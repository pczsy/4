<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修2019年腾讯最新Java工程师面试题' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>2019年腾讯最新Java工程师面试题</center></div><div class='banquan'>原文出处:本文由博客园博主程序媛的明天提供。<br/>
原文连接:https://www.cnblogs.com/a609251438/p/11897905.html</div><br>
    <src class="part-title">
<h4>一、单选题（共21题，每题5分）</h4>

<src class="panel panel-default que-block">
<src class="panel-heading que-title">
<src class="item-title"><strong><em>1</em>在正则表达式当中下面那一个字符集表示非空格字符</strong>

<src class="panel-body form-group que-option">
<src class="line-numbers">&nbsp;
<src class="radio"><label><input type="radio" name="radio12925" value="A" checked="checked" disabled="disabled" />A、[:graph:]</label>
<src class="radio"><label><input type="radio" name="radio12925" value="B" disabled="disabled" />B、[:digit:]</label>
<src class="radio"><label><input type="radio" name="radio12925" value="C" disabled="disabled" />C、[:space:]</label>
<src class="radio"><label><input type="radio" name="radio12925" value="D" disabled="disabled" />D、[:alpha:]</label>
<src class="text-default"><label>参考答案：</label>A
<src class="text-default"><label>答案解析：</label>
<p>A</p>

<src class="text-warning">&nbsp;


<src class="panel panel-default que-block">
<src class="panel-heading que-title">
<src class="item-title"><strong><em>2</em>下列叙述中，错误的是( )。</strong>

<src class="panel-body form-group que-option">
<src class="line-numbers">&nbsp;
<src class="radio"><label><input type="radio" name="radio12196" value="A" disabled="disabled" />A、&nbsp;内部类可访问它所在类的成员</label>
<src class="radio"><label><input type="radio" name="radio12196" value="B" disabled="disabled" />B、&nbsp;内部类的名称与定义它的类的名称可以相同</label>
<src class="radio"><label><input type="radio" name="radio12196" value="C" disabled="disabled" />C、&nbsp;内部类可用abstract修饰</label>
<src class="radio"><label><input type="radio" name="radio12196" value="D" disabled="disabled" />D、&nbsp;内部类可作为其他类的成员</label>
<src class="text-default"><label>参考答案：</label>A
<src class="text-default"><label>答案解析：</label>
<p>暂无</p>

<src class="text-warning">&nbsp;


<src class="panel panel-default que-block">
<src class="panel-heading que-title">
<src class="item-title"><strong><em>3</em>以下哪个排序算法中，元素的比较次数元素与元素的初始排列无关（）</strong>

<src class="panel-body form-group que-option">
<src class="line-numbers">&nbsp;
<src class="radio"><label><input type="radio" name="radio116635" value="A" disabled="disabled" />A、希尔排序</label>
<src class="radio"><label><input type="radio" name="radio116635" value="B" disabled="disabled" />B、快速排序</label>
<src class="radio"><label><input type="radio" name="radio116635" value="C" disabled="disabled" />C、归并排序</label>
<src class="radio"><label><input type="radio" name="radio116635" value="D" disabled="disabled" />D、直接插入排序</label>
<src class="radio"><label><input type="radio" name="radio116635" value="E" disabled="disabled" />E、选择排序</label>
<src class="text-default"><label>参考答案：</label>E
<src class="text-warning">&nbsp;


<src class="panel panel-default que-block">
<src class="panel-heading que-title">
<src class="item-title"><strong><em>4</em>下面程序的输出结果是什么。</strong>

<src class="panel-body form-group que-option">
<src class="line-numbers">
<src><strong>下面程序的输出结果是什么。</strong>
```
<src class="cnblogs_code">
<pre><code><span style="color: #008080;"> 1</span> <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> A2{ 
</span><span style="color: #008080;"> 2</span> <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args){
</span><span style="color: #008080;"> 3</span>     <span style="color: #0000ff;">int</span>[] a={2,4,6,8,3,6,9,12<span style="color: #000000;">};
</span><span style="color: #008080;"> 4</span>     doSomething(a,0,a.length-1<span style="color: #000000;">);
</span><span style="color: #008080;"> 5</span>     <span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=0;i=<span style="color: #000000;">x){
</span><span style="color: #008080;"> 6</span> <span style="color: #000000;">            swap(a,i,j);
</span><span style="color: #008080;"> 7</span>             i++;<span style="color: #008000;">//</span><span style="color: #008000;">交换了几次 </span>
<span style="color: #008080;"> 8</span> <span style="color: #000000;">        }
</span><span style="color: #008080;"> 9</span>     }<span style="color: #008000;">//</span><span style="color: #008000;">把最大的放到最后</span>
<span style="color: #008080;">10</span>     swap(a,i,end);<span style="color: #008000;">//</span><span style="color: #008000;">把最大的放到i的位置 </span>
<span style="color: #008080;">11</span>     <span style="color: #0000ff;">return</span><span style="color: #000000;"> i;
</span><span style="color: #008080;">12</span> <span style="color: #000000;">} 
</span><span style="color: #008080;">13</span>  
<span style="color: #008080;">14</span> <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> swap(<span style="color: #0000ff;">int</span>[] a,<span style="color: #0000ff;">int</span> i,<span style="color: #0000ff;">int</span><span style="color: #000000;"> j) 
</span><span style="color: #008080;">15</span> <span style="color: #000000;">{
</span><span style="color: #008080;">16</span>     <span style="color: #0000ff;">int</span> tmp=<span style="color: #000000;">a[i];
</span><span style="color: #008080;">17</span>     a[i]=<span style="color: #000000;">a[j];
</span><span style="color: #008080;">18</span>     a[j]=<span style="color: #000000;">tmp;
</span><span style="color: #008080;">19</span> <span style="color: #000000;">}
</span><span style="color: #008080;">20</span> <span style="color: #000000;">} 
</span><span style="color: #008080;">21</span> ```                           </code></pre>

<p>&nbsp;</p>

<src class="radio"><label><input type="radio" name="radio85675" value="A" disabled="disabled" />A、找到最大值</label>
<src class="radio"><label><input type="radio" name="radio85675" value="B" disabled="disabled" />B、找到最小值</label>
<src class="radio"><label><input type="radio" name="radio85675" value="C" disabled="disabled" />C、从大到小的排序</label>
<src class="radio"><label><input type="radio" name="radio85675" value="D" disabled="disabled" />D、从小到大的排序</label>
<src class="text-default"><label>参考答案：</label>C
<src class="text-default"><label>答案解析：</label>
<src class="line number24 index23 alt1">开始被注释迷惑了半天。
<src class="line number24 index23 alt1">按快排的思想，遍历数组将比x大的按顺序存至a\[0\]a\[1\]a\[2\]..此时j负责遍历数组，i负责依次指向下一次
<src class="line number24 index23 alt1">遍历判断得到的大于x的数该存储的位置，每一次成功存储向后移动一格
<src class="line number24 index23 alt1">&nbsp;
<src class="line number24 index23 alt1">![](https://storage.kuibuke.com/source/1/Eawsn8OjUtldwcCznJeyAa-L2dkhbIeK.)
<src class="line number24 index23 alt1">![](https://storage.kuibuke.com/source/1/r_qNSSJe5jKn7YAjOeVqW87cD14xy3SB.)
<src class="line number24 index23 alt1">![](https://storage.kuibuke.com/source/1/P_3qexdojr61Po55nN0C_TegJw5vWnl_.)
<src class="line number24 index23 alt1">swap(a,i,end);//把最大的放到i的位置
<src class="line number24 index23 alt1">应该是将x交换至分界点，（&nbsp;x并非最大&nbsp;）至此一趟core完成，x左侧大于x，x右侧小于x,x左右任是无序数列
<src class="line number24 index23 alt1">然后依据分治的思想，对左序列，右序列迭代。当分至每个序列只有一个元素序列必然有序。
<src class="line number24 index23 alt1">最终达到排序目的。(灵魂手绘轻喷)
<src class="line number24 index23 alt1">&nbsp;
<src class="line number24 index23 alt1">&nbsp;

<src class="text-warning">&nbsp;


<src class="panel panel-default que-block">
<src class="panel-heading que-title">
<src class="item-title"><strong><em>5</em>以下关于hive以及Hadoop生态系统中其他组件的说法正确的是</strong>

<src class="panel-body form-group que-option">
<src class="line-numbers">&nbsp;
<src class="radio"><label><input type="radio" name="radio117552" value="A" disabled="disabled" />A、Hbase依赖HDFS存储数据，实现的编程语言为Java</label>
<src class="radio"><label><input type="radio" name="radio117552" value="B" disabled="disabled" />B、Hbase是一个面向列分布式数据库，和hive不同的是，hbase能够在它的数据库上实时运行，而不是运行mapreduce任务</label>
<src class="radio"><label><input type="radio" name="radio117552" value="C" disabled="disabled" />C、hive不支持数据更新，延迟比较小，可用于实时查询系统</label>
<src class="radio"><label><input type="radio" name="radio117552" value="D" disabled="disabled" />D、hive采用了SQL的查询语言HQL，其支持了SQL中的所有特性</label>
<src class="text-default"><label>参考答案：</label>B
<src class="text-default"><label>答案解析：</label>
<p>Hbase是一个面向列分布式数据库，和hive不同的是，hbase能够在它的数据库上实时运行，而不是运行mapreduce任务发生的</p>

<src class="text-warning">&nbsp;


<src class="panel panel-default que-block">
<src class="panel-heading que-title">
<src class="item-title"><strong><em>6</em>以下JAVA程序的输出是什么（）</strong>

<src class="panel-body form-group que-option">
<src class="line-numbers">
<p><strong>以下JAVA程序的输出是什么（）</strong></p>
<src class="cnblogs_code">
<pre><code><span style="color: #008080;"> 1</span> &lt;pre <span style="color: #0000ff;">class</span>="prettyprint"&gt;<span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> HelloSogou{
</span><span style="color: #008080;"> 2</span>      <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">synchronized</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] a){
</span><span style="color: #008080;"> 3</span>          Thread t=<span style="color: #0000ff;">new</span><span style="color: #000000;"> Thread(){
</span><span style="color: #008080;"> 4</span>              <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> run(){Sogou();}
</span><span style="color: #008080;"> 5</span> <span style="color: #000000;">     };
</span><span style="color: #008080;"> 6</span> <span style="color: #000000;">     t.run();
</span><span style="color: #008080;"> 7</span>      System.out.print("Hello"<span style="color: #000000;">);
</span><span style="color: #008080;"> 8</span> <span style="color: #000000;">     }
</span><span style="color: #008080;"> 9</span>      <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">synchronized</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> Sogou(){
</span><span style="color: #008080;">10</span>      System.out.print("Sogou"<span style="color: #000000;">);
</span><span style="color: #008080;">11</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">12</span> }</code></pre>

<p>&nbsp;</p>

<src class="radio"><label><input type="radio" name="radio85081" value="A" disabled="disabled" />A、HelloSogou</label>
<src class="radio"><label><input type="radio" name="radio85081" value="B" disabled="disabled" />B、SogouHello</label>
<src class="radio"><label><input type="radio" name="radio85081" value="C" disabled="disabled" />C、Hello</label>
<src class="radio"><label><input type="radio" name="radio85081" value="D" disabled="disabled" />D、结果不确定</label>
<src class="text-default"><label>参考答案：</label>B
<src class="text-default"><label>答案解析：</label>
<src>我觉得误区有两个：一个是run和start区别，Thread.run()是调用方法，Thread.&nbsp;start()是启动线程；另一个是锁持有问题。这个题是调用方法，和多线程就无关。本题只有一个线程，持有HelloSogou.class锁。那么，就是另一个问题：同步方法调用另一个同步方法的锁问题？
<src>&nbsp;
<src>public synchronized void methodA(int a, int b){} public synchronized void methodB(int a）{ methodA(a, 0);
<src>}
<src>首先要明白两个问题，**1.锁的对象是谁？2.谁持有了锁？**
<src>假设方法A和B是在同一个类Test中的两个方法。 Test t=new Test(); t.methodB();
<src>调用methodB()方法，获得锁，锁是对象**t**；锁谁持有？当前线程（不可以说是methodB持有该锁），methodB又调用methodA，也需要锁**t**，该线程已持有**t**，当然可以直接调用methodA。
<src>&nbsp;
<src>类比到此题，只有一个主线程，调用main，持有HelloSogou.class锁，那当然可以直接调用Sogou方法。
<src>&nbsp;
<src>第二，如果是**t.statrt()**，那么这个题，**静态同步函数的锁是该类的字节码文件.class。**此题中，main函数和Sogou方法都是static的，所以持有相同**锁**&nbsp;**HelloSogou.class**&nbsp;，那么，在main线程（main&nbsp;是一个线程也是一个进程&nbsp;）中又开了一个线程，调用Sogou方法，锁会冲突。
<src>&nbsp;
<src>我的分析是：调用main函数（一个线程），main函数开启另一个线程，并启动，但是main函数和Sogou方法是同一个锁，所以main函数执行完毕后才会释放锁，Sogou方法才会执行，这就是为什么，换成start，是HelloSogou。
<src>第三，将Sogou方法的锁改为其他.class锁，那么，HelloSogou和SogouHello都可能出现。因为没有互斥现象了，变为抢占式的了。

<src class="text-warning">&nbsp;


<src class="panel panel-default que-block">
<src class="panel-heading que-title">
<src class="item-title"><strong><em>7</em>下列关于Java语言中线程的叙述中，正确的是（　　）。</strong>

<src class="panel-body form-group que-option">
<src class="line-numbers">&nbsp;
<src class="radio"><label><input type="radio" name="radio5933" value="A" disabled="disabled" />A、线程由代码、数据、内核状态和－组寄存器组成</label>
<src class="radio"><label><input type="radio" name="radio5933" value="B" disabled="disabled" />B、线程间的数据是不共享的</label>
<src class="radio"><label><input type="radio" name="radio5933" value="C" disabled="disabled" />C、用户只能通过创建Thread类的实例或者定义和创建Thread子类的实例，建立和控制自己的线程</label>
<src class="radio"><label><input type="radio" name="radio5933" value="D" disabled="disabled" />D、因多线程并发执行而引起的执行顺序的不确定性可能造成执行结果的不确定</label>
<src class="text-default"><label>参考答案：</label>D
<src class="text-default"><label>答案解析：</label>
<p>本题考查线程的基本知识。线程与进程在概念上是相关的，线程是由表示程序运行状态的寄存器、程序计数器、栈指针以及堆栈组成，它不包含进程地址空间中的代码 和数据。代码所操作的数据是Java线程模型中的一个组成部分，数据与代码是独立的。数据可以被多个线程共享，也可不共享。Java语言中提供两种创建线 程的方法，－种是通过继承Thread类创建线程，另－种是通过实现Runnable接口来创建线程。</p>
<src>&nbsp;

<src class="text-warning">&nbsp;


<src class="panel panel-default que-block">
<src class="panel-heading que-title">
<src class="item-title"><strong><em>8</em>通过Intent传递一些二进制数据的方法有哪些？</strong>

<src class="panel-body form-group que-option">
<src class="line-numbers">
<src>通过Intent传递一些二进制数据的方法有哪些？
<src>A、使用Serializable接口实现序列化，这是java常用的方法
<src>B、实现Parcelable接口，这里Andriod的部分分类比如Bitmap类就已经实现了，同时Parcelable在Android AIDL中交换数据也很常见

<src class="radio"><label><input type="radio" name="radio67050" value="A" disabled="disabled" />A、A</label>
<src class="radio"><label><input type="radio" name="radio67050" value="B" disabled="disabled" />B、B</label>
<src class="radio"><label><input type="radio" name="radio67050" value="C" disabled="disabled" />C、AB</label>
<src class="text-default"><label>参考答案：</label>C
<src class="text-default"><label>答案解析：</label>
<p>Android中实现序列化有两个选择：一是实现Serializable接口（是JavaSE本身就支持的），一是实现Parcelable接口（是Android特有功能，效率比实现Serializable接口高效，可用于Intent数据传递，也可以用于进程间通信（IPC））。实现Serializable接口非常简单，声明一下就可以了，而实现Parcelable接口稍微复杂一些，但效率更高，推荐用这种方法提高性能。</p>
<p>注：Android中Intent传递对象有两种方法：一是Bundle.putSerializable(Key，Object)，另一种是Bundle.putParcelable(Key，Object)。当然这些Object是有一定的条件的，前者是实现了Serializable接口，而后者是实现了Parcelable接口。</p>

<src class="text-warning">&nbsp;


<src class="panel panel-default que-block">
<src class="panel-heading que-title">
<src class="item-title"><strong><em>9</em>在Java中，JDBC API定义了一组用于与数据库进行通信的接口和类，它们包括在（&nbsp;&nbsp; ）包中。</strong>

<src class="panel-body form-group que-option">
<src class="line-numbers">&nbsp;
<src class="radio"><label><input type="radio" name="radio27054" value="A" disabled="disabled" />A、java.lang</label>
<src class="radio"><label><input type="radio" name="radio27054" value="B" disabled="disabled" />B、java.sql</label>
<src class="radio"><label><input type="radio" name="radio27054" value="C" disabled="disabled" />C、java.util</label>
<src class="radio"><label><input type="radio" name="radio27054" value="D" disabled="disabled" />D、java.math</label>
<src class="text-default"><label>参考答案：</label>B
<src class="text-default"><label>答案解析：</label>
<p>暂无</p>

<src class="text-warning">&nbsp;


<src class="panel panel-default que-block">
<src class="panel-heading que-title">
<src class="item-title"><em>10</em>关于计算机网络，以下说法正确的是 (1)在向下的过程中，需要添加下层...

<src class="panel-body form-group que-option">
<src class="line-numbers">
<src>关于计算机网络，以下说法正确的是
<src>(1)在向下的过程中，需要添加下层协议所需要的首部或者尾部
<src>(2)在向上的过程中不断拆开首部和尾部
<src>(3)在向上的过程中，需要添加下层协议所需要的首部或者尾部
<src>(4)在向下的过程中不断拆开首部和尾部
<src>(5)SMTP属于TCP协议
<src>(6)POP3属于UDP协议
<src>(7)DNS属于TCP协议
<src>(8)Telnet属于UDP协议

<src class="radio"><label><input type="radio" name="radio107802" value="A" disabled="disabled" />A、(1)(2)(5)</label>
<src class="radio"><label><input type="radio" name="radio107802" value="B" disabled="disabled" />B、(1)(2)(6)</label>
<src class="radio"><label><input type="radio" name="radio107802" value="C" disabled="disabled" />C、(1)(2)(8)</label>
<src class="radio"><label><input type="radio" name="radio107802" value="D" disabled="disabled" />D、(3)(4)(5)(6)</label>
<src class="radio"><label><input type="radio" name="radio107802" value="E" disabled="disabled" />E、(3)(4)(5)(7)</label>
<src class="text-default"><label>参考答案：</label>A
<src class="text-default"><label>答案解析：</label>
<src>1）TCP (Transmission Control Protocol)和UDP(User Datagram Protocol)协议属于[传输层](https://baike.baidu.com/item/%E4%BC%A0%E8%BE%93%E5%B1%82)协议。
<src>2）其中TCP提供IP环境下的数据[可靠传输](https://baike.baidu.com/item/%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93)，它提供的服务包括[数据流](https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E6%B5%81)传送、可靠性、有效流控、全双工操作和多路复用。通过面向连接、端到端和可靠的[数据包](https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%8C%85)发送。通俗说，它是事先为所发送的数据开辟出连接好的通道，然后再进行数据发送；一般来说，TCP对应的是可靠性要求高的应用。
<src>3）而UDP则不为IP提供可靠性、流控或差错恢复功能。UDP对应的则是可靠性要求低、传输经济的应用。
<src>4）TCP支持的应用协议主要有：Telnet、FTP、SMTP等；
<src>5）&nbsp;TCP对应的协议：&nbsp;（1）&nbsp;FTP：定义了文件传输协议，使用21端口。&nbsp;（2）&nbsp;Telnet：一种用于远程登陆的端口，使用23端口，用户可以以自己的身份远程连接到计算机上，可提供基于DOS模式下的通信服务。&nbsp;（3）&nbsp;SMTP：邮件传送协议，用于发送邮件。服务器开放的是25号端口。&nbsp;（4）&nbsp;POP3：它是和SMTP对应，POP3用于接收邮件。POP3协议所用的是110端口。&nbsp;（5）HTTP：是从Web服务器传输超文本到本地浏览器的传送协议。&nbsp;UDP对应的协议：&nbsp;（1）&nbsp;DNS：用于域名解析服务，将域名地址转换为IP地址。DNS用的是53号端口。&nbsp;（2）&nbsp;SNMP：简单网络管理协议，使用161号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。&nbsp;（3）&nbsp;TFTP(Trival File Tran敏感词er Protocal)，简单文件传输协议，该协议在熟知端口69上使用UDP服务。

<src class="text-warning">&nbsp;


<src class="panel panel-default que-block">
<src class="panel-heading que-title">
<src class="item-title"><strong><em>11</em>Java是一门面向对象的编程语言，下面关键字中能够表示Java面向对象的特...</strong>

<src class="panel-body form-group que-option">
<src class="line-numbers">
<p><strong>Java是一门面向对象的编程语言，下面关键字中能够表示Java面向对象的特性是（）</strong></p>

<src class="radio"><label><input type="radio" name="radio114403" value="A" disabled="disabled" />A、extends, interface</label>
<src class="radio"><label><input type="radio" name="radio114403" value="B" disabled="disabled" />B、volatite, implements</label>
<src class="radio"><label><input type="radio" name="radio114403" value="C" disabled="disabled" />C、abstract, interface</label>
<src class="radio"><label><input type="radio" name="radio114403" value="D" disabled="disabled" />D、static, void</label>
<src class="text-default"><label>参考答案：</label>A
<src class="text-default"><label>答案解析：</label>
<p>A</p>

<src class="text-warning">&nbsp;


<src class="panel panel-default que-block">
<src class="panel-heading que-title">
<src class="item-title"><strong><em>12</em>下面关于操作系统的进程说法正确的有?</strong>

<src class="panel-body form-group que-option">
<src class="line-numbers"><strong>&nbsp;</strong>
<src class="radio"><label><input type="radio" name="radio118070" value="A" disabled="disabled" />A、系统中进程的数目越多，CPU的利用率就越高</label>
<src class="radio"><label><input type="radio" name="radio118070" value="B" disabled="disabled" />B、同一个进程的多个线程共享状况为堆共享，栈私有</label>
<src class="radio"><label><input type="radio" name="radio118070" value="C" disabled="disabled" />C、只有使用了多进程技术才会发生死锁问题</label>
<src class="radio"><label><input type="radio" name="radio118070" value="D" disabled="disabled" />D、进程和线程都有独立的地址空间</label>
<src class="text-default"><label>参考答案：</label>B
<src class="text-default"><label>答案解析：</label>
<p>死锁不仅可以发生在多线程中，也可以发生在多个进程中。只要是因争抢资源导致互相等待，无外力作用无法前进的都可以称为死锁</p>

<src class="text-warning">&nbsp;


<src class="panel panel-default que-block">
<src class="panel-heading que-title">
<src class="item-title"><strong><em>13</em>下列关于Java布尔类型的描述中，正确的是（　　）。</strong>

<src class="panel-body form-group que-option">
<src class="line-numbers"><strong>&nbsp;</strong>
<src class="radio"><label><input type="radio" name="radio38220" value="A" disabled="disabled" />A、&nbsp;－种基本的数据类型，它的类型名称为boolean</label>
<src class="radio"><label><input type="radio" name="radio38220" value="B" disabled="disabled" />B、&nbsp;用int表示类型</label>
<src class="radio"><label><input type="radio" name="radio38220" value="C" disabled="disabled" />C、&nbsp;其值可以赋给int类型的变量</label>
<src class="radio"><label><input type="radio" name="radio38220" value="D" disabled="disabled" />D、&nbsp;有两个值，l代表真，0代表假</label>
<src class="text-default"><label>参考答案：</label>A
<src class="text-default"><label>答案解析：</label>
<p>暂无</p>

<src class="text-warning">&nbsp;


<src class="panel panel-default que-block">
<src class="panel-heading que-title">
<src class="item-title"><strong><em>14</em>下面有关java classloader说法错误的是?</strong>

<src class="panel-body form-group que-option">
<src class="line-numbers">&nbsp;
<src class="radio"><label><input type="radio" name="radio85945" value="A" disabled="disabled" />A、Java默认提供的三个ClassLoader是BootStrap ClassLoader，Extension ClassLoader，App ClassLoader</label>
<src class="radio"><label><input type="radio" name="radio85945" value="B" disabled="disabled" />B、ClassLoader使用的是双亲委托模型来搜索类的</label>
<src class="radio"><label><input type="radio" name="radio85945" value="C" disabled="disabled" />C、JVM在判定两个class是否相同时，只用判断类名相同即可，和类加载器无关</label>
<src class="radio"><label><input type="radio" name="radio85945" value="D" disabled="disabled" />D、ClassLoader就是用来动态加载class文件到内存当中用的</label>
<src class="text-default"><label>参考答案：</label>C
<src class="text-default"><label>答案解析：</label>
<p>一个jvm中默认的classloader有Bootstrap ClassLoader、Extension ClassLoader、App ClassLoader，分别各司其职：</p>
<ul>
<li><strong>Bootstrap ClassLoader</strong>&nbsp;负责加载java基础类，主要是 %JRE_HOME/lib/ 目录下的rt.jar、resources.jar、charsets.jar和class等</li>
<li><strong>Extension ClassLoader</strong>&nbsp;负责加载java扩展类，主要是 %JRE_HOME/lib/ext 目录下的jar和class</li>
<li><strong>App ClassLoader</strong>&nbsp;负责加载当前java应用的classpath中的所有类。</li>
</ul>
<p>classloader 加载类用的是全盘负责委托机制。<em>所谓全盘负责，即是当一个classloader加载一个Class的时候，这个Class所依赖的和引用的所有 Class也由这个classloader负责载入，除非是显式的使用另外一个classloader载入。</em><br />所以，当我们自定义的classloader加载成功了com.company.MyClass以后，MyClass里所有依赖的class都由这个classLoader来加载完成。</p>


<src class="text-warning">&nbsp;




<src class="panel panel-default que-block">
<src class="panel-heading que-title">
<src class="item-title"><strong><em>15</em>HTTPS是一种安全的HTTP协议，它使用 （ ） 来保证信息安全？</strong>


<src class="panel-body form-group que-option">
<src class="line-numbers">&nbsp;
<src class="radio"><label><input type="radio" name="radio1953" value="A" disabled="disabled" />A、IPSec&nbsp;</label>
<src class="radio"><label><input type="radio" name="radio1953" value="B" disabled="disabled" />B、SSL</label>
<src class="radio"><label><input type="radio" name="radio1953" value="C" disabled="disabled" />C、SET</label>
<src class="radio"><label><input type="radio" name="radio1953" value="D" disabled="disabled" />D、SSH</label>
<src class="text-default"><label>参考答案：</label>B
<src class="text-default"><label>答案解析：</label>
<p>SSL是解决传输层安全问题的一个主要协议，其设计的初衷是基于TCP协议之上提供可靠的端到端安全服务。应用SSL协议最广泛的是HTTPS，它为客户浏览器和Web服务器之间交换信息提供安全通信支持。它使用TCP的443端口发送和接收报文。</p>


<src class="text-warning">&nbsp;




<src class="panel panel-default que-block">
<src class="panel-heading que-title">
<src class="item-title"><strong><em>16</em>下列能够正确创建线程的方法是 ?</strong>


<src class="panel-body form-group que-option">
<src class="line-numbers">
<ul>
<li>①．继承java．lang．Thread类，并重写run（　　）方法</li>
<li>②．继承java．lang．Runnable类，并重写start（　　）方法</li>
<li>③．实现java．lang．Thread接口，并实现run（　　）方法</li>
<li>④．实现java．lang．Runable接口．并实现run（　　）方法</li>

</ul>


<src class="radio"><label><input type="radio" name="radio5965" value="A" disabled="disabled" />A、①，③</label>
<src class="radio"><label><input type="radio" name="radio5965" value="B" disabled="disabled" />B、②，④</label>
<src class="radio"><label><input type="radio" name="radio5965" value="C" disabled="disabled" />C、②，③</label>
<src class="radio"><label><input type="radio" name="radio5965" value="D" disabled="disabled" />D、①，④</label>
<src class="text-default"><label>参考答案：</label>D
<src class="text-default"><label>答案解析：</label>
<p>用Thread类的构造方法Thread(Runnable target)创建线程对象时，构造方法中的参数必须是一个具体的对象，该对象称作线程的目标对象，创建目标对象的类必须要实现Runnable接口。</p>
<src>&nbsp;


<src class="text-warning">&nbsp;




<src class="panel panel-default que-block">
<src class="panel-heading que-title">
<src class="item-title"><strong><em>17</em>given the following code,what will be the output?</strong>

<src class="panel-body form-group que-option">
<src class="line-numbers">
<src class="code-toolbar">
<src class="cnblogs_code">
<pre><code><span style="color: #008080;"> 1</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Value{
</span><span style="color: #008080;"> 2</span>     <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">int</span> i=15<span style="color: #000000;">;
</span><span style="color: #008080;"> 3</span> <span style="color: #000000;">}
</span><span style="color: #008080;"> 4</span> <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Test{
</span><span style="color: #008080;"> 5</span>     <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String argv[]){
</span><span style="color: #008080;"> 6</span>         Test t=<span style="color: #0000ff;">new</span><span style="color: #000000;"> Test( );
</span><span style="color: #008080;"> 7</span> <span style="color: #000000;">        t.first( );
</span><span style="color: #008080;"> 8</span> <span style="color: #000000;">    }
</span><span style="color: #008080;"> 9</span> 
<span style="color: #008080;">10</span> <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> first( ){
</span><span style="color: #008080;">11</span>     <span style="color: #0000ff;">int</span> i=5<span style="color: #000000;">;
</span><span style="color: #008080;">12</span>     Value v=<span style="color: #0000ff;">new</span><span style="color: #000000;"> Value( );
</span><span style="color: #008080;">13</span>     v.i=25<span style="color: #000000;">;
</span><span style="color: #008080;">14</span> <span style="color: #000000;">    second(v,i);
</span><span style="color: #008080;">15</span> <span style="color: #000000;">    System.out.println(v.i);
</span><span style="color: #008080;">16</span> <span style="color: #000000;">}
</span><span style="color: #008080;">17</span> 
<span style="color: #008080;">18</span> <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> second(Value v,<span style="color: #0000ff;">int</span><span style="color: #000000;"> i){
</span><span style="color: #008080;">19</span>     i = 0<span style="color: #000000;">;
</span><span style="color: #008080;">20</span>     v.i = 20<span style="color: #000000;">;
</span><span style="color: #008080;">21</span>     Value val = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Value( );
</span><span style="color: #008080;">22</span>     v =<span style="color: #000000;"> val;
</span><span style="color: #008080;">23</span>     System.out.println(v.i+" "+<span style="color: #000000;">i);
</span><span style="color: #008080;">24</span> <span style="color: #000000;">   }
</span><span style="color: #008080;">25</span> }</code></pre>

<p>&nbsp;</p>
<src class="toolbar">
<src class="toolbar-item">&nbsp;



<src class="radio"><label><input type="radio" name="radio87528" value="A" disabled="disabled" />A、15 0 20</label>
<src class="radio"><label><input type="radio" name="radio87528" value="B" disabled="disabled" />B、15 0 15</label>
<src class="radio"><label><input type="radio" name="radio87528" value="C" disabled="disabled" />C、20 0 20</label>
<src class="radio"><label><input type="radio" name="radio87528" value="D" disabled="disabled" />D、0 15 20</label>
<src class="text-default"><label>参考答案：</label>A
<src class="text-default"><label>答案解析：</label>
<p>![](<a href="https://storage.kuibuke.com/source/1/1IhReVK1/_lhieKPRakZwi7kZdUrMZm/_k">https://storage.kuibuke.com/source/1/1IhReVK1\_lhieKPRakZwi7kZdUrMZm\_k</a>.)</p>

<src class="text-warning">&nbsp;


<src class="panel panel-default que-block">
<src class="panel-heading que-title">
<src class="item-title"><strong><em>18</em>如果希望在网络中通过某个类的对象包装数据进行传输，那么这个类需要实现下面哪...</strong>

<src class="panel-body form-group que-option">
<src class="line-numbers">
<p><strong>如果希望在网络中通过某个类的对象包装数据进行传输，那么这个类需要实现下面哪个接口？（）</strong></p>

<src class="radio"><label><input type="radio" name="radio114383" value="A" disabled="disabled" />A、Cloneable</label>
<src class="radio"><label><input type="radio" name="radio114383" value="B" disabled="disabled" />B、Comparable</label>
<src class="radio"><label><input type="radio" name="radio114383" value="C" disabled="disabled" />C、Serializable</label>
<src class="radio"><label><input type="radio" name="radio114383" value="D" disabled="disabled" />D、Runnable</label>
<src class="text-default"><label>参考答案：</label>C
<src class="text-warning">&nbsp;


<src class="panel panel-default que-block">
<src class="panel-heading que-title">
<src class="item-title"><strong><em>19</em>linux查看系统IP地址以及网卡流量可以使用以下哪个命令</strong>

<src class="panel-body form-group que-option">
<src class="line-numbers"><strong>&nbsp;</strong>
<src class="radio"><label><input type="radio" name="radio114329" value="A" disabled="disabled" />A、ipconfig</label>
<src class="radio"><label><input type="radio" name="radio114329" value="B" disabled="disabled" />B、ifconfig</label>
<src class="radio"><label><input type="radio" name="radio114329" value="C" disabled="disabled" />C、netstat</label>
<src class="radio"><label><input type="radio" name="radio114329" value="D" disabled="disabled" />D、ss</label>
<src class="text-default"><label>参考答案：</label>B
<src class="text-default"><label>答案解析：</label>
<p>Windows下是ipconfig，Linux下是ifconfig</p>

<src class="text-warning">&nbsp;


<src class="panel panel-default que-block">
<src class="panel-heading que-title">
<src class="item-title"><strong><em>20</em>数据的存储结构是指____。</strong>

<src class="panel-body form-group que-option">
<src class="line-numbers">&nbsp;
<src class="radio"><label><input type="radio" name="radio22328" value="A" disabled="disabled" />A、&nbsp;存储在外存中的数据</label>
<src class="radio"><label><input type="radio" name="radio22328" value="B" disabled="disabled" />B、&nbsp;数据所占的存储空间</label>
<src class="radio"><label><input type="radio" name="radio22328" value="C" disabled="disabled" />C、&nbsp;数据在计算机中的顺序存储方式</label>
<src class="radio"><label><input type="radio" name="radio22328" value="D" disabled="disabled" />D、&nbsp;数据的逻辑结构在计算机中的表示</label>
<src class="text-default"><label>参考答案：</label>D
<src class="text-default"><label>答案解析：</label>
<p>暂无</p>

<src class="text-warning">&nbsp;


<src class="panel panel-default que-block">
<src class="panel-heading que-title">
<src class="item-title"><strong><em>21</em>封装、继承和多态是面向对象编程的三大特征，在java 开发过程中有着广泛应用。以下关于它们的描述不正确的是： （ ）</strong>

<src class="panel-body form-group que-option">
<src class="line-numbers">&nbsp;
<src class="radio"><label><input type="radio" name="radio26007" value="A" disabled="disabled" />A、封装是将数据和基于数据的操作封装成一个整体对象，通过接口实现对数据的访问和修改</label>
<src class="radio"><label><input type="radio" name="radio26007" value="B" disabled="disabled" />B、继承关系中共有的类属性特征均需在父类和子类中进行说明</label>
<src class="radio"><label><input type="radio" name="radio26007" value="C" disabled="disabled" />C、多态使得一个类实例的相同方法在不同情形有不同表现形式</label>
<src class="radio"><label><input type="radio" name="radio26007" value="D" disabled="disabled" />D、多态机制使具有不同内部结构的对象可以共享相同的外部接口</label>
<src class="text-default"><label>参考答案：</label>B
<src class="text-default"><label>答案解析：</label>
<p><span style="font-family: 宋体;">答案：</span>B解析：<span style="font-family: 宋体;">根据《系统集成项目管理工程师教程（第</span>2<span style="font-family: 宋体;">版）》第137</span><span style="font-family: 宋体;">页，继承表示类之间的层次关系（父类与子类），这种关系使得某类对象可以集成另外一类对象的特征。</span><span style="font-family: 宋体;">所以继承关系中共有类属性只要在父类中进行说明即可，子类不需要了。</span></p>

<src class="text-warning">&nbsp;


<src class="part-title">
<h4>二、多选题（共8题，每题5分）</h4>

<src class="panel panel-default que-block">
<src class="panel-heading que-title">
<src class="item-title"><strong><em>1</em>在Java语言中，下列关于字符集编码（Character set encoding）和国际化（i18n）的问题，哪些是正确的？</strong>

<src class="panel-body form-group que-option">
<src class="line-numbers">&nbsp;
<src class="checkbox"><label><input type="checkbox" name="checkbox86400[]" value="A" disabled="disabled" />A、每个中文字符占用2个字节，每个英文字符占用1个字节</label>
<src class="checkbox"><label><input type="checkbox" name="checkbox86400[]" value="B" disabled="disabled" />B、假设数据库中的字符是以GBK编码的，那么显示数据库数据的网页也必须是GBK编码的。</label>
<src class="checkbox"><label><input type="checkbox" name="checkbox86400[]" value="C" disabled="disabled" />C、Java的char类型，通常以UTF-16 Big Endian的方式保存一个字符。</label>
<src class="checkbox"><label><input type="checkbox" name="checkbox86400[]" value="D" disabled="disabled" />D、实现国际化应用常用的手段是利用ResourceBundle类</label>
<src class="text-default"><label>参考答案：</label>C,D
<src class="text-default"><label>答案解析：</label>
<p>收到很多赞，感谢诸君阅读捧场<br />在此针对评论区的一些意见发表如下声明：</p>
<ol>
<li>这个回答不会给你解释题目与分析解题过程。这个回答的目的是科普。为的是从根本上向大家解释清楚Unicode的玩法。如果读者只是想了解解题过程和选项分析，请看本题的推荐答案。</li>
<li>一些朋友说这个答案是复制粘贴过来的。我想一千个读者有一千个哈姆雷特。我无论说什么其实都无法改变读者内心认定的那个结论。所以，大家开心就好。为了这个目的，大家不妨先问问自己是不是真的想要了解Unicode的基础知识？如果是，那么欢迎您继续下面的旅程。</li>

</ol><hr />
<p>很多人都把Unicode编码挂在嘴边，其实咱们现实生活中遇到的编码基本都是Unicode的</p>
<p>因为Unicode兼容了大多数老版本的编码规范例如 ASCII</p>
<p>Unicode编码定义了这个世界上几乎所有字符（就是你眼睛看到的长那个样子的符号）的数字表示</p>
<p>也就是说Unicode为每个字符发了一张身份证，这张身份证上有一串唯一的数字ID确定了这个字符</p>
<p>在这个纷乱世界上存在的唯一性。Unicode给这串数字ID起了个名字叫<strong>［码点］（Code Point）</strong></p>
<p>而很多人说的编码其实是想表达<strong>［Unicode转换格式］（即UTF，Unicode Transformation Formats）</strong></p>
<p>有没有觉得眼前一亮豁然开朗？没错 这就是我们看到的UTF-8/UTF-16/UTF-32的前缀来源</p>
<p>这个［Unicode转换格式］的存在是为了解决［码点］在计算机中的二进制表现形式而设计的</p>
<p>毕竟我们的机内表示涉及存储位宽，兼容古老编码格式，码点是数值过大的罕见字符等问题</p>
<p>［码点］经过映射后得到的二进制串的转换格式单位称之为<strong>［码元］（Code Unit）</strong>。也就是说如果有一种UTF的码点二进制表示有n字节，其码元为8位（1个byte），那么其拥有码元n个。每种UTF的码元都不同，其宽度被作为区分写在了UTF的后缀&mdash;&mdash;这就是UTF-8/UTF-16/UTF-32的由来。UTF-8的码元是8位的，UTF-16的码元是16位的。大部分的编程语言采用16位的码元作为机内表示。这就是我们在各种语言中调用获取一个字符串中character的数量时会出现这么多混乱的原因。事实上我们调用这些方法时取得的不是字符个数，而是<strong>码元个数</strong>！一旦我们的字符串中包含了位于基本平面之外的码点，那么就会需要更多的码元来表示，这个时候就会出现测试时常见的困惑&mdash;&mdash;为何return的字符数比实际字符数要多？所以实际写代码时要特别注意这个问题。</p>
<p>采取不同的映射方式可以得到不同格式的二进制串，但是他们背后所表示的［码点］永远是一致的就好像你换身份证但是身份证号不变一样。由于平时人们误把［转换格式］也称为［编码］，所以造成今天Unicode／UTF傻傻分不清楚且遣词造句运用混乱的悲桑局面。</p>
<p>Unicode 编码 发展到今天 扩展到了 21 位（从 U+0000 到 U+10FFFF ）。这一点很重要：&nbsp;<strong>Unicode</strong>&nbsp;<strong>不是</strong>&nbsp;<strong>16</strong>&nbsp;<strong>位的编码，</strong>&nbsp;它是 21 位的。这 21 位提供了 1,114,112 个码点，其中，只有大概 10% 正在使用，所以还有相当大的扩充空间。</p>
<p>编码空间被分成 17 个<strong>平面</strong>（plane），每个平面有 65,536 个字符（正好填充2个字节，16位）。0 号平面叫做<strong>「基本多文种平面」（</strong>&nbsp;<strong>BMP,</strong>&nbsp;<strong>Basic Multilingual Plane</strong>&nbsp;<strong>）</strong>，涵盖了几乎所有你能遇到的字符，除了 emoji（emoji位于1号平面 - -）。其它平面叫做补充平面，大多是空的。</p>
<p>总结一下各种编码格式的特质：</p>
<p><strong>UTF-32</strong></p>
<p>最清楚明了的一个 UTF 就是 UTF<a href="http://en.wikipedia.org/wiki/UTF-32">-</a>32 ：它在每个码点上使用整 32 位。32 大于 21，因此每一个 UTF-32 值都可以直接表示对应的码点。尽管简单，UTF-32却几乎从来不在实际中使用，因为每个字符占用 4 字节太浪费空间了。</p>
<p><strong>UTF-16</strong>&nbsp;<strong>以及「代理对」（</strong>&nbsp;<strong>Surrogate Pairs</strong>&nbsp;<strong>）的概念</strong></p>
<p>UTF<a href="http://en.wikipedia.org/wiki/UTF-16">-</a>16要常见得多，它是根据有 16 位固定长度的<strong>码元（</strong>&nbsp;<strong>code units</strong>&nbsp;<strong>）</strong>定义的。UTF-16 本身是一种长度可变的编码。基本多文种平面（BMP）中的每一个码点都直接与一个码元相映射。鉴于 BMP 几乎囊括了所有常见字符，UTF-16 一般只需要 UTF-32 一半的空间。其它平面里很少使用的码点都是用两个 16 位的码元来编码的，这两个合起来表示一个码点的码元就叫做<strong>代理对（</strong>&nbsp;<strong>surrogate pair</strong>&nbsp;<strong>）</strong>。</p>
<p><strong>UTF-8</strong></p>
<p>UTF-8 使用一到四个字节来编码一个码点。从 0 到 127 的这些码点直接映射成 1 个字节（对于只包含这个范围字符的文本来说，这一点使得 UTF-8 和 ASCII 完全相同）。接下来的 1,920 个码点映射成 2 个字节，在 BMP 里所有剩下的码点需要 3 个字节。Unicode 的其他平面里的码点则需要 4 个字节。UTF-8 是基于 8 位的码元的，因此它并不需要关心字节顺序（不过仍有一些程序会在 UTF-8 文件里加上多余的 BOM）。</p>
<p>有效率的空间使用（仅就西方语言来讲），以及不需要操心字节顺序问题使得 UTF-8 成为存储和交流 Unicode 文本方面的最佳编码。它也已经是文件格式、网络协议以及 Web API 领域里<strong>事实上</strong>的标准了。</p>
<p>我们的JVM中保存码点是UTF16的转换格式，从char的位宽为16位也可以看得出来。由于绝大部分编码的码点位于基本平面，所以使用16位可以几乎表示所有常用字符。这就是许多语言编译器或运行时都使用UTF16的原因。英文在使用UTF16时也是2字节表示的。当我们想要使用其他平面的字符时，码元超过2个字节，就需要使用代理对在语言中的特定表示方式，譬如&lsquo;\U112233&rsquo;之类的。</p>
<p>使用UTF8时，常用的Alphabet和Numeric都在前127字节，被有效率地用一个字节表示。而我们的中文由于排在1920个码点之后，所以使用3个字节表示，这方面就比UTF16转换格式耗费更多空间。</p>
<p>最后，不论使用哪种UTF转换格式，都是程序员自己可以选择的一种表达方式而已。我们可以通过Java方便的API进行自如转换。</p>


<src class="text-warning">&nbsp;




<src class="panel panel-default que-block">
<src class="panel-heading que-title">
<src class="item-title"><strong><em>2</em>下列说法错误的有（ ）</strong>


<src class="panel-body form-group que-option">
<src class="line-numbers">&nbsp;
<src class="checkbox"><label><input type="checkbox" name="checkbox88150[]" value="A" disabled="disabled" />A、Java面向对象语言容许单独的过程与函数存在</label>
<src class="checkbox"><label><input type="checkbox" name="checkbox88150[]" value="B" disabled="disabled" />B、Java面向对象语言容许单独的方法存在</label>
<src class="checkbox"><label><input type="checkbox" name="checkbox88150[]" value="C" disabled="disabled" />C、Java语言中的非静态方法属于类中的成员（member）</label>
<src class="checkbox"><label><input type="checkbox" name="checkbox88150[]" value="D" disabled="disabled" />D、Java语言中的方法必定隶属于某一类（对象），调用方法与C语言的过程或C++语言的函数相同</label>
<src class="text-default"><label>参考答案：</label>A,B,C,D
<src class="text-default"><label>答案解析：</label>
<p>答案:ABCD 做这题其实要区分:C的过程，C++的函数，Java的方法。再看题目，就知道考点了。 java不允许单独的方法，过程或函数存在,需要隶属于某一类中。&mdash;&mdash;AB错 java语言中的方法属于对象的成员,而不是类的成员。不过，其中静态方法属于类的成员。&mdash;&mdash;C错 D问的是java调用方法和C调用过程,C+ + 的函数一样？肯定不一样。错</p>


<src class="text-warning">&nbsp;




<src class="panel panel-default que-block">
<src class="panel-heading que-title">
<src class="item-title"><strong><em>3</em>关于Java中的字符串，下列说法错误的是</strong>


<src class="panel-body form-group que-option">
<src class="line-numbers">&nbsp;
<src class="checkbox"><label><input type="checkbox" name="checkbox17608[]" value="A" disabled="disabled" />A、Java为了方便字符串操作，重载了+、+=这两个运算符</label>
<src class="checkbox"><label><input type="checkbox" name="checkbox17608[]" value="B" disabled="disabled" />B、由于Java中的字符串操作非常重要，所以Java将String类型设定为基本数据类型</label>
<src class="checkbox"><label><input type="checkbox" name="checkbox17608[]" value="C" disabled="disabled" />C、要使用String，就必须在程序的开头部分写上：import&nbsp;java.util.*;</label>
<src class="checkbox"><label><input type="checkbox" name="checkbox17608[]" value="D" disabled="disabled" />D、StringBuilder是JDK&nbsp;5.0中新加入的类，它可以提高字符串操作的效率</label>
<src class="text-default"><label>参考答案：</label>B,C
<src class="text-default"><label>答案解析：</label>
<p>暂无</p>


<src class="text-warning">&nbsp;




<src class="panel panel-default que-block">
<src class="panel-heading que-title">
<src class="item-title"><strong><em>4</em>Java异常处理的过程中，那些实践是值得推荐的？</strong>


<src class="panel-body form-group que-option">
<src class="line-numbers">&nbsp;
<src class="checkbox"><label><input type="checkbox" name="checkbox123981[]" value="A" disabled="disabled" />A、调用方法的时候返回布尔值来代替返回null，这样可以 NullPointerException</label>
<src class="checkbox"><label><input type="checkbox" name="checkbox123981[]" value="B" disabled="disabled" />B、能抛受控异常（checked Exception）就尽量不抛受非控异常(checked Exception)</label>
<src class="checkbox"><label><input type="checkbox" name="checkbox123981[]" value="C" disabled="disabled" />C、catch块里不用写代码，优先在finally去实现功能</label>
<src class="checkbox"><label><input type="checkbox" name="checkbox123981[]" value="D" disabled="disabled" />D、一定要在数据库连接，数据库查询，流处理后，在finally块中调用close()方法</label>
<src class="text-default"><label>参考答案：</label>A,B,D
<src class="text-default"><label>答案解析：</label>
<p><strong>异常处理的过程中，你遵循那些好的实践？</strong></p>
<ul>
<li>异常处理在项目设计中是非常关键的，所以精通异常处理是十分必要的。异常处理有很多最佳实践，下面列举集中，它们提高你代码的健壮性和灵活性：</li>
<li>调用方法的时候返回布尔值来代替返回null，这样可以 NullPointerException。由于空指针是java异常里最恶心的异常。</li>
<li>catch块里别不写代码。空catch块是异常处理里的错误事件，因为它只是捕获了异常，却没有任何处理或者提示。通常你起码要打印出异常信息，当然你最好根据需求对异常信息进行处理。</li>
<li>能抛受控异常（checked Exception）就尽量不抛受非控异常(checked Exception)。通过去掉重复的异常处理代码，可以提高代码的可读性。</li>
<li>绝对不要让你的数据库相关异常显示到客户端。由于绝大多数数据库和SQLException异常都是受控异常，在Java中，你应该在DAO层把异常信息处理，然后返回处理过的能让用户看懂并根据异常提示信息改正操作的异常信息。</li>
<li>在Java中，一定要在数据库连接，数据库查询，流处理后，在finally块中调用close()方法。</li>

</ul>


<src class="text-warning">&nbsp;




<src class="panel panel-default que-block">
<src class="panel-heading que-title">
<src class="item-title"><strong><em>5</em>以下JSP代码定义了一个变量，如何输出这个变量的值？</strong>


<src class="panel-body form-group que-option">
<src class="line-numbers">&nbsp;
<src class="checkbox"><label><input type="checkbox" name="checkbox4730[]" value="A" disabled="disabled" />A、&lt;bean:write&nbsp;name="helloWorld"/&gt;</label>
<src class="checkbox"><label><input type="checkbox" name="checkbox4730[]" value="B" disabled="disabled" />B、&lt;%=stringBean%&gt;</label>
<src class="checkbox"><label><input type="checkbox" name="checkbox4730[]" value="C" disabled="disabled" />C、&lt;bean:write&nbsp;name="stringBean"/&gt;</label>
<src class="checkbox"><label><input type="checkbox" name="checkbox4730[]" value="D" disabled="disabled" />D、&lt;%String&nbsp;myBean=(String)pageContext.getAttribute("stringBean",PageContext.PAGE_SCOPE);%&gt;&lt;br&gt;&lt;%=myBean%&gt;</label>
<src class="text-default"><label>参考答案：</label>B,C,D
<src class="text-default"><label>答案解析：</label>
<p>bean是Struts1的标签，先下载struts-taglib-1.3.10.jar，然后添加到lib.<br />测试代码：<br />pageEncoding="gbk"%&gt;</p>


<src class="text-warning">&nbsp;




<src class="panel panel-default que-block">
<src class="panel-heading que-title">
<src class="item-title"><strong><em>6&nbsp;</em>jdk1.8中，下面有关java 抽象类和接口的区别，说法错误的是？</strong>


<src class="panel-body form-group que-option">
<src class="line-numbers">&nbsp;
<src class="checkbox"><label><input type="checkbox" name="checkbox85951[]" value="A" disabled="disabled" />A、抽象类可以有构造方法，接口中不能有构造方法</label>
<src class="checkbox"><label><input type="checkbox" name="checkbox85951[]" value="B" disabled="disabled" />B、抽象类中可以包含非抽象的普通方法，接口中的方法必须是抽象的，不能有非抽象的普通方法</label>
<src class="checkbox"><label><input type="checkbox" name="checkbox85951[]" value="C" disabled="disabled" />C、一个类可以实现多个接口，但只能继承一个抽象类</label>
<src class="checkbox"><label><input type="checkbox" name="checkbox85951[]" value="D" disabled="disabled" />D、接口中可以有普通成员变量，抽象类中没有普通成员变量</label>
<src class="text-default"><label>参考答案：</label>B,D
<src class="text-default"><label>答案解析：</label>
<src>**接口可以有default、static方法，所以B是错的。** &gt; interface A { &gt; abstract void a(); &gt; static void s() { &gt; } &gt; default void d(){ &gt; &gt; } &gt; void b();//默认用abstract修饰 &gt; int a = 0;//默认用static final 修饰 &gt; }


<src class="text-warning">&nbsp;




<src class="panel panel-default que-block">
<src class="panel-heading que-title">
<src class="item-title"><strong><em>7</em>以下关于Redis的RDB 优缺点的说法正确的有？</strong>


<src class="panel-body form-group que-option">
<src class="line-numbers">&nbsp;
<src class="checkbox"><label><input type="checkbox" name="checkbox123984[]" value="A" disabled="disabled" />A、RDB 会生成多个数据文件，每个数据文件都代表了某一个时刻中 redis 的数据，这种多个数据文件的方式，非常适合做冷备，可以将这种完整的数据文件发送到一些远程的安全存储上去，比如说 Amazon 的 S3 云服务上去，在国内可以是阿里云的 ODPS 分布式存储上，以预定好的备份策略来定期备份 redis 中的数据。</label>
<src class="checkbox"><label><input type="checkbox" name="checkbox123984[]" value="B" disabled="disabled" />B、RDB 对 redis 对外提供的读写服务，影响非常小，可以让 redis 保持高性能，因为 redis 主进程只需要 fork 一个子进程，让子进程执行磁盘 IO 操作来进行 RDB 持久化即可。</label>
<src class="checkbox"><label><input type="checkbox" name="checkbox123984[]" value="C" disabled="disabled" />C、相对于 AOF 持久化机制来说，直接基于 RDB 数据文件来重启和恢复 redis 进程，更加快速。</label>
<src class="checkbox"><label><input type="checkbox" name="checkbox123984[]" value="D" disabled="disabled" />D、如果想要在 redis 故障时，尽可能少的丢失数据，那么 RDB 没有 AOF 好。一般来说，RDB 数据快照文件，都是每隔 5 分钟，或者更长时间生成一次，这个时候就得接受一旦 redis 进程宕机，那么会丢失最近 5 分钟的数据。</label>
<src class="text-default"><label>参考答案：</label>A,B,C,D
<src class="text-default"><label>答案解析：</label>
<p><strong>RDB 优缺点</strong></p>
<ul>
<li>RDB 会生成多个数据文件，每个数据文件都代表了某一个时刻中 redis 的数据，这种多个数据文件的方式，非常适合做冷备，可以将这种完整的数据文件发送到一些远程的安全存储上去，比如说 Amazon 的 S3 云服务上去，在国内可以是阿里云的 ODPS 分布式存储上，以预定好的备份策略来定期备份 redis 中的数据。</li>
<li>RDB 对 redis 对外提供的读写服务，影响非常小，可以让 redis 保持高性能，因为 redis 主进程只需要 fork 一个子进程，让子进程执行磁盘 IO 操作来进行 RDB 持久化即可。</li>
<li>相对于 AOF 持久化机制来说，直接基于 RDB 数据文件来重启和恢复 redis 进程，更加快速。</li>
<li>如果想要在 redis 故障时，尽可能少的丢失数据，那么 RDB 没有 AOF 好。一般来说，RDB 数据快照文件，都是每隔 5 分钟，或者更长时间生成一次，这个时候就得接受一旦 redis 进程宕机，那么会丢失最近 5 分钟的数据。</li>
<li>RDB 每次在 fork 子进程来执行 RDB 快照数据文件生成的时候，如果数据文件特别大，可能会导致对客户端提供的服务暂停数毫秒，或者甚至数秒。</li>

</ul>


<src class="text-warning">&nbsp;




<src class="panel panel-default que-block">
<src class="panel-heading que-title">
<src class="item-title"><strong><em>8</em>OutOfMemoryError异常在哪些数据区域中可能会出现？</strong>


<src class="panel-body form-group que-option">
<src class="line-numbers">&nbsp;
<src class="checkbox"><label><input type="checkbox" name="checkbox123973[]" value="A" disabled="disabled" />A、Java堆溢出</label>
<src class="checkbox"><label><input type="checkbox" name="checkbox123973[]" value="B" disabled="disabled" />B、程序计数器溢出</label>
<src class="checkbox"><label><input type="checkbox" name="checkbox123973[]" value="C" disabled="disabled" />C、虚拟机栈和本地方法栈溢出</label>
<src class="checkbox"><label><input type="checkbox" name="checkbox123973[]" value="D" disabled="disabled" />D、方法区和运行时常量池溢出</label>
<src class="text-default"><label>参考答案：</label>A,C,D
<src class="text-default"><label>答案解析：</label>
<p>程序计数器一般不会溢出。</p>


<src class="text-warning">&nbsp;




<src class="part-title">
<h4>三、判断题（共1题，每题5分）</h4>


<src class="panel panel-default que-block">
<src class="panel-heading que-title">
<src class="item-title"><strong><em>1</em>天猫双十一有个积分换墨盒的活动，总共有50万台天猫魔盒（box），每个用户（user）可以用99个天猫积分（point）兑换一台魔盒，且每人限换一台。 请设计一套java接口并实现下单（order）逻辑。 参考（但不局限于）下面的下单逻辑： 1、创建订单 2、扣减用户积分 3、扣减魔盒库存 4、下单成功 同时请回答： 1、数据库表结构如何设计，有哪些表，分别有什么作用？ 2、下单过程中哪些地方可能成为瓶颈？如何解决或改善？ 3、是否会用到数据库事务，哪些地方会用到？如果不用数据库事务，如何保证数据的一致性？</strong>


<src class="panel-body form-group que-option">
<src class="line-numbers">&nbsp;
<src class="radio"><label><input type="radio" name="radio14920" disabled="disabled" />正确</label>
<src class="radio"><label><input type="radio" name="radio14920" disabled="disabled" />错误</label>
<src class="text-default"><label>参考答案：</label>A
<src class="text-default"><label>答案解析：</label>
<p>1、表的设计：<br />①用户表usertable ，字段id,name,point,以及记录该用户是否曾经兑换过魔盒的标志字段hasdown,用0表示没有下过，1表示下过<br />②魔盒表boxtable,字段allnumber表示总数，remainnumber表示所省的魔盒数量<br />③订单表ordertable,字段id,userid,ordertime表示下单时间<br />2、并发过程，当所有用户同时访问数据库，操作魔盒表和用户表时为了保证事务的一致性，有必要在业务逻辑处理的地方，即更改魔盒表中魔盒数量的代码块或接口和对用户表信息的处理地方处都要加上同步机制，事务回滚等措施<br />3、用到的事务<br />判断用户信息：积分是否大于99，是否曾经兑换过魔盒（hasdown是否为0），如果积分够又没兑换过，那么在兑换时用户表里的积分数要减去99，并且置hasdown为1<br />操作魔盒表：判断魔盒剩余数是否大于0，如果大于0就进行兑换，并使魔盒数减1，<br />订单表：当以上两个事务均完成时再向订单表里插入一条记录，包括用户id，下单时间<br />附：接口<br />Public void order(User user, Box box);</p>







</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>