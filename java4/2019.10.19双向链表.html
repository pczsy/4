<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修2019.10.19双向链表' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>2019.10.19双向链表</center></div><div class='banquan'>原文出处:本文由博客园博主LonelyLeo提供。<br/>
原文连接:https://www.cnblogs.com/lonelyleo/p/11706013.html</div><br>
    <pre><code><br />import java.util.NoSuchElementException;<br /><br />public class LinkedListT&lt;E&gt; {<br />    private Node&lt;E&gt; first;<br /><br />    private Node&lt;E&gt; last;<br /><br />    long size = 0l;<br /><br />    private void linkLast(E e) {<br />        Node&lt;E&gt; temp = last;<br />        Node&lt;E&gt; newNode = new Node&lt;E&gt;(temp, e, null);<br />        last = newNode;<br />        if (temp == null) {<br />            first = newNode;<br />        } else {<br />            temp.next = newNode;<br />        }<br />        size++;<br />    }<br /><br />    public boolean add(E e) {<br />        linkLast(e);<br />        return true;<br />    }<br /><br />    public boolean add(long index, E e) {<br />        checkInsertIndex(index);<br />        if (index &gt; 0 &amp;&amp; index &lt; size) {<br />            //从前到后的查法<br />            /*long j = 0;<br />            for (Node&lt;E&gt; i = first; i != null; i = i.next, j++) {<br />                if (j == index) {<br />                    Node&lt;E&gt; newNode = new Node&lt;&gt;(i.prev, e, i);<br />                    i.prev.next = newNode;<br />                    i.prev = newNode;<br />                }<br />            }*/<br />            //分前后查找法<br />            Node&lt;E&gt; node = indexNode(isSize(index), index);<br />            Node&lt;E&gt; newNode = new Node&lt;&gt;(node.prev, e, node);<br />            node.prev.next = newNode;<br />            node.prev = newNode;<br />            size++;<br />        } else if (index == 0) {<br />            addFirst(e);<br />        }<br />        if (index == size) {<br />            linkLast(e);<br />        }<br />        return true;<br />    }<br /><br />    public void checkInsertIndex(long index) {<br />        if (index &gt; size || index &lt; 0) {<br />            throw new IndexOutOfBoundsException();<br />        }<br />    }<br /><br />    public Boolean addFirst(E e) {<br />        if (size == 0) {<br />            linkLast(e);<br />        } else {<br />            Node&lt;E&gt; newNode = new Node&lt;&gt;(null, e, first);<br />            first.prev = newNode;<br />            first = newNode;<br />            size++;<br />        }<br />        return true;<br />    }<br /><br />    public Boolean addLast(E e) {<br />        linkLast(e);<br />        return true;<br />    }<br /><br />    public E getFirst() {<br />        if (first == null) {<br />            throw new NoSuchElementException();<br />        }<br />        return first.item;<br />    }<br /><br />    public E getLast() {<br />        if (last == null) {<br />            throw new NoSuchElementException();<br />        }<br />        return last.item;<br />    }<br /><br />    public long getSize() {<br />        return size;<br />    }<br /><br />    public E get(long index) {<br />        E result = null;<br />        checkInsertIndex(index);<br />        long j = 0;<br />        for (Node&lt;E&gt; i = first; i != null; i = i.next, j++) {<br />            if (j == index) {<br />                result = i.item;<br />            }<br />        }<br />        return result;<br />    }<br /><br />    public void removeAll() {<br />        first = null;<br />        last = null;<br />        size = 0;<br />    }<br /><br />    public E remove(long index) {<br />        E e = null;<br />        checkRemoveIndex(index);<br />        if (index != 0 &amp;&amp; index != size - 1){<br />            Node&lt;E&gt; node = indexNode(isSize(index), index);<br />//            Node&lt;E&gt; prev = node.prev;<br />            node.prev.next = node.next;<br />            node.next.prev = node.prev;<br />            e = node.item;<br />            node = null;<br />            size--;<br />        }else if(index == 0){<br />            e = removeFirst();<br />        }else {<br />            e = removeLast();<br />        }<br />        return e;<br />    }<br /><br />    private void checkRemoveIndex(long index){<br />        if (index &gt;= size || index &lt; 0) {<br />            throw new IndexOutOfBoundsException();<br />        }<br />    }<br /><br />    private Node&lt;E&gt; indexNode(boolean flag, long index) {<br />        long j = 0;<br />        Node&lt;E&gt; node = null;<br />        if (flag) {<br />            for (Node&lt;E&gt; i = first; i != null; i = i.next, j++) {<br />                if (index == j) {<br />                    node = i;<br />                }<br />            }<br />        } else {<br />            j = size - 1;<br />            for (Node&lt;E&gt; i = last; i != null; i = i.prev, j--) {<br />                if (index == j){<br />                    node = i;<br />                }<br />            }<br />        }<br />        return node;<br />    }<br /><br />    private boolean isSize(long index) {<br />        if (size / 2 &gt;= index) {<br />            return true;<br />        } else {<br />            return false;<br />        }<br />    }<br /><br />    public E remove(Object obj) {<br />        E e = null;<br />        if (obj == null){<br />            for ( Node&lt;E&gt; i = first;i != null;i = i.next){<br />                if (i.item == obj){<br />                    e = unlink(i);<br />                }<br />            }<br />        }else {<br />            for ( Node&lt;E&gt; i = first;i != null;i = i.next){<br />                if (i.item.equals(obj)){<br />                    e = unlink(i);<br />                }<br />            }<br />        }<br />        return e;<br />    }<br /><br />    E unlink(Node&lt;E&gt; x) {<br />        E element = x.item;<br />        Node&lt;E&gt; next = x.next;<br />        Node&lt;E&gt; prev = x.prev;<br /><br />        if (prev == null) {<br />            first = next;<br />        } else {<br />            prev.next = next;<br />            x.prev = null;<br />        }<br /><br />        if (next == null) {<br />            last = prev;<br />        } else {<br />            next.prev = prev;<br />            x.next = null;<br />        }<br /><br />        x.item = null;<br />        size--;<br />        return element;<br />    }<br /><br />    public E removeFirst() {<br />        if (size == 0) {<br />            throw new IndexOutOfBoundsException();<br />        }<br />        Node&lt;E&gt; second = first.next;<br />        E e = first.item;<br />        first.next = null;<br />        if (second == null) {<br />            last = null;<br />        } else {<br />            second.prev = null;<br />        }<br />        first = second;<br />        size--;<br />        return e;<br />    }<br /><br />    public E removeLast() {<br />        if (size == 0) {<br />            throw new IndexOutOfBoundsException();<br />        }<br />        Node&lt;E&gt; secondLast = last.prev;<br />        E e = last.item;<br />        last.prev = null;<br />        if (secondLast == null) {<br />            first = null;<br />        } else {<br />            secondLast.next = null;<br />        }<br />        last = secondLast;<br />        size--;<br />        return e;<br />    }<br /><br />    private static class Node&lt;E&gt; {<br />        E item;<br />        Node&lt;E&gt; next;<br />        Node&lt;E&gt; prev;<br /><br />        Node(Node&lt;E&gt; prev, E item, Node&lt;E&gt; next) {<br />            this.item = item;<br />            this.next = next;<br />            this.prev = prev;<br />        }<br />    }<br /><br />    @Override<br />    public String toString() {<br />        StringBuffer str = new StringBuffer("");<br />        for (Node&lt;E&gt; i = first; i != null; i = i.next) {<br />            str.append(i.item);<br />            if (i.next != null) {<br />                str.append(",");<br />            }<br />        }<br />        return "[" + str.toString() + "]";<br />    }<br />}</code></pre>

</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>