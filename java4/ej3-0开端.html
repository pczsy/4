<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修ej3-0开端' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>ej3-0开端</center></div><div class='banquan'>原文出处:本文由博客园博主春天springcarter提供。<br/>
原文连接:https://www.cnblogs.com/snidget/p/11947264.html</div><br>
    <h1 id="开始">开始</h1>
<blockquote>
<p>编码多年，总有一些最佳实践，Java也是，比如设计模式，比如Effective Java 3 (ej3) 。 设计模式先后看过《大话设计模式》，《HeadFirst 设计模式》。而EffectiveJava3我打算阅读英语原版的，翻译过来，提高一下自己的英文阅读能力，同时也思考一下大师总结的编程最佳实践，应用到日常编码工作中。</p>
</blockquote>
<pre><code><code>开端从ef3作者的[宣讲PPT](https://www.yuque.com/office/yuque/0/2019/pptx/186661/1574762227798-103405a7-8cec-4953-b03c-26e8eff4150c.pptx)开始。</code></code></pre>
<p>建议先快速看一遍ppt,不过全部是英文的，我把它翻译过来，作为我开始ej3的开始。</p>
<h1 id="版本变化">版本变化</h1>
<table>
<thead>
<tr class="header">
<th>变化</th>
<th>ej3</th>
<th>ej2</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>新增章节</td>
<td>一个新章节</td>
<td></td>
</tr>
<tr class="even">
<td>新增规则</td>
<td>14条新规则</td>
<td></td>
</tr>
<tr class="odd">
<td>重写规则</td>
<td>2个重写规则</td>
<td></td>
</tr>
<tr class="even">
<td>修改规则</td>
<td>所有规则条目彻底修改</td>
<td></td>
</tr>
<tr class="odd">
<td>发布日期</td>
<td>2017</td>
<td>2008</td>
</tr>
<tr class="even">
<td>jdk版本</td>
<td>java9</td>
<td>java6</td>
</tr>
<tr class="odd">
<td>页数</td>
<td>366</td>
<td>315</td>
</tr>
</tbody>
</table>
<h1 id="使用-lambdas优先匿名类">使用 lambdas优先匿名类</h1>
<pre><code><code>使用匿名内部类的代码可读性和简洁性不断提高；</code></code></pre>
<p><img src="./images/ej3-0开端0.png" alt="file" /></p>
<p>类型推断:</p>
<p><code>Collections.sort(stringList,(s1,s2)-&gt;Integer.compare(s1.length(),s2.length()));</code></p>
<pre><code><code>等价于：</code></code></pre>
<p><code>Collections.sort(stringList,(Comparator&lt;String&gt;)(String s1,String s2)-&gt;Integer.compare(s1.length(),s2.length()));</code></p>
<pre><code><code>类型推断很魔幻：</code></code></pre>
<ol>
<li>没有人知道规则，但是它是对的；</li>
<li>忽略类型除非它可以让程序更清晰；</li>
<li><p>编译器如果需要帮助它会告诉你；</p>
类型推断的警告：</li>
<li>推断依赖于泛型信息； 比如 words被声明为List<String>,代码无法编译，如果words是一个原生的List;</li>
<li>第二版说不要使用原生类型：惩罚是不必要的运行期bug和令人讨厌的代码；</li>
<li>第三版本说的更严重：惩罚包括无法合适的使用lambdas；</li>
<li><p>你必须理解泛型之后才能使用lambdas；</p></li>
</ol>
<p>使用labmbdas的警告：</p>
<ol>
<li>它缺少名字和文档：它应该是自解释的，它应该不超过一定行数，最好是一行；</li>
<li>如果它必须很长或者复杂：抽取到方法中然后使用方法引用，枚举则或者使用指定实例的类体；</li>
<li>匿名类任然有使用场景：lambdas需要函数式接口，并且无法访问自己，在lambdas中this指向了一个封闭的实例；</li>
</ol>
<p><img src="./images/ej3-0开端1.png" alt="file" /></p>
<pre><code><code>把一个抽象方法的实现替换成了一个函数式接口；</code></code></pre>
<h1 id="方法引用优先lambdas">方法引用优先lambdas</h1>
<p><img src="./images/ej3-0开端2.png" alt="file" /></p>
<pre><code><code>说明：</code></code></pre>
<ol>
<li>参数越多，代码块约长；但是参数可以提供文档信息；</li>
<li>如果使用lambdas，需要小心的选择参数名字；</li>
</ol>
<pre><code><code>public class ExeTest {
    public static void main(String[] args) {
        new Thread(()-&gt;action()).start();
        System.out.println(&quot;====&quot;);
        new Thread(ExeTest::action).start();
        Arrays.asList(&quot;aaa&quot;,&quot;bbb&quot;,&quot;CCC&quot;).stream().map(x-&gt;x).collect(Collectors.toList());
        Arrays.asList(&quot;aaa&quot;,&quot;bbb&quot;,&quot;CCC&quot;).stream().map(Function.identity()).collect(Collectors.toList());
    }
    private static void action() {
        System.out.println(&quot;do action &quot;);
    }
}</code></code></pre>
<p><img src="./images/ej3-0开端3.png" alt="file" /></p>
<pre><code><code>写在最后：</code></code></pre>
<ol>
<li>所有可以使用方法引用的地方，你都可以使用lambda替换；</li>
<li>方法引用通常更简洁；</li>
<li>有的时候，lambda更清晰</li>
<li>基于你自己的判断力，你总是可以改变主意；</li>
</ol>
<h1 id="优先使用标准函数式接口">优先使用标准函数式接口</h1>
<pre><code><code>jdk9中一共43个标准的函数式接口；</code></code></pre>
<p><img src="./images/ej3-0开端4.png" alt="file" /></p>
<pre><code><code>使用标准的函数式接口的好处：</code></code></pre>
<ol>
<li>api更好学习降低了概念领域的学习；</li>
<li>提供了互操作性便利：很多的标准函数式接口提供了有用的默认方法，比如Predicate提供了combine和negate；</li>
<li><p>例子中方法可以使用BiPredicate来替代；</p>
为何如此关注比较器 Comparator?</li>
<li>每次在api使用的时候名字提供了文档：使用频率高；</li>
<li>在合法的实例列表中强烈需要：需要通用的比较协议，通过实现这个接口，你遵守了承诺；</li>
<li><p>很多有用的默认方法可以组合和转换实例，6种形式的thenComparing和reversed；</p>
基于目的写函数式接口的标准：</li>
<li>接口应该共享一个或多个比较器comparator的特征：经常使用，有个很好描述的名字，很强的关联，可以从默认方法中收益；</li>
<li><p>如果你写了一个函数式接口，记住，它是一个接口：所有的接口都需要特别关注；</p></li>
</ol>
<h1 id="辩证的使用streams">辩证的使用streams</h1>
<pre><code><code>什么是流？</code></code></pre>
<ol>
<li>一系列从集合，数组，输入设备等过来的数据对象，为了大量的数据处理；</li>
<li>按照管道处理数据：一个数据源，0个或多个中间操作，一个终止操作；</li>
<li>支持大部分函数式数据处理；</li>
<li><p>支持无痛并行：简单的替换流为parallelStream:你可能看到性能提升；</p>
<p>标准实现，不使用流</p></li>
</ol>
<pre><code><code>public static void test1(String[] args) throws FileNotFoundException {
    File dictionary = new File(args[0]);
    int minGroupSize = Integer.parseInt(args[1]);
    Map&lt;String, Set&lt;String&gt;&gt; groups = new HashMap&lt;&gt;();
    try (Scanner s = new Scanner(dictionary)) {
        // Item 9       
                while (s.hasNext()) {
            String word = s.next();
            groups.computeIfAbsent(alphabetize(word), (unused) -&gt; new TreeSet&lt;&gt;())
                    .add(word);
        }
    }
    for (Set&lt;String&gt; group : groups.values()) {
        if (group.size() &gt;= minGroupSize) {
            System.out.println(group.size() + &quot;: &quot; + group);
        }
    }
}</code></code></pre>
<pre><code><code>使用流，连字符串的处理都使用流</code></code></pre>
<pre><code><code>public static void test2(String[] args) throws IOException {

    Path dictionary = Paths.get(args[0]);

    int minGroupSize = Integer.parseInt(args[1]);

    try (Stream&lt;String&gt; words = Files.lines(dictionary)) {

        words.collect(

                groupingBy(word -&gt; word.chars().sorted()

                        .collect(StringBuilder::new,

                                (sb, c) -&gt; sb.append((char) c),

                                StringBuilder::append).toString()))

                .values().stream()

                .filter(group -&gt; group.size() &gt;= minGroupSize)

                .map(group -&gt; group.size() + &quot;: &quot; + group)

                .forEach(System.out::println);

    }

}</code></code></pre>
<pre><code><code>    使用流</code></code></pre>
<hr />
<pre><code><code>    public static void test3(String[] args) throws IOException {

    Path dictionary = Paths.get(args[0]);

    int minGroupSize = Integer.parseInt(args[1]);

    try (Stream&lt;String&gt; words = Files.lines(dictionary)) {

        words.collect(groupingBy(Test2::alphabetize))

                .values().stream()

                .filter(group -&gt; group.size() &gt;= minGroupSize)

                .forEach(g -&gt; System.out.println(g.size() + &quot;: &quot; + g));

    }

}</code></code></pre>
<pre><code><code>为何不用streas去实现alphabetize方法？</code></code></pre>
<ol>
<li>streams没有提供直接的支持char;</li>
<li><p>实现结果：不清晰，很难写正确，很难阅读，可能更慢；</p>
<p>看一下这段代码输出结果：<br />
&quot;Hello world&quot;.chars().forEach(System.out::print);<br />
输出结果是：<br />
7210110810811132119111114108100</p>
<p>因为chars得到的是一个IntStream；所以输出了整数；<br />
修正：<br />
&quot;Hello world&quot;.chars().forEach(i-&gt; System.out.print((char)i));<br />
<strong>禁止使用streams处理char;</strong></p>
<p>一个难题： 笛卡尔产品</p></li>
</ol>
<pre><code><code>private static List&lt;Card&gt; newDeck() {
        List&lt;Card&gt; result = new ArrayList&lt;&gt;();
        for (Suit suit : Suit.values()) {
            for (Rank rank : Rank.values()) {
                result.add(new Card(suit, rank));
            }
        }
        return result;
    }
    private static List&lt;Card&gt; newDeck2() {
        return Stream.of(Suit.values())
                .flatMap(suit -&gt; Stream.of(Rank.values()).map(rank -&gt; new Card(suit, rank)))
                .collect(toList());
    }</code></code></pre>
<pre><code><code>    写在最后：</code></code></pre>
<ol>
<li>流在很多事情上非常出色，但是它不是灵丹妙药；</li>
<li>你第一次学习流的时候，你可能会项把所有的循环转换成流式循环，别这么做，它可以让你的代码更短，但是不太简洁；</li>
<li>一边练习一边评价，合适的使用，流可以提高简介和清晰，但是很多的程序应该结合iteration和流；</li>
<li>并不是一开始就很清晰，如果你不懂，开始猜测然后开始探究源码，如果你感觉不对，尝试另外的方法</li>
</ol>
<h1 id="辩证的使用streams的并行化">辩证的使用streams的并行化</h1>
<pre><code><code>并行化不一定更快。</code></code></pre>
<p><img src="./images/ej3-0开端5.png" alt="file" /></p>
<pre><code><code>为何例子中的并行程序跑的如此慢？</code></code></pre>
<ol>
<li>流的库中没有明确的注意如何去并行执行，这个探索很痛苦的失败了；</li>
<li>在最好的例子中，parallel没用：流的源头是stream.iteratoe或者中间操作被使用；</li>
<li>反例：limit操作的默认策略计算超额的元素，计算素数一个的时间是另外一个的两倍时间；</li>
<li><p>准则：不要无差别的并行化；</p>
parallelize适合的场景：</li>
<li>Arrays,ArrayList,HashMap,HashSet,ConcurrentHashMap,int,long的区间；</li>
<li>这些数据源的公共特征：可以预见的分离，好的位置引用；</li>
<li>终止操作也会影响：必须快速并且容易并行化：减法比如min,max,count,sum是适合的，collectors不适合；</li>
<li><p>中间操作也会影响：mapping和filter非常适合，limit不适合；</p>
parallel()仅仅只是优化：</li>
<li>优化需要判断；</li>
<li>不使用parallel除非你能证明它维护正确；</li>
<li>不适用parallel除非你确幸它能跑的更快；</li>
<li><p>测量性能在使用前后；</p></li>
</ol>
<h1 id="大神的小结">大神的小结</h1>
<ol>
<li>java比以前庞大和复杂了；</li>
<li>现在一个多模式的语言；</li>
<li>不要仅仅关注如何使用特征，还要关注使用哪些；</li>
<li>lambdas和streams是一个巨大的成功，但是你必须批判的使用他们；</li>
<li>java的力量越大责任越大；</li>
</ol>
<h1 id="非神小白的小结">非神小白的小结</h1>
<blockquote>
<p>ppt首先对比了3个版本的effectiveJava的区别，然后挑选了新增的章节中的5个条目进行了演示，确实让人耳目一新。Java8,9最亮的点就是lambdas和streams .要好好利用和理解。</p>
</blockquote>
<blockquote>
<p>原创不易，转载请注明出处。</p>
</blockquote>


</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>