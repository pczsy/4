<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修java 微信开发的工具类WeChatUtils' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>java 微信开发的工具类WeChatUtils</center></div><div class='banquan'>原文出处:本文由博客园博主变红叶提供。<br/>
原文连接:https://www.cnblogs.com/bhudy/p/11956778.html</div><br>
    <p>import com.alibaba.fastjson.JSONObject;<br />import com.bhudy.entity.BhudyPlugin;<br />import com.bhudy.service.BhudyPluginService;<br />import org.jdom2.Document;<br />import org.jdom2.Element;<br />import org.jdom2.JDOMException;<br />import org.jdom2.input.SAXBuilder;<br />import org.springframework.beans.factory.annotation.Autowired;<br />import org.springframework.stereotype.Component;<br /><br />import javax.xml.transform.Transformer;<br />import javax.xml.transform.TransformerConfigurationException;<br />import javax.xml.transform.TransformerException;<br />import javax.xml.transform.TransformerFactory;<br />import javax.xml.transform.dom.DOMSource;<br />import javax.xml.transform.stream.StreamResult;<br />import java.io.IOException;<br />import java.io.StringReader;<br />import java.io.StringWriter;<br />import java.security.MessageDigest;<br />import java.util.*;<br /><br />/**<br />* Created by Administrator on 2019/8/23/023.<br />*/<br />@Component<br />public final class WeChatUtils {<br /><br />@Autowired<br />private WeChatUtils(BhudyPluginService bhudyPluginService) {<br />WeChatUtils.bhudyPluginService = bhudyPluginService;<br />}<br /><br />private static BhudyPluginService bhudyPluginService; // 获取微信appid的接口<br /><br />private static Map&lt;String, String&gt; tokenMap = null;<br /><br />public static String wxGzhWorkOrder = "xxxxx"; // 工单状态通知Key<br />public static String weGzhReport = "xxxxxx"; // 报告生成通知Key<br /><br /><br />private static String authorizationCode = "authorization_code"; // 微信调用接口使用参数authorization_code<br />private static String clientCredential = "client_credential"; // 微信调用接口使用参数client_credential<br /><br /><br />/**<br />* 发送报告生成通知<br />* 报告生成通知Id: P9U-LYY4qtcKKqSoDb7sfqK4GlFQvDu8G5JxWOTkUQk<br />* &lt;p&gt;<br />* {{first.DATA}}<br />* 报告类型：{{keyword1.DATA}}<br />* 生成时间：{{keyword2.DATA}}<br />* {{remark.DATA}}<br />*<br />* @return 是否发送成功<br />*/<br />public static boolean sendWeGzhReport(String openId, String first, String remark, Map&lt;String, Object&gt; keywordMap) {<br />return sendWxGzh(openId, WeChatUtils.weGzhReport, first, remark, keywordMap);<br />}<br /><br />/**<br />* 发送微信公众号工单消息提醒<br />* 工单模板信息id: i5JtheQBLYM9VyByYR2EqrGlbdZiiFZVyA7rndbOAuM<br />* &lt;p&gt;<br />* {{first.DATA}}<br />* 工单编号：{{keyword1.DATA}}<br />* 工单标题：{{keyword2.DATA}}<br />* 时间：{{keyword3.DATA}}<br />* {{remark.DATA}}<br />*<br />* @return 是否发送成功<br />*/<br />public static boolean sendWxGzhWorkOrder(String openId, String first, String remark, Map&lt;String, Object&gt; keywordMap) {<br />return sendWxGzh(openId, WeChatUtils.wxGzhWorkOrder, first, remark, keywordMap);<br />}<br /><br />/**<br />* 发送微信公众号信息<br />* &lt;p&gt;<br />* 参数 是否必填 说明<br />* touser 是 接收者openid<br />* template_id 是 模板ID<br />* url 否 模板跳转链接（海外帐号没有跳转能力）<br />* miniprogram 否 跳小程序所需数据，不需跳小程序可不用传该数据<br />* appid 是 所需跳转到的小程序appid（该小程序appid必须与发模板消息的公众号是绑定关联关系，暂不支持小游戏）<br />* pagepath 否 所需跳转到小程序的具体页面路径，支持带参数,（示例index?foo=bar），要求该小程序已发布，暂不支持小游戏<br />* data 是 模板数据<br />* color 否 模板内容字体颜色，不填默认为黑色<br />* &lt;p&gt;<br />* json数据模板<br />* {"touser":"OPENID","template_id":"ngqIpbwh8bUfcSsECmogfXcV14J0tQlEpBO27izEYtY","url":"http://weixin.qq.com/download",<br />* "miniprogram":{"appid":"xiaochengxuappid12345","pagepath":"index?foo=bar"},"data":{"first":{"value":"恭喜你购买成功！","color":"#173177"},<br />* "keyword1":{"value":"巧克力","color":"#173177"},"keyword2":{"value":"39.8元","color":"#173177"},"keyword3":{"value":"2014年9月22日","color":"#173177"},<br />* "remark":{"value":"欢迎再次购买！","color":"#173177"}}}<br />*<br />* @param openId 接收消息的用户openid<br />* @param templateId 消息模板id<br />* @param first 标题<br />* @param remark 结尾<br />* @param keywordMap 内容map<br />* @return 是否发送成功<br />*/<br />public static boolean sendWxGzh(String openId, String templateId, String first, String remark, Map&lt;String, Object&gt; keywordMap) {<br />if (openId == null || openId.equals("")) return false;<br /><br />String url = "https://api.weixin.qq.com/cgi-bin/message/template/send?access_token=" + WeChatUtils.getToken(BhudyPlugin.TENCENT_TAS);<br />Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();<br />map.put("touser", openId);<br />map.put("template_id", templateId);<br />map.put("url", null);<br /><br />Map&lt;String, Object&gt; miniprogramMap = new HashMap&lt;&gt;();<br /><br /><br />miniprogramMap.put("appid", bhudyPluginService.getBhudyPluginDataByType(BhudyPlugin.TENCENT_TAS).get(BhudyPlugin.appId));<br />//miniprogramMap.put("pagepath", "index");<br />map.put("miniprogram", miniprogramMap);<br /><br />Map&lt;String, Object&gt; dataMap = new HashMap&lt;&gt;();<br /><br />Map firstMap = new HashMap&lt;&gt;();<br />firstMap.put("value", first);<br />dataMap.put("first", firstMap);<br /><br />for (Map.Entry entrySet : keywordMap.entrySet()) {<br />Map keyword1Map = new HashMap&lt;&gt;();<br />keyword1Map.put("value", entrySet.getValue());<br />dataMap.put(entrySet.getKey().toString(), keyword1Map);<br />}<br /><br />Map remarkMap = new HashMap&lt;&gt;();<br />remarkMap.put("value", remark);<br />dataMap.put("remark", remarkMap);<br /><br />map.put("data", dataMap);<br /><br />Map&lt;String, Object&gt; resultMap = WeChatUtils.wxReqDataPost(url, JSONObject.toJSONString(map));<br />return resultMap != null;<br />}<br /><br />/**<br />* 获取用户基本信息(UnionID机制)<br />* 在关注者与公众号产生消息交互后，公众号可获得关注者的OpenID（加密后的微信号，每个用户对每个公众号的OpenID是唯一的。对于不同公众号，同一用户的openid不同）。公众号可通过本接口来根据OpenID获取用户基本信息，包括昵称、头像、性别、所在城市、语言和关注时间。<br />* 请注意，如果开发者有在多个公众号，或在公众号、移动应用之间统一用户帐号的需求，需要前往微信开放平台（open.weixin.qq.com）绑定公众号后，才可利用UnionID机制来满足上述需求。<br />* &lt;p&gt;<br />* 参数 是否必须 说明<br />* access_token 是 调用接口凭证<br />* openid 是 普通用户的标识，对当前公众号唯一<br />* lang 否 返回国家地区语言版本，zh_CN 简体，zh_TW 繁体，en 英语<br />* ***********************************<br />*<br />* @return &lt;br&gt;<br />* 参数 说明<br />* subscribe 用户是否订阅该公众号标识，值为0时，代表此用户没有关注该公众号，拉取不到其余信息。<br />* openid 用户的标识，对当前公众号唯一<br />* nickname 用户的昵称<br />* sex 用户的性别，值为1时是男性，值为2时是女性，值为0时是未知<br />* city 用户所在城市<br />* country 用户所在国家<br />* province 用户所在省份<br />* language 用户的语言，简体中文为zh_CN<br />* headimgurl 用户头像，最后一个数值代表正方形头像大小（有0、46、64、96、132数值可选，0代表640*640正方形头像），用户没有头像时该项为空。若用户更换头像，原有头像URL将失效。<br />* subscribe_time 用户关注时间，为时间戳。如果用户曾多次关注，则取最后关注时间<br />* unionid 只有在用户将公众号绑定到微信开放平台帐号后，才会出现该字段。<br />* remark 公众号运营者对粉丝的备注，公众号运营者可在微信公众平台用户管理界面对粉丝添加备注<br />* groupid 用户所在的分组ID（兼容旧的用户分组接口）<br />* tagid_list 用户被打上的标签ID列表<br />* subscribe_scene 返回用户关注的渠道来源，ADD_SCENE_SEARCH 公众号搜索，ADD_SCENE_ACCOUNT_MIGRATION 公众号迁移，ADD_SCENE_PROFILE_CARD 名片分享，ADD_SCENE_QR_CODE 扫描二维码，ADD_SCENEPROFILE LINK 图文页内名称点击，ADD_SCENE_PROFILE_ITEM 图文页右上角菜单，ADD_SCENE_PAID 支付后关注，ADD_SCENE_OTHERS 其他<br />* qr_scene 二维码扫码场景（开发者自定义）<br />* qr_scene_str 二维码扫码场景描述（开发者自定义）<br />* UnionID<br />*/<br />public static Map&lt;String, Object&gt; getUserInfo(String openId, Integer type) {<br />String url = "https://api.weixin.qq.com/cgi-bin/user/info?access_token=" + WeChatUtils.getToken(type) + "&amp;openid=" + openId + "&amp;lang=zh_CN";<br />Map resultMap = WeChatUtils.wxReqDataGet(url);<br />return resultMap;<br />}<br /><br />/**<br />* 获取公众号用户列表<br />* 公众号可通过本接口来获取帐号的关注者列表，关注者列表由一串OpenID（加密后的微信号，每个用户对每个公众号的OpenID是唯一的）组成。一次拉取调用最多拉取10000个关注者的OpenID，可以通过多次拉取的方式来满足需求。<br />* &lt;p&gt;<br />* 参数 是否必须 说明<br />* access_token 是 调用接口凭证<br />* next_openid 是 第一个拉取的OPENID，不填默认从头开始拉取<br />*<br />* @param nextOpenid 第一个拉取的OPENID，不填默认从头开始拉取<br />* @return &lt;br&gt;<br />* 参数 说明<br />* total 关注该公众账号的总用户数<br />* count 拉取的OPENID个数，最大值为10000<br />* data 列表数据，OPENID的列表<br />* next_openid 拉取列表的最后一个用户的OPENID<br />*/<br />public static Map&lt;String, Object&gt; getOpenIdListMap(String nextOpenid) {<br />String url = "https://api.weixin.qq.com/cgi-bin/user/get?access_token=" + getToken(BhudyPlugin.TENCENT_TAS);<br />if (nextOpenid != null &amp;&amp; nextOpenid.equals("")) {<br />url += "&amp;next_openid=" + nextOpenid;<br />}<br /><br />Map resultMap = WeChatUtils.wxReqDataGet(url);<br />return resultMap;<br />}<br /><br />/**<br />* @param type 1是公众号请求<br />* @return * * *<br />* 属性 类型 说明<br />* access_token string 获取到的凭证<br />* expires_in number 凭证有效时间，单位：秒。目前是7200秒之内的值。<br />* errcode number 错误码<br />* errmsg string 错误信息<br />* &lt;p&gt;<br />* =====================================<br />* &lt;p&gt;<br />* errcode 的合法值<br />* 值 说明 最低版本<br />* -1 系统繁忙，此时请开发者稍候再试<br />* 0 请求成功<br />* 40001 AppSecret 错误或者 AppSecret 不属于这个小程序，请开发者确认 AppSecret 的正确性<br />* 40002 请确保 grant_type 字段值为 client_credential<br />* 40013 不合法的 AppID，请开发者检查 AppID 的正确性，避免异常字符，注意大小写<br />*/<br />public static String getToken(Integer type) {<br />Map&lt;String, String&gt; tokenMap = WeChatUtils.tokenMap;<br />// 微信的access_token有效期是7200秒，所以我们的过期时间要比微信的快token<br />if (tokenMap != null &amp;&amp; Utils.formatLong(tokenMap.get("date")) &gt;= (new Date().getTime() + (7200 * 1000))) {<br />return tokenMap.get("access_token");<br />}<br /><br />Map&lt;String, String&gt; weChatMap = bhudyPluginService.getBhudyPluginDataByType(type);<br />String url = "https://api.weixin.qq.com/cgi-bin/token?appid=" + weChatMap.get(BhudyPlugin.appId) + "&amp;secret=" + weChatMap.get(BhudyPlugin.appSecret) + "&amp;grant_type=" + clientCredential;<br /><br />Map&lt;String, Object&gt; resultMap = WeChatUtils.wxReqDataGet(url);<br />if (resultMap == null) throw new BhudyException(BhudyExceptionCode.CODE_29);<br /><br />String token = (String) resultMap.get("access_token");<br />WeChatUtils.tokenMap = new HashMap&lt;&gt;();<br />WeChatUtils.tokenMap.put("date", String.valueOf(new Date().getTime()));<br />WeChatUtils.tokenMap.put("access_token", token);<br /><br />return token;<br />}<br /><br /><br />/**<br />* @param code string 是 登录时获取的 code<br />* @return * * *<br />* 属性 类型 说明<br />* openid string 用户唯一标识<br />* session_key string 会话密钥<br />* unionid string 用户在开放平台的唯一标识符，在满足 UnionID 下发条件的情况下会返回，详见 UnionID 机制说明。<br />* errcode number 错误码<br />* errmsg string 错误信息<br />* &lt;p&gt;<br />* ===================================<br />* &lt;p&gt;<br />* errcode 的合法值<br />* 值 说明 最低版本<br />* -1 系统繁忙，此时请开发者稍候再试<br />* 0 请求成功<br />* 40029 code 无效<br />* 45011 频率限制，每个用户每分钟100次<br />*/<br />public static Map&lt;String, Object&gt; getOpenIdAndSessionKey(String code, Integer type) {<br />Map&lt;String, String&gt; weChatMap = bhudyPluginService.getBhudyPluginDataByType(type);<br />String url = "https://api.weixin.qq.com/sns/jscode2session?appid=" + weChatMap.get(BhudyPlugin.appId) + "&amp;secret=" + weChatMap.get(BhudyPlugin.appSecret) + "&amp;grant_type=" + authorizationCode + "&amp;js_code=" + code;<br />return WeChatUtils.wxReqDataGet(url);<br />}<br /><br /><br />/**<br />* 微信Post请求<br />* 如果微信端返回错误码或者没有返回数据，这个方法直接返回null<br />* 该方法没有使用线程，可能会卡死<br />*<br />* @param url 请求的url<br />* @param params<br />* @return<br />*/<br />public static Map&lt;String, Object&gt; wxReqDataPost(String url, String params) {<br />try {<br />Map&lt;String, Object&gt; reulstMap = Utils.reqPost(url, params);<br />if (reulstMap == null || (reulstMap.containsKey("errcode") &amp;&amp; (Integer) reulstMap.get("errcode") != 0)) {<br />return null;<br />}<br />return reulstMap;<br />} catch (Exception e) {<br />return null;<br />}<br />}<br /><br />/**<br />* 微信Get请求<br />* 如果微信端返回错误码或者没有返回数据，这个方法直接返回null<br />* 该方法没有使用线程，可能会卡死<br />*<br />* @param url 请求的url<br />* @return<br />*/<br />public static Map&lt;String, Object&gt; wxReqDataGet(String url) {<br />try {<br />Map&lt;String, Object&gt; reulstMap = Utils.reqGetMap(url);<br />if (reulstMap == null || (reulstMap.containsKey("errcode") &amp;&amp; (Integer) reulstMap.get("errcode") != 0)) {<br />return null;<br />}<br />return reulstMap;<br />} catch (Exception e) {<br />return null;<br />}<br />}<br /><br /><br />/**<br />* 接收事件推送<br />* 用法@RequestMapping(value = "/wx/api/v1/receiveEventPush.do", method = RequestMethod.POST, consumes = {"application/xml", "text/xml"}, produces = {"application/xml;charset=utf-8", "text/xml;charset=utf-8"})<br />* public Object receiveEventPush(@RequestBody DOMSource domSource) {<br />* return WxUtils.receiveEventPush(domSource);<br />* }<br />*<br />* @param domSource<br />* @return * * *<br />* &lt;p&gt;<br />* 目录 MsgType Event<br />* 1 关注/取消关注事件<br />* 2 扫描带参数二维码事件<br />* 3 上报地理位置事件<br />* 4 自定义菜单事件<br />* 5 点击菜单拉取消息时的事件推送<br />* 6 点击菜单跳转链接时的事件推送<br />* &lt;p&gt;<br />* &lt;p&gt;<br />* 》》》1.关注/取消关注事件《《《<br />* 参数 描述<br />* ToUserName 开发者微信号<br />* FromUserName 发送方帐号（一个OpenID）<br />* CreateTime 消息创建时间 （整型）<br />* MsgType 消息类型，event<br />* Event 事件类型，subscribe(订阅)、unsubscribe(取消订阅)<br />* &lt;p&gt;<br />* &lt;p&gt;<br />* 》》》2.扫描带参数二维码事件《《《<br />* 参数 描述<br />* ToUserName 开发者微信号<br />* FromUserName 发送方帐号（一个OpenID）<br />* CreateTime 消息创建时间 （整型）<br />* MsgType 消息类型，event<br />* Event 事件类型，subscribe<br />* EventKey 事件KEY值，qrscene_为前缀，后面为二维码的参数值<br />* Ticket 二维码的ticket，可用来换取二维码图片<br />* &lt;p&gt;<br />* &lt;p&gt;<br />* 》》》3.上报地理位置事件《《《<br />* 参数 描述<br />* ToUserName 开发者微信号<br />* FromUserName 发送方帐号（一个OpenID）<br />* CreateTime 消息创建时间 （整型）<br />* MsgType 消息类型，event<br />* Event 事件类型，LOCATION<br />* Latitude 地理位置纬度<br />* Longitude 地理位置经度<br />* Precision 地理位置精度<br />* &lt;p&gt;<br />* &lt;p&gt;<br />* 》》》5.点击菜单拉取消息时的事件推送《《《<br />* 参数 描述<br />* ToUserName 开发者微信号<br />* FromUserName 发送方帐号（一个OpenID）<br />* CreateTime 消息创建时间 （整型）<br />* MsgType 消息类型，event<br />* Event 事件类型，CLICK<br />* EventKey 事件KEY值，与自定义菜单接口中KEY值对应<br />* &lt;p&gt;<br />* &lt;p&gt;<br />* 》》》6.点击菜单跳转链接时的事件推送《《《<br />* 参数 描述<br />* ToUserName 开发者微信号<br />* FromUserName 发送方帐号（一个OpenID）<br />* CreateTime 消息创建时间 （整型）<br />* MsgType 消息类型，event<br />* Event 事件类型，VIEW<br />* EventKey 事件KEY值，设置的跳转URL<br />* &lt;p&gt;<br />* &lt;p&gt;<br />* MsgType<br />* 消息类型，接收事件推送为event<br />* 消息类型，文本为text<br />* 消息类型，图片为image<br />* 消息类型，语音为voice<br />* 消息类型，视频为video<br />* 消息类型，音乐为music<br />* 消息类型，图文为news<br />*/<br />public static String receiveEventPush(DOMSource domSource) {<br />Map&lt;String, Object&gt; xmlMap = domSourceToMap(domSource);<br /><br />if (xmlMap == null) return "";<br /><br />String msgType = (String) xmlMap.get("MsgType");<br />String fromUserName = (String) xmlMap.get("FromUserName");<br />String toUserName = (String) xmlMap.get("ToUserName");<br />String event = (String) xmlMap.get("Event");<br />String text;<br />if (msgType.equals("event")) {<br />if (event.equals("subscribe")) {<br />// 关注事件<br />text = "关注事件";<br />} else if (event.equals("unsubscribe")) {<br />// 取消关注事件<br />text = "取消关注事件";<br />} else {<br />text = "对不起，无法识别消息类型";<br />}<br />} else if (msgType.equals("text")) {<br />// 消息类型，为text<br />text = "消息类型，文本为text";<br />} else if (msgType.equals("image")) {<br />// 消息类型，图片为image<br />text = "消息类型，图片为image";<br />} else if (msgType.equals("voice")) {<br />// 消息类型，语音为voice<br />text = "消息类型，语音为voice";<br />} else if (msgType.equals("video")) {<br />// 消息类型，视频为video<br />text = "消息类型，视频为video";<br />} else if (msgType.equals("music")) {<br />// 消息类型，音乐为music<br />text = "消息类型，音乐为music";<br />} else if (msgType.equals("news")) {<br />// 消息类型，图文为news<br />text = "消息类型，图文为news";<br />} else {<br />text = "对不起，无法识别消息类型";<br />}<br /><br />String returnData = "&lt;?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?&gt;" +<br />" &lt;xml&gt;" +<br />" &lt;Content&gt;" + text + "&lt;/Content&gt;" +<br />" &lt;ToUserName&gt;" + fromUserName + "&lt;/ToUserName&gt;" +<br />" &lt;FromUserName&gt;" + toUserName + "&lt;/FromUserName&gt;" +<br />" &lt;CreateTime&gt;" + new Date().getTime() / 1000 + "&lt;/CreateTime&gt;" +<br />" &lt;MsgType&gt;text&lt;/MsgType&gt;" +<br />" &lt;/xml&gt;";<br /><br />//输出格式化后的json<br />return returnData;<br />}<br /><br />private static Map&lt;String, Object&gt; domSourceToMap(DOMSource domSource) {<br />try {<br />StringWriter writer = new StringWriter();<br />StreamResult result = new StreamResult(writer);<br />TransformerFactory tf = TransformerFactory.newInstance();<br />Transformer transformer = tf.newTransformer();<br />transformer.transform(domSource, result);<br /><br />SAXBuilder sb = new SAXBuilder();<br />Document doc = sb.build(new StringReader(writer.toString()));<br />Element root = doc.getRootElement();<br /><br />JSONObject json = new JSONObject();<br />json.put(root.getName(), iterateElement(root));<br /><br />Map&lt;String, Object&gt; dataMap = JSONObject.parseObject(json.toJSONString(), Map.class);<br />Map&lt;String, Object&gt; xmlMap = (Map&lt;String, Object&gt;) dataMap.get("xml");<br />return xmlMap;<br />} catch (TransformerConfigurationException e) {<br />e.printStackTrace();<br />} catch (TransformerException e) {<br />e.printStackTrace();<br />} catch (IOException e) {<br />e.printStackTrace();<br />} catch (JDOMException e) {<br />e.printStackTrace();<br />}<br /><br />return null;<br />}<br /><br />private static JSONObject iterateElement(Element element) {<br />List&lt;Element&gt; node = element.getChildren();<br />JSONObject obj = new JSONObject();<br />List list = null;<br />for (Element child : node) {<br />list = new LinkedList();<br />String text = child.getTextTrim();<br />if (text == null || text.equals("")) {<br />if (child.getChildren().size() == 0) {<br />continue;<br />}<br />if (obj.containsKey(child.getName())) {<br />list = (List) obj.get(child.getName());<br />}<br />list.add(iterateElement(child)); //遍历child的子节点<br />obj.put(child.getName(), list);<br />} else {<br />if (obj.containsKey(child.getName())) {<br />Object value = obj.get(child.getName());<br />try {<br />list = (List) value;<br />} catch (ClassCastException e) {<br />list.add(value);<br />}<br />}<br />if (child.getChildren().size() == 0) { //child无子节点时直接设置text<br />obj.put(child.getName(), text);<br />} else {<br />list.add(text);<br />obj.put(child.getName(), list);<br />}<br />}<br />}<br />return obj;<br />}<br /><br />/**<br />* 验证微信绑定服务器的方法<br />*<br />* @param signature<br />* @param timestamp<br />* @param nonce<br />* @return<br />*/<br />public static boolean checkSignature(String signature, String timestamp, String nonce) {<br />//1.定义数组存放tooken，timestamp,nonce<br />String[] arr = {"7i6L5SEu4NPuYiGVAXMy0ZnFxd6", timestamp, nonce};<br /><br />//2.对数组进行排序<br />Arrays.sort(arr);<br /><br />//3.生成字符串<br />StringBuffer sb = new StringBuffer();<br />for (String s : arr) {<br />sb.append(s);<br />}<br /><br />//4.sha1加密,网上均有现成代码<br />String temp = getSha(sb.toString());<br /><br />//5.将加密后的字符串，与微信传来的加密签名比较，返回结果<br />return temp.equals(signature);<br />}<br /><br /><br />public static String getSha(String str) {<br />if (str == null || str.length() == 0) {<br />return null;<br />}<br />char hexDigits[] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};<br />try {<br /><br />MessageDigest mdTemp = MessageDigest.getInstance("SHA1");<br /><br />mdTemp.update(str.getBytes("UTF-8"));<br /><br /><br />byte[] md = mdTemp.digest();<br /><br />int j = md.length;<br /><br />char buf[] = new char[j * 2];<br /><br />int k = 0;<br /><br />for (int i = 0; i &lt; j; i++) {<br /><br />byte byte0 = md[i];<br /><br />buf[k++] = hexDigits[byte0 &gt;&gt;&gt; 4 &amp; 0xf];<br /><br />buf[k++] = hexDigits[byte0 &amp; 0xf];<br /><br />}<br /><br />return new String(buf);<br /><br />} catch (Exception e) {<br /><br />// TODO: handle exception<br /><br />return null;<br /><br />}<br /><br />}<br /><br /><br />}</p>
<h1>微信工具类需要的其他方法&nbsp;</h1>
<p>/**<br />* 发送HttpPost请求<br />*<br />* @param strURL 服务地址<br />* @param params json字符串,例如: "{ \"id\":\"12345\" }" ;其中属性名必须带双引号&lt;br/&gt;<br />* @return 成功:返回json字符串&lt;br/&gt;<br />*/<br />public static Map&lt;String, Object&gt; reqPost(String strURL, String params) {<br />BufferedReader reader;<br />try {<br />URL url = new URL(strURL);// 创建连接<br />HttpURLConnection connection = (HttpURLConnection) url.openConnection();<br />connection.setDoOutput(true);<br />connection.setDoInput(true);<br />connection.setUseCaches(false);<br />connection.setInstanceFollowRedirects(true);<br />connection.setRequestMethod("POST"); // 设置请求方式<br />connection.setRequestProperty("Accept", "application/json"); // 设置接收数据的格式<br />connection.setRequestProperty("Content-Type", "application/json"); // 设置发送数据的格式<br />connection.connect();<br />//一定要用BufferedReader 来接收响应， 使用字节来接收响应的方法是接收不到内容的<br />OutputStreamWriter out = new OutputStreamWriter(connection.getOutputStream(), "UTF-8"); // utf-8编码<br />out.append(params);<br />out.flush();<br />out.close();<br />// 读取响应<br />reader = new BufferedReader(new InputStreamReader(connection.getInputStream(), "UTF-8"));<br />String line;<br />String res = "";<br />while ((line = reader.readLine()) != null) {<br />res += line;<br />}<br />reader.close();<br /><br />return JSON.parseObject(res, Map.class);<br />} catch (IOException e) {<br />e.printStackTrace();<br />return null;<br />}<br />}<br /><br />/**<br />* 请求url<br />*<br />* @param url<br />* @return<br />*/<br />public static Map&lt;String, Object&gt; reqGetMap(String url) {<br />try {<br />URL reqURL = new URL(url);<br />HttpsURLConnection openConnection = (HttpsURLConnection) reqURL.openConnection();<br />openConnection.setConnectTimeout(10000);<br />//这里我感觉获取openid的时间比较长，不过也可能是我网络的问题，<br />//所以设置的响应时间比较长<br />openConnection.connect();<br />InputStream in = openConnection.getInputStream();<br /><br />StringBuilder builder = new StringBuilder();<br />BufferedReader bufreader = new BufferedReader(new InputStreamReader(in));<br />for (String temp = bufreader.readLine(); temp != null; temp = bufreader<br />.readLine()) {<br />builder.append(temp);<br />}<br /><br />String result = builder.toString();<br />in.close();<br />openConnection.disconnect();<br /><br />Map&lt;String, Object&gt; resultMap = JSON.parseObject(result, Map.class);<br /><br />return resultMap;<br />} catch (Exception e) {<br />e.printStackTrace();<br />return null;<br />}<br />}</p>

</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>