<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修Java基础第一天--继承、修饰符' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>Java基础第一天--继承、修饰符</center></div><div class='banquan'>原文出处:本文由博客园博主双眼皮的小眼睛提供。<br/>
原文连接:https://www.cnblogs.com/energy-xjq/p/first_day.html</div><br>
    <h1 id="继承">继承</h1>
<h2 id="继承的概述">继承的概述：</h2>
<p>继承是面向对象三大特征之一。可以使得子类具有父类的属性和方法，还可以在子类中重新定义，追加属性和方法。</p>
<pre><code><code>    //创建父类
    public class Fu{
        public void show(){
            System.out.println(&quot;show方法被调用&quot;);
        }
    }</code></code></pre>
<pre><code><code>    //创建子类让子类继承父类
    public class Zi extends Fu{
        public void method(){
            System.out.println(&quot;method方法被调用&quot;);
        }
    }</code></code></pre>
<pre><code><code>    //测试类
    public class Demo{
        public static void main(String[] args){
            Fu f = new Fu();
            f.show();
            //show方法被调用

            Zi z = new Zi();
            z.method();
            z.show();
            //metho方法被调用
            //show方法被调用
        }
    }</code></code></pre>
<h2 id="继承的好处">继承的好处：</h2>
<ul>
<li>提高了代码的复用性</li>
<li>提高了代码的维护性</li>
</ul>
<h2 id="继承的弊端">继承的弊端：</h2>
<ul>
<li>继承让类与类之间产生了关系，类的耦合性增强了，削弱了子类的独立性</li>
</ul>
<pre><code><code>    //创建父类
    public class Fu{
        public int age = 40；
    }</code></code></pre>
<pre><code><code>    //创建子类让子类继承父类
    public class Zi extends Fu{
        public int height = 175;

        public int age = 20;

        public void show(){
            int age =30;
            System.out.println(age);
            System.out.println(height);
        }
    }</code></code></pre>
<pre><code><code>    //测试类
    public class Demo{
        public static void main(String[] args){
            Zi z = new Zi();
            z.show();
        }
    }</code></code></pre>
<h2 id="继承中变量的访问特点">继承中变量的访问特点：</h2>
<p>在子类中访问一个变量</p>
<ul>
<li>子类局部范围找</li>
<li>子类成员范围找</li>
<li>父类成员范围找</li>
<li>如果都没有就报错</li>
</ul>
<pre><code><code>    //创建父类
    public class Fu{
        public int age = 40；
    }</code></code></pre>
<pre><code><code>    //创建子类让子类继承父类
    public class Zi extends Fu{
        public int age = 20;

        public void show(){
            int age =30;
            System.out.println(age);
            System.out.println(this.age)  //访问本类成员变量age
            System.out.println(super.age) //访问父类成员变量age
       }
    }</code></code></pre>
<pre><code><code>    //测试类
    public class Demo{
        public static void main(String[] args){
            Zi z = new Zi();
            z.show(); 
        }
    }</code></code></pre>
<h3 id="super">super</h3>
<ul>
<li>this：代表本类对象的引用</li>
<li>super：代表父类储存空间的标示（父类对象的引用）</li>
</ul>
<table>
<thead>
<tr class="header">
<th>关键字</th>
<th>访问成员变量</th>
<th>访问成员构造方法</th>
<th>访问成员方法</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>this</td>
<td>this.成员变量 访问本类成员变量</td>
<td>this(...) 访问本类构造方法</td>
<td>this.成员方法(...) 访问本类成员方法</td>
</tr>
<tr class="even">
<td>super</td>
<td>super.成员变量 访问父类成员变量</td>
<td>super(...) 访问父类构造方法</td>
<td>super.成员方法(...) 访问本类成员方法</td>
</tr>
</tbody>
</table>
<pre><code><code>    //创建父类
    public class Fu{
        public Fu(){
           System.out.println(&quot;Fu中无参构造方法被调用&quot;); 
        }
        public Fu(int age){
            System.out.println(&quot;Fu中带参构造方法被调用&quot;);
        }
    }</code></code></pre>
<pre><code><code>    //创建子类
    public class Zi{
        public Zi(){
            //super();
            System.out.println(&quot;Zi中无参构造方法被调用&quot;); 
        }
        public Zi(int age){
            //super(); 
            System.out.println(&quot;Zi中带参构造方法被调用&quot;);
        }
    }</code></code></pre>
<pre><code><code>    //测试类
    public class Demo{
        public static void main(String[] args){
            Zi z = new Zi();
            //输出Fu中无参构造方法被调用
            //输出Zi中无参构造方法被调用

            Zi z2 = new Zi(age:20);
            //输出Fu中无参构造方法被调用
            //输出Zi中无参构造方法被调用
            //输出Fu中无参构造方法被调用
            //输出Zi中带参构造方法被调用
        }
    }</code></code></pre>
<h2 id="继承中构造方法的访问特点">继承中构造方法的访问特点：</h2>
<p>子类中所有的构造方法默认都会访问父类中无参的构造方法，为什么呢？</p>
<ul>
<li>因为子类会继承父类中的数据，可能还会使用父类的数据。所以子类初始化之前，一定要先完成父类数据的初始化</li>
<li>每一个子类构造方法的第一条语句默认都是：<strong><code>super()</code></strong></li>
</ul>
<p>如果父类中没有无参构造方法，只有带参构造方法怎么办呢？</p>
<ul>
<li>通过使用super关键字去显示调用父类的带参构造方法</li>
<li>在父类中自己提供一个无参构造方法</li>
</ul>
<pre><code><code>    //创建父类
    public class Fu{
        public void show(){
            System.out.println(&quot;Fu中show方法被调用&quot;);
        }
    }</code></code></pre>
<pre><code><code>    //创建子类让子类继承父类
    public class Zi extends Fu{
        public void method(){
            System.out.println(&quot;Zi中method方法被调用&quot;);

        public void show(){
            super.show();
            System.out.println(&quot;Zi中show方法被调用&quot;);
        }
    }</code></code></pre>
<pre><code><code>    //测试类
    public class Demo{
        public static void main(String[] args){
            Zi z = new Zi();
            z.method();
            z.show();
        }
    }</code></code></pre>
<h2 id="继承中成员方法的访问特点">继承中成员方法的访问特点：</h2>
<p>通过子类对象访问一个方法</p>
<ul>
<li>子类成员范围找</li>
<li>父类成员范围找</li>
<li>如果都没有就报错</li>
</ul>
<h2 id="方法重写">方法重写：</h2>
<p>方法重写概述</p>
<ul>
<li>子类中出现了和父类一样的方法声明</li>
</ul>
<p>方法重写的应用</p>
<ul>
<li>当子类需要父类的功能，而功能主体子类有自己特有内容时，可以重写父类中的方法，这时，即沿袭了父类的功能，又定义了子类特有的内容</li>
</ul>
<h3 id="override"><strong><code>Override</code></strong></h3>
<ul>
<li>这是一个注解</li>
<li>可以帮组我们检查重写方法的方法声明的正确性</li>
</ul>
<pre><code><code>    //创建手机类
    public class Phone{
        public void call(String name){
            System.out.println(&quot;给&quot;+name+“打电话”);
        }
    }</code></code></pre>
<pre><code><code>    //创建新手机类继承手机类
    /*
    public class NewPhpne extends phone {
        public void call(String name){
            System.out.println(&quot;开启视频功能&quot;);
//          System.out.println(&quot;给&quot;+name+“打电话”);  
            super.call(name);   
    }
    */
    @override
    public class NewPhpne extends phone {
        public void call(String name){
            System.out.println(&quot;开启视频功能&quot;);
            super.call(name);</code></code></pre>
<pre><code><code>    //手机测试类
    public class PhoneDemo {
        Phone p = new Phone();
        p.call(&quot;周杰伦&quot;);

        NewPhone np = new NewPhone();
        np.call(&quot;周杰伦&quot;);
    }</code></code></pre>
<h2 id="方法重写注意事项">方法重写注意事项：</h2>
<ul>
<li>私有方法不能被重写(父类私有成员子类不能继承)</li>
<li>子类方法访问权限不能更低(public&gt;默认&gt;私有)</li>
</ul>
<h2 id="java中继承的注意事项">Java中继承的注意事项：</h2>
<ul>
<li>Java中类只支持单继承，不支持多继承</li>
<li>Java中类支持多层继承</li>
</ul>
<h1 id="修饰符">修饰符</h1>
<h2 id="包的概述和使用">包的概述和使用</h2>
<p>包其实就是文件夹,对类进行分类管理</p>
<h2 id="导包的概述和使用">导包的概述和使用</h2>
<p>使用不同包下的类时，使用的时候要写类的全路径，写起来太麻烦了，为了简化带包的操作，Java就提供了导包的功能</p>
<h2 id="权限修饰符">权限修饰符</h2>
<table>
<thead>
<tr class="header">
<th>修饰符</th>
<th>同一个类中</th>
<th>同一个包中子类无关类</th>
<th>不同包的子类</th>
<th>不同包的无关类</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>private</td>
<td>√</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>默认</td>
<td>√</td>
<td>√</td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>protected</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td></td>
</tr>
<tr class="even">
<td>public</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
</tbody>
</table>
<h2 id="状态修饰符finalstatic">状态修饰符(final、static)</h2>
<ul>
<li><h2 id="final最终态"><strong>final</strong>(最终态)：</h2></li>
</ul>
<ol>
<li><h3 id="final关键字是最终的意思可以修饰成员方法成员变量类"><strong>final</strong>关键字是最终的意思，可以修饰成员方法，成员变量，类</h3></li>
<li><h3 id="final修饰的特点"><strong>final</strong>修饰的特点：</h3></li>
</ol>
<ul>
<li>修饰方法：表明该方法是最终方法，<strong>不能被重写</strong></li>
<li>修饰变量：表明该变量是常量，<strong>不能再次被赋值</strong></li>
<li>修饰类：表明该类是最终类，<strong>不能被继承</strong></li>
</ul>
<ol>
<li><h3 id="final修饰局部变量"><strong>final修饰局部变量</strong></h3></li>
</ol>
<ul>
<li>变量是基本类型：final修饰指的是基本类型的<strong>数据值</strong>不能发生改变</li>
<li><p>变量是引用类型：final修饰指的是引用类型的<strong>地址值</strong>不能发生改变，但是地址里面的内容是可以发生改变的</p></li>
<li><h2 id="static静态"><strong>static</strong>(静态)：</h2></li>
</ul>
<ol>
<li><h3 id="static关键字是静态的意思可以修饰成员方法成员变量"><strong>static</strong>关键字是静态的意思，可以修饰成员方法，成员变量</h3></li>
<li><h3 id="static修饰的特点"><strong>static</strong>修饰的特点：</h3></li>
</ol>
<ul>
<li>被类的所有对象共享</li>
<li>可以通过类名调用</li>
</ul>
<ol>
<li><h3 id="static访问特点">static访问特点</h3></li>
</ol>
<ul>
<li>非静态的成员方法：能访问静态成员变量、非静态成员变量、静态成员方法、非静态成员方法</li>
<li>静态的成员方法：能访问静态成员变量、静态成员方法</li>
</ul>


</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>