<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修面试必备：Java线程池解析' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>面试必备：Java线程池解析</center></div><div class='banquan'>原文出处:本文由博客园博主Jay_huaxiao提供。<br/>
原文连接:https://www.cnblogs.com/jay-huaxiao/p/11454416.html</div><br>
    <h2 id="前言">前言</h2>
<p>掌握线程池是后端程序员的基本要求，相信大家求职面试过程中，几乎都会被问到有关于线程池的问题。我在网上搜集了几道经典的线程池面试题，并以此为切入点，谈谈我对线程池的理解。如果有哪里理解不正确，非常希望大家指出，接下来大家一起分析学习吧。</p>
<h2 id="经典面试题">经典面试题</h2>
<ul>
<li>面试问题1：Java的线程池说一下，各个参数的作用，如何进行的?</li>
<li>面试问题2：按线程池内部机制，当提交新任务时，有哪些异常要考虑。</li>
<li>面试问题3：线程池都有哪几种工作队列？</li>
<li>面试问题4：使用无界队列的线程池会导致内存飙升吗？</li>
<li>面试问题5：说说几种常见的线程池及使用场景?</li>
</ul>
<h2 id="线程池概念">线程池概念</h2>
<p><strong>线程池：</strong> 简单理解，它就是一个管理线程的池子。</p>
<ul>
<li><strong>它帮我们管理线程，避免增加创建线程和销毁线程的资源损耗</strong>。因为线程其实也是一个对象，创建一个对象，需要经过类加载过程，销毁一个对象，需要走GC垃圾回收流程，都是需要资源开销的。</li>
<li><strong>提高响应速度。</strong> 如果任务到达了，相对于从线程池拿线程，重新去创建一条线程执行，速度肯定慢很多。</li>
<li><strong>重复利用。</strong> 线程用完，再放回池子，可以达到重复利用的效果，节省资源。</li>
</ul>
<h2 id="线程池的创建">线程池的创建</h2>
<p>线程池可以通过ThreadPoolExecutor来创建，我们来看一下它的构造函数：</p>
<pre><code><code>public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize,long keepAliveTime,TimeUnit unit,
   BlockingQueue&lt;Runnable&gt; workQueue,
   ThreadFactory threadFactory,
   RejectedExecutionHandler handler) </code></code></pre>
<p>几个核心参数的作用：</p>
<ul>
<li><strong>corePoolSize：</strong> 线程池核心线程数最大值</li>
<li><strong>maximumPoolSize：</strong> 线程池最大线程数大小</li>
<li><strong>keepAliveTime：</strong> 线程池中非核心线程空闲的存活时间大小</li>
<li><strong>unit：</strong> 线程空闲存活时间单位</li>
<li><strong>workQueue：</strong> 存放任务的阻塞队列</li>
<li><strong>threadFactory：</strong> 用于设置创建线程的工厂，可以给创建的线程设置有意义的名字，可方便排查问题。</li>
<li><strong>handler：</strong> 线城池的饱和策略事件，主要有四种类型。</li>
</ul>
<h2 id="任务执行">任务执行</h2>
<h3 id="线程池执行流程即对应execute方法">线程池执行流程，即对应execute()方法：</h3>
<p><img src="./images/面试必备：Java线程池解析0.png" /></p>
<ul>
<li>提交一个任务，线程池里存活的核心线程数小于线程数corePoolSize时，线程池会创建一个核心线程去处理提交的任务。</li>
<li>如果线程池核心线程数已满，即线程数已经等于corePoolSize，一个新提交的任务，会被放进任务队列workQueue排队等待执行。</li>
<li>当线程池里面存活的线程数已经等于corePoolSize了,并且任务队列workQueue也满，判断线程数是否达到maximumPoolSize，即最大线程数是否已满，如果没到达，创建一个非核心线程执行提交的任务。</li>
<li>如果当前的线程数达到了maximumPoolSize，还有新的任务过来的话，直接采用拒绝策略处理。</li>
</ul>
<h3 id="四种拒绝策略">四种拒绝策略</h3>
<ul>
<li>AbortPolicy(抛出一个异常，默认的)</li>
<li>DiscardPolicy(直接丢弃任务)</li>
<li>DiscardOldestPolicy（丢弃队列里最老的任务，将当前这个任务继续提交给线程池）</li>
<li>CallerRunsPolicy（交给线程池调用所在的线程进行处理)</li>
</ul>
<h3 id="为了形象描述线程池执行我打个比喻">为了形象描述线程池执行，我打个比喻：</h3>
<ul>
<li>核心线程比作公司正式员工</li>
<li>非核心线程比作外包员工</li>
<li>阻塞队列比作需求池</li>
<li>提交任务比作提需求<br />
<img src="./images/面试必备：Java线程池解析1.png" /></li>
<li>当产品提个需求，正式员工（核心线程）先接需求（执行任务）</li>
<li>如果正式员工都有需求在做，即核心线程数已满），产品就把需求先放需求池（阻塞队列）。</li>
<li>如果需求池(阻塞队列)也满了，但是这时候产品继续提需求,怎么办呢？那就请外包（非核心线程）来做。</li>
<li>如果所有员工（最大线程数也满了）都有需求在做了，那就执行拒绝策略。</li>
<li>如果外包员工把需求做完了，它经过一段（keepAliveTime）空闲时间，就离开公司了。</li>
</ul>
<p>好的，到这里。<strong>面试问题1-&gt;Java的线程池说一下，各个参数的作用，如何进行的?</strong> 是否已经迎刃而解啦，<br />
我觉得这个问题，回答：<strong>线程池构造函数的corePoolSize,maximumPoolSize等参数，并且能描述清楚线程池的执行流程</strong> 就差不多啦。</p>
<h2 id="线程池异常处理">线程池异常处理</h2>
<p>在使用线程池处理任务的时候，任务代码可能抛出RuntimeException，抛出异常后，线程池可能捕获它，也可能创建一个新的线程来代替异常的线程，我们可能无法感知任务出现了异常，因此我们需要考虑线程池异常情况。</p>
<h3 id="当提交新任务时异常如何处理">当提交新任务时，异常如何处理?</h3>
<p>我们先来看一段代码：</p>
<pre><code><code>       ExecutorService threadPool = Executors.newFixedThreadPool(5);
        for (int i = 0; i &lt; 5; i++) {
            threadPool.submit(() -&gt; {
                System.out.println(&quot;current thread name&quot; + Thread.currentThread().getName());
                Object object = null;
                System.out.print(&quot;result## &quot;+object.toString());
            });
        }
</code></code></pre>
<p>显然，这段代码会有异常，我们再来看看执行结果</p>
<p><img src="./images/面试必备：Java线程池解析2.png" /></p>
<p>虽然没有结果输出，但是没有抛出异常，所以我们无法感知任务出现了异常，所以需要添加try/catch。<br />
如下图：<br />
<img src="./images/面试必备：Java线程池解析3.png" /><br />
OK，线程的异常处理，<strong>我们可以直接try...catch捕获。</strong></p>
<h3 id="线程池exec.submitrunnable的执行流程">线程池exec.submit(runnable)的执行流程</h3>
<p>通过debug上面有异常的submit方法（<strong>建议大家也去debug看一下,图上的每个方法内部是我打断点的地方</strong>），处理有异常submit方法的主要执行流程图：</p>
<p><img src="./images/面试必备：Java线程池解析4.png" /></p>
<pre><code><code>  //构造feature对象
  /**
     * @throws RejectedExecutionException {@inheritDoc}
     * @throws NullPointerException       {@inheritDoc}
     */
    public Future&lt;?&gt; submit(Runnable task) {
        if (task == null) throw new NullPointerException();
        RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, null);
        execute(ftask);
        return ftask;
    }
     protected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Runnable runnable, T value) {
        return new FutureTask&lt;T&gt;(runnable, value);
    }
     public FutureTask(Runnable runnable, V result) {
        this.callable = Executors.callable(runnable, result);
        this.state = NEW;       // ensure visibility of callable
    }
       public static &lt;T&gt; Callable&lt;T&gt; callable(Runnable task, T result) {
        if (task == null)
            throw new NullPointerException();
        return new RunnableAdapter&lt;T&gt;(task, result);
    }
    //线程池执行
     public void execute(Runnable command) {
        if (command == null)
            throw new NullPointerException();
               int c = ctl.get();
        if (workerCountOf(c) &lt; corePoolSize) {
            if (addWorker(command, true))
                return;
            c = ctl.get();
        }
        if (isRunning(c) &amp;&amp; workQueue.offer(command)) {
            int recheck = ctl.get();
            if (! isRunning(recheck) &amp;&amp; remove(command))
                reject(command);
            else if (workerCountOf(recheck) == 0)
                addWorker(null, false);
        }
        else if (!addWorker(command, false))
            reject(command);
    }
    //捕获异常
    public void run() {
        if (state != NEW ||
            !UNSAFE.compareAndSwapObject(this, runnerOffset,
                                         null, Thread.currentThread()))
            return;
        try {
            Callable&lt;V&gt; c = callable;
            if (c != null &amp;&amp; state == NEW) {
                V result;
                boolean ran;
                try {
                    result = c.call();
                    ran = true;
                } catch (Throwable ex) {
                    result = null;
                    ran = false;
                    setException(ex);
                }
                if (ran)
                    set(result);
            }
        } finally {
            // runner must be non-null until state is settled to
            // prevent concurrent calls to run()
            runner = null;
            // state must be re-read after nulling runner to prevent
            // leaked interrupts
            int s = state;
            if (s &gt;= INTERRUPTING)
                handlePossibleCancellationInterrupt(s);
        }</code></code></pre>
<p>通过以上分析，<strong>submit执行的任务，可以通过Future对象的get方法接收抛出的异常，再进行处理。</strong><br />
我们再通过一个demo，看一下Future对象的get方法处理异常的姿势，如下图：</p>
<p><img src="./images/面试必备：Java线程池解析5.png" /></p>
<h3 id="其他两种处理线程池异常方案">其他两种处理线程池异常方案</h3>
<p>除了以上<strong>1.在任务代码try/catch捕获异常，2.通过Future对象的get方法接收抛出的异常，再处理</strong>两种方案外，还有以上两种方案：</p>
<h4 id="为工作者线程设置uncaughtexceptionhandler在uncaughtexception方法中处理异常">3.为工作者线程设置UncaughtExceptionHandler，在uncaughtException方法中处理异常</h4>
<p>我们直接看这样实现的正确姿势：</p>
<pre><code><code>ExecutorService threadPool = Executors.newFixedThreadPool(1, r -&gt; {
            Thread t = new Thread(r);
            t.setUncaughtExceptionHandler(
                    (t1, e) -&gt; {
                        System.out.println(t1.getName() + &quot;线程抛出的异常&quot;+e);
                    });
            return t;
           });
        threadPool.execute(()-&gt;{
            Object object = null;
            System.out.print(&quot;result## &quot; + object.toString());
        });</code></code></pre>
<p>运行结果：<br />
<img src="./images/面试必备：Java线程池解析6.png" /></p>
<h4 id="重写threadpoolexecutor的afterexecute方法处理传递的异常引用">4.重写ThreadPoolExecutor的afterExecute方法，处理传递的异常引用</h4>
<p>这是jdk文档的一个demo：</p>
<pre><code><code>class ExtendedExecutor extends ThreadPoolExecutor {
    // 这可是jdk文档里面给的例子。。
    protected void afterExecute(Runnable r, Throwable t) {
        super.afterExecute(r, t);
        if (t == null &amp;&amp; r instanceof Future&lt;?&gt;) {
            try {
                Object result = ((Future&lt;?&gt;) r).get();
            } catch (CancellationException ce) {
                t = ce;
            } catch (ExecutionException ee) {
                t = ee.getCause();
            } catch (InterruptedException ie) {
                Thread.currentThread().interrupt(); // ignore/reset
            }
        }
        if (t != null)
            System.out.println(t);
    }
}}</code></code></pre>
<h3 id="因此被问到线程池异常处理如何回答">因此，被问到线程池异常处理，如何回答？</h3>
<p><img src="./images/面试必备：Java线程池解析7.png" />。</p>
<h2 id="线程池的工作队列">线程池的工作队列</h2>
<p><strong>线程池都有哪几种工作队列？</strong></p>
<ul>
<li>ArrayBlockingQueue</li>
<li>LinkedBlockingQueue</li>
<li>DelayQueue</li>
<li>PriorityBlockingQueue</li>
<li>SynchronousQueue</li>
</ul>
<h3 id="arrayblockingqueue">ArrayBlockingQueue</h3>
<p>ArrayBlockingQueue（有界队列）是一个用数组实现的有界阻塞队列，按FIFO排序量。</p>
<h3 id="linkedblockingqueue">LinkedBlockingQueue</h3>
<p>LinkedBlockingQueue（可设置容量队列）基于链表结构的阻塞队列，按FIFO排序任务，容量可以选择进行设置，不设置的话，将是一个无边界的阻塞队列，最大长度为Integer.MAX_VALUE，吞吐量通常要高于ArrayBlockingQuene；newFixedThreadPool线程池使用了这个队列</p>
<h3 id="delayqueue">DelayQueue</h3>
<p>DelayQueue（延迟队列）是一个任务定时周期的延迟执行的队列。根据指定的执行时间从小到大排序，否则根据插入到队列的先后排序。newScheduledThreadPool线程池使用了这个队列。</p>
<h3 id="priorityblockingqueue">PriorityBlockingQueue</h3>
<p>PriorityBlockingQueue（优先级队列）是具有优先级的无界阻塞队列；</p>
<h3 id="synchronousqueue">SynchronousQueue</h3>
<p>SynchronousQueue（同步队列）一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQuene，newCachedThreadPool线程池使用了这个队列。</p>
<p>针对面试题：<strong>线程池都有哪几种工作队列？</strong> 我觉得，<strong>回答以上几种ArrayBlockingQueue，LinkedBlockingQueue，SynchronousQueue等，说出它们的特点，并结合使用到对应队列的常用线程池(如newFixedThreadPool线程池使用LinkedBlockingQueue)，进行展开阐述，</strong> 就可以啦。</p>
<h2 id="几种常用的线程池">几种常用的线程池</h2>
<ul>
<li>newFixedThreadPool (固定数目线程的线程池)</li>
<li>newCachedThreadPool(可缓存线程的线程池)</li>
<li>newSingleThreadExecutor(单线程的线程池)</li>
<li>newScheduledThreadPool(定时及周期执行的线程池)</li>
</ul>
<h3 id="newfixedthreadpool">newFixedThreadPool</h3>
<pre><code><code>  public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) {
        return new ThreadPoolExecutor(nThreads, nThreads,
                                      0L, TimeUnit.MILLISECONDS,
                                      new LinkedBlockingQueue&lt;Runnable&gt;(),
                                      threadFactory);
    }</code></code></pre>
<h4 id="线程池特点">线程池特点：</h4>
<ul>
<li>核心线程数和最大线程数大小一样</li>
<li>没有所谓的非空闲时间，即keepAliveTime为0</li>
<li>阻塞队列为无界队列LinkedBlockingQueue</li>
</ul>
<h4 id="工作机制">工作机制：</h4>
<p><img src="./images/面试必备：Java线程池解析8.png" /></p>
<ul>
<li>提交任务</li>
<li>如果线程数少于核心线程，创建核心线程执行任务</li>
<li>如果线程数等于核心线程，把任务添加到LinkedBlockingQueue阻塞队列</li>
<li>如果线程执行完任务，去阻塞队列取任务，继续执行。</li>
</ul>
<h4 id="实例代码">实例代码</h4>
<pre><code><code>   ExecutorService executor = Executors.newFixedThreadPool(10);
                    for (int i = 0; i &lt; Integer.MAX_VALUE; i++) {
                        executor.execute(()-&gt;{
                            try {
                                Thread.sleep(10000);
                            } catch (InterruptedException e) {
                                //do nothing
                            }
            });</code></code></pre>
<p>IDE指定JVM参数：-Xmx8m -Xms8m :</p>
<p><img src="./images/面试必备：Java线程池解析9.png" /></p>
<p>run以上代码，会抛出OOM：</p>
<p><img src="./images/面试必备：Java线程池解析10.png" /></p>
<p>因此，<strong>面试题：使用无界队列的线程池会导致内存飙升吗？</strong></p>
<p>答案 <strong>：会的，newFixedThreadPool使用了无界的阻塞队列LinkedBlockingQueue，如果线程获取一个任务后，任务的执行时间比较长(比如，上面demo设置了10秒)，会导致队列的任务越积越多，导致机器内存使用不停飙升，</strong> 最终导致OOM。</p>
<h4 id="使用场景">使用场景</h4>
<p>FixedThreadPool 适用于处理CPU密集型的任务，确保CPU在长期被工作线程使用的情况下，尽可能的少的分配线程，即适用执行长期的任务。</p>
<h3 id="newcachedthreadpool">newCachedThreadPool</h3>
<pre><code><code>   public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory) {
        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                      60L, TimeUnit.SECONDS,
                                      new SynchronousQueue&lt;Runnable&gt;(),
                                      threadFactory);
    }</code></code></pre>
<h4 id="线程池特点-1">线程池特点：</h4>
<ul>
<li>核心线程数为0</li>
<li>最大线程数为Integer.MAX_VALUE</li>
<li>阻塞队列是SynchronousQueue</li>
<li>非核心线程空闲存活时间为60秒</li>
</ul>
<p>当提交任务的速度大于处理任务的速度时，每次提交一个任务，就必然会创建一个线程。极端情况下会创建过多的线程，耗尽 CPU 和内存资源。由于空闲 60 秒的线程会被终止，长时间保持空闲的 CachedThreadPool 不会占用任何资源。</p>
<h4 id="工作机制-1">工作机制</h4>
<p><img src="./images/面试必备：Java线程池解析11.png" /></p>
<ul>
<li>提交任务</li>
<li>因为没有核心线程，所以任务直接加到SynchronousQueue队列。</li>
<li>判断是否有空闲线程，如果有，就去取出任务执行。</li>
<li>如果没有空闲线程，就新建一个线程执行。</li>
<li>执行完任务的线程，还可以存活60秒，如果在这期间，接到任务，可以继续活下去；否则，被销毁。</li>
</ul>
<h4 id="实例代码-1">实例代码</h4>
<pre><code><code>  ExecutorService executor = Executors.newCachedThreadPool();
        for (int i = 0; i &lt; 5; i++) {
            executor.execute(() -&gt; {
                System.out.println(Thread.currentThread().getName()+&quot;正在执行&quot;);
            });
        }</code></code></pre>
<p>运行结果：</p>
<p><img src="./images/面试必备：Java线程池解析12.png" /></p>
<h4 id="使用场景-1">使用场景</h4>
<p>用于并发执行大量短期的小任务。</p>
<h3 id="newsinglethreadexecutor">newSingleThreadExecutor</h3>
<pre><code><code>  public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory) {
        return new FinalizableDelegatedExecutorService
            (new ThreadPoolExecutor(1, 1,
                                    0L, TimeUnit.MILLISECONDS,
                                    new LinkedBlockingQueue&lt;Runnable&gt;(),
                                    threadFactory));
    }</code></code></pre>
<h4 id="线程池特点-2">线程池特点</h4>
<ul>
<li>核心线程数为1</li>
<li>最大线程数也为1</li>
<li>阻塞队列是LinkedBlockingQueue</li>
<li>keepAliveTime为0</li>
</ul>
<h4 id="工作机制-2">工作机制</h4>
<p><img src="./images/面试必备：Java线程池解析13.png" /></p>
<ul>
<li>提交任务</li>
<li>线程池是否有一条线程在，如果没有，新建线程执行任务</li>
<li>如果有，讲任务加到阻塞队列</li>
<li>当前的唯一线程，从队列取任务，执行完一个，再继续取，一个人（一条线程）夜以继日地干活。</li>
</ul>
<h4 id="实例代码-2">实例代码</h4>
<pre><code><code>  ExecutorService executor = Executors.newSingleThreadExecutor();
                for (int i = 0; i &lt; 5; i++) {
                    executor.execute(() -&gt; {
                        System.out.println(Thread.currentThread().getName()+&quot;正在执行&quot;);
                    });
        }</code></code></pre>
<p>运行结果：</p>
<p><img src="./images/面试必备：Java线程池解析14.png" /></p>
<h4 id="使用场景-2">使用场景</h4>
<p>适用于串行执行任务的场景，一个任务一个任务地执行。</p>
<h3 id="newscheduledthreadpool">newScheduledThreadPool</h3>
<pre><code><code>    public ScheduledThreadPoolExecutor(int corePoolSize) {
        super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,
              new DelayedWorkQueue());
    }</code></code></pre>
<h4 id="线程池特点-3">线程池特点</h4>
<ul>
<li>最大线程数为Integer.MAX_VALUE</li>
<li>阻塞队列是DelayedWorkQueue</li>
<li>keepAliveTime为0</li>
<li>scheduleAtFixedRate() ：按某种速率周期执行</li>
<li>scheduleWithFixedDelay()：在某个延迟后执行</li>
</ul>
<h4 id="工作机制-3">工作机制</h4>
<ul>
<li>添加一个任务</li>
<li>线程池中的线程从 DelayQueue 中取任务</li>
<li>线程从 DelayQueue 中获取 time 大于等于当前时间的task</li>
<li>执行完后修改这个 task 的 time 为下次被执行的时间</li>
<li>这个 task 放回DelayQueue队列中</li>
</ul>
<h4 id="实例代码-3">实例代码</h4>
<pre><code><code>    /**
    创建一个给定初始延迟的间隔性的任务，之后的下次执行时间是上一次任务从执行到结束所需要的时间+* 给定的间隔时间
    */
    ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(1);
        scheduledExecutorService.scheduleWithFixedDelay(()-&gt;{
            System.out.println(&quot;current Time&quot; + System.currentTimeMillis());
            System.out.println(Thread.currentThread().getName()+&quot;正在执行&quot;);
        }, 1, 3, TimeUnit.SECONDS);</code></code></pre>
<p>运行结果：</p>
<p><img src="./images/面试必备：Java线程池解析15.png" /></p>
<pre><code><code>    /**
    创建一个给定初始延迟的间隔性的任务，之后的每次任务执行时间为 初始延迟 + N * delay(间隔) 
    */
    ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(1);
            scheduledExecutorService.scheduleAtFixedRate(()-&gt;{
            System.out.println(&quot;current Time&quot; + System.currentTimeMillis());
            System.out.println(Thread.currentThread().getName()+&quot;正在执行&quot;);
        }, 1, 3, TimeUnit.SECONDS);;</code></code></pre>
<h4 id="使用场景-3">使用场景</h4>
<p>周期性执行任务的场景，需要限制线程数量的场景</p>
<p>回到面试题：<strong>说说几种常见的线程池及使用场景？</strong></p>
<p>回答这四种经典线程池 <strong>：newFixedThreadPool，newSingleThreadExecutor，newCachedThreadPool，newScheduledThreadPool，分线程池特点，工作机制，使用场景分开描述，再分析可能存在的问题，比如newFixedThreadPool内存飙升问题</strong> 即可</p>
<h2 id="线程池状态">线程池状态</h2>
<p>线程池有这几个状态：RUNNING,SHUTDOWN,STOP,TIDYING,TERMINATED。</p>
<pre><code><code>   //线程池状态
   private static final int RUNNING    = -1 &lt;&lt; COUNT_BITS;
   private static final int SHUTDOWN   =  0 &lt;&lt; COUNT_BITS;
   private static final int STOP       =  1 &lt;&lt; COUNT_BITS;
   private static final int TIDYING    =  2 &lt;&lt; COUNT_BITS;
   private static final int TERMINATED =  3 &lt;&lt; COUNT_BITS;</code></code></pre>
<h3 id="线程池各个状态切换图">线程池各个状态切换图：</h3>
<p><img src="./images/面试必备：Java线程池解析16.png" /></p>
<p><strong>RUNNING</strong></p>
<ul>
<li>该状态的线程池会接收新任务，并处理阻塞队列中的任务;</li>
<li>调用线程池的shutdown()方法，可以切换到SHUTDOWN状态;</li>
<li>调用线程池的shutdownNow()方法，可以切换到STOP状态;</li>
</ul>
<p><strong>SHUTDOWN</strong></p>
<ul>
<li>该状态的线程池不会接收新任务，但会处理阻塞队列中的任务；</li>
<li>队列为空，并且线程池中执行的任务也为空,进入TIDYING状态;</li>
</ul>
<p><strong>STOP</strong></p>
<ul>
<li>该状态的线程不会接收新任务，也不会处理阻塞队列中的任务，而且会中断正在运行的任务；</li>
<li>线程池中执行的任务为空,进入TIDYING状态;</li>
</ul>
<p><strong>TIDYING</strong></p>
<ul>
<li>该状态表明所有的任务已经运行终止，记录的任务数量为0。</li>
<li>terminated()执行完毕，进入TERMINATED状态</li>
</ul>
<p><strong>TERMINATED</strong></p>
<ul>
<li>该状态表示线程池彻底终止</li>
</ul>
<h2 id="参考与感谢">参考与感谢</h2>
<ul>
<li>Java线程池异常处理方案：https://www.jianshu.com/p/30e488f4e021</li>
<li>Java线程池 https://www.hollischuang.com/archives/2888</li>
<li>关于线程池的面试题 https://www.jianshu.com/p/9710b899e749</li>
<li>线程池的五种状态 https://blog.csdn.net/l_kanglin/article/details/57411851</li>
<li>深入分析java线程池的实现原理 https://www.jianshu.com/p/87bff5cc8d8c/</li>
</ul>
<h2 id="个人公众号">个人公众号</h2>
<p><img src="./images/面试必备：Java线程池解析17.png" /></p>
<p>欢迎大家关注，大家一起学习，一起讨论。</p>


</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>