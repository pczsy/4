<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修SSM整合学习 四' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>SSM整合学习 四</center></div><div class='banquan'>原文出处:本文由博客园博主Lo随风的风v提供。<br/>
原文连接:https://www.cnblogs.com/lovetq520/p/11731132.html</div><br>
    <h1>事务管理</h1>
<h2 id="1-初步理解">一：初步理解</h2>
<p>理解事务之前，先讲一个你日常生活中最常干的事：取钱。&nbsp;<br />比如你去ATM机取1000块钱，大体有两个步骤：首先输入密码金额，银行卡扣掉1000元钱；然后ATM出1000元钱。这两个步骤必须是要么都执行要么都不执行。如果银行卡扣除了1000块但是ATM出钱失败的话，你将会损失1000元；如果银行卡扣钱失败但是ATM却出了1000块，那么银行将损失1000元。所以，如果一个步骤成功另一个步骤失败对双方都不是好事，如果不管哪一个步骤失败了以后，整个取钱过程都能回滚，也就是完全取消所有操作的话，这对双方都是极好的。&nbsp;<br />事务就是用来解决类似问题的。事务是一系列的动作，它们综合在一起才是一个完整的工作单元，这些动作必须全部完成，如果有一个失败的话，那么事务就会回滚到最开始的状态，仿佛什么都没发生过一样。&nbsp;<br />在企业级应用程序开发中，事务管理必不可少的技术，用来确保数据的完整性和一致性。&nbsp;<br />事务有四个特性：ACID</p>
<ul>
<li>原子性（Atomicity）：事务是一个原子操作，由一系列动作组成。事务的原子性确保动作要么全部完成，要么完全不起作用。</li>
<li>一致性（Consistency）：一旦事务完成（不管成功还是失败），系统必须确保它所建模的业务处于一致的状态，而不会是部分完成部分失败。在现实中的数据不应该被破坏。</li>
<li>隔离性（Isolation）：可能有许多事务会同时处理相同的数据，因此每个事务都应该与其他事务隔离开来，防止数据损坏。</li>
<li>持久性（Durability）：一旦事务完成，无论发生什么系统错误，它的结果都不应该受到影响，这样就能从任何系统崩溃中恢复过来。通常情况下，事务的结果被写到持久化存储器中。</li>

</ul>
<p>Spring事务管理包含两种情况，编程式事务、声明式事务。而声明式事务又包括基于注解@Transactional和tx+aop的方式。编程式事务管理使用TransactionTemplate或者PlatformTransactionManager。&nbsp;编程式事务需要手动在代码中处理事务，项目中使用的较少，也不推荐使用，因为它直接耦合代码，这里就不多介绍了，本文主要讲解申明式事务</p>
<p>&nbsp;</p>
<h2>二：申明式事务</h2>
<h3>注解@Transactional</h3>
<p>我们将之前的项目改造，在Spring配置文件applicationContext.xml中屏蔽AOP及TX部分</p>
<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br />&lt;beans xmlns="http://www.springframework.org/schema/beans"<br />       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"<br />       xmlns:context="http://www.springframework.org/schema/context"<br />       xmlns:tx="http://www.springframework.org/schema/tx"<br />       xmlns:aop="http://www.springframework.org/schema/aop"<br />       xsi:schemaLocation="http://www.springframework.org/schema/beans<br />       http://www.springframework.org/schema/beans/spring-beans.xsd<br />        http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd<br />       http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd<br />       http://www.springframework.org/schema/context<br />       http://www.springframework.org/schema/context/spring-context-3.0.xsd"&gt;<br /><br /><br /><br />    &lt;!--加载上下文注解配置--&gt;<br />    &lt;context:annotation-config/&gt;<br />    &lt;context:property-placeholder location="classpath:Resources/db.properties"/&gt;<br />    &lt;context:component-scan base-package="com.founderit"&gt;<br />        &lt;context:exclude-filter type="annotation" expression="org.springframework.stereotype.Controller"/&gt;<br />    &lt;/context:component-scan&gt;<br />    &lt;aop:aspectj-autoproxy/&gt;<br /><br />    &lt;!--DBCP数据库连接池--&gt;<br />    &lt;bean id="dataSource"<br />          class="org.apache.commons.dbcp2.BasicDataSource"<br />          destroy-method="close" &gt;<br />        &lt;property name="driverClassName" value="${DRIVERCLASS}"/&gt;<br />        &lt;property name="url" value="${URL}"/&gt;<br />        &lt;property name="username" value="${USERNAME}"/&gt;<br />        &lt;property name="password" value="${PASSWORD}"/&gt;<br />        &lt;!--maxActive: 最大连接数量--&gt;<br />        &lt;property name="maxTotal" value="150"/&gt;<br />        &lt;!--minIdle: 最小空闲连接--&gt;<br />        &lt;property name="minIdle" value="5"/&gt;<br />        &lt;!--maxIdle: 最大空闲连接--&gt;<br />        &lt;property name="maxIdle" value="20"/&gt;<br />        &lt;!--initialSize: 初始化连接--&gt;<br />        &lt;property name="initialSize" value="30"/&gt;<br />        &lt;!--removeAbandonedTimeout: 超时时间(以秒数为单位)--&gt;<br />        &lt;property name="removeAbandonedTimeout" value="10"/&gt;<br />    &lt;/bean&gt;<br /><br />    &lt;!-- spring和MyBatis完美整合 --&gt;<br />    &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt;<br />        &lt;property name="dataSource" ref="dataSource"/&gt;<br />        &lt;!-- 自动扫描mapping.xml文件 --&gt;<br />        &lt;property name="mapperLocations" value="classpath:com/founderit/mapper/*.xml"&gt;&lt;/property&gt;<br />    &lt;/bean&gt;<br /><br />    &lt;!-- DAO接口所在包名，Spring会自动查找其下的类 --&gt;<br />    &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt;<br />        &lt;property name="basePackage" value="com.founderit.dao"/&gt;<br />        &lt;property name="sqlSessionFactoryBeanName" value="sqlSessionFactory"&gt;&lt;/property&gt;<br />    &lt;/bean&gt;<br /><br /><br /><br /><br />    &lt;!--事务管理部分--&gt;<br />    &lt;bean id="transactionManager"<br />          class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt;<br />        &lt;property name="dataSource" ref="dataSource" /&gt;<br />    &lt;/bean&gt;<br />    &lt;tx:annotation-driven transaction-manager="transactionManager" proxy-target-class="true" /&gt;<br /><br /><br />&lt;!--    &lt;tx:advice id="txAdvice" transaction-manager="transactionManager"&gt;--&gt;<br />&lt;!--        &lt;tx:attributes&gt;--&gt;<br />&lt;!--            &lt;tx:method name="save*" propagation="REQUIRED" /&gt;--&gt;<br />&lt;!--            &lt;tx:method name="insert*" propagation="REQUIRED" /&gt;--&gt;<br />&lt;!--            &lt;tx:method name="add*" propagation="REQUIRED" /&gt;--&gt;<br />&lt;!--            &lt;tx:method name="create*" propagation="REQUIRED" /&gt;--&gt;<br />&lt;!--            &lt;tx:method name="delete*" propagation="REQUIRED" /&gt;--&gt;<br />&lt;!--            &lt;tx:method name="update*" propagation="REQUIRED" /&gt;--&gt;<br />&lt;!--            &lt;tx:method name="find*" propagation="SUPPORTS" read-only="true" /&gt;--&gt;<br />&lt;!--            &lt;tx:method name="select*" propagation="SUPPORTS" read-only="true" /&gt;--&gt;<br />&lt;!--            &lt;tx:method name="get*" propagation="SUPPORTS" read-only="true" /&gt;--&gt;<br />&lt;!--        &lt;/tx:attributes&gt;--&gt;<br />&lt;!--    &lt;/tx:advice&gt;--&gt;<br /><br />&lt;!--    &lt;aop:config&gt;--&gt;<br />&lt;!--        &lt;aop:pointcut id="iccardTerm" expression="execution(* com.founderit.service.*.*(..))" /&gt;--&gt;<br />&lt;!--        &lt;aop:advisor pointcut-ref="iccardTerm" advice-ref="txAdvice" /&gt;--&gt;<br />&lt;!--    &lt;/aop:config&gt;--&gt;<br /><br />&lt;/beans&gt;<br /><br /><br /></code></pre>
<p>在Service层类上加@Transactional注解，并在catch错误中手动回滚事务</p>
<pre><code>@Transactional<br />@Override<br />public int insertObject(Object obj) {<br />    int result=0;<br />    try {<br />        for (int i=0;i&lt;4;i++) {<br />            Student student=new Student();<br />            student.setName("wll");<br />            student.setAge(1);<br />            student.setId(100+i);<br />            result=userDao.insertObject(student);<br />        }<br />    }catch (Exception e){<br />        TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();<br />    }<br />    return result;<br />}</code></pre>
<p>测试</p>
<p>&nbsp;项目中将插入四条记录，我们在插入第三条时手动报错，如果没有事务，前二条正常的记录将插入成功，运行tomcat,发起hello请求</p>
<pre><code>@Transactional<br />@Override<br />public int insertObject(Object obj) {<br />    int result=0;<br />    try {<br />        for (int i=0;i&lt;4;i++) {<br />            Student student=new Student();<br />            student.setName("wll");<br />            student.setAge(1);<br />            student.setId(100+i);<br />            if (i==2){<br />                int error=10/0;<br />            }<br />            result=userDao.insertObject(student);<br />        }<br />    }catch (Exception e){<br />        TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();<br />    }<br />    return result;<br />}<br />执行日志如下，可以看到前二条记录正确执行，但是插入第三条时报错，事务进行了回滚，导致一条也没有插入成功</code></pre>
<p><img src="./images/SSM整合学习 四0.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;<img src="./images/SSM整合学习 四1.png" alt="" /></p>
<p>&nbsp;</p>
<h3>&nbsp;</h3>
<h3>&nbsp;</h3>
<h3>基于tx+aop</h3>
<p>在Spring配置文件applicationContext.xml中加上AOP及TX部分</p>
<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br />&lt;beans xmlns="http://www.springframework.org/schema/beans"<br />       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"<br />       xmlns:context="http://www.springframework.org/schema/context"<br />       xmlns:tx="http://www.springframework.org/schema/tx"<br />       xmlns:aop="http://www.springframework.org/schema/aop"<br />       xsi:schemaLocation="http://www.springframework.org/schema/beans<br />       http://www.springframework.org/schema/beans/spring-beans.xsd<br />        http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd<br />       http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd<br />       http://www.springframework.org/schema/context<br />       http://www.springframework.org/schema/context/spring-context-3.0.xsd"&gt;<br /><br /><br /><br />    &lt;!--加载上下文注解配置--&gt;<br />    &lt;context:annotation-config/&gt;<br />    &lt;context:property-placeholder location="classpath:Resources/db.properties"/&gt;<br />    &lt;context:component-scan base-package="com.founderit"&gt;<br />        &lt;context:exclude-filter type="annotation" expression="org.springframework.stereotype.Controller"/&gt;<br />    &lt;/context:component-scan&gt;<br />    &lt;aop:aspectj-autoproxy/&gt;<br /><br />    &lt;!--DBCP数据库连接池--&gt;<br />    &lt;bean id="dataSource"<br />          class="org.apache.commons.dbcp2.BasicDataSource"<br />          destroy-method="close" &gt;<br />        &lt;property name="driverClassName" value="${DRIVERCLASS}"/&gt;<br />        &lt;property name="url" value="${URL}"/&gt;<br />        &lt;property name="username" value="${USERNAME}"/&gt;<br />        &lt;property name="password" value="${PASSWORD}"/&gt;<br />        &lt;!--maxActive: 最大连接数量--&gt;<br />        &lt;property name="maxTotal" value="150"/&gt;<br />        &lt;!--minIdle: 最小空闲连接--&gt;<br />        &lt;property name="minIdle" value="5"/&gt;<br />        &lt;!--maxIdle: 最大空闲连接--&gt;<br />        &lt;property name="maxIdle" value="20"/&gt;<br />        &lt;!--initialSize: 初始化连接--&gt;<br />        &lt;property name="initialSize" value="30"/&gt;<br />        &lt;!--removeAbandonedTimeout: 超时时间(以秒数为单位)--&gt;<br />        &lt;property name="removeAbandonedTimeout" value="10"/&gt;<br />    &lt;/bean&gt;<br /><br />    &lt;!-- spring和MyBatis完美整合 --&gt;<br />    &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt;<br />        &lt;property name="dataSource" ref="dataSource"/&gt;<br />        &lt;!-- 自动扫描mapping.xml文件 --&gt;<br />        &lt;property name="mapperLocations" value="classpath:com/founderit/mapper/*.xml"&gt;&lt;/property&gt;<br />    &lt;/bean&gt;<br /><br />    &lt;!-- DAO接口所在包名，Spring会自动查找其下的类 --&gt;<br />    &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt;<br />        &lt;property name="basePackage" value="com.founderit.dao"/&gt;<br />        &lt;property name="sqlSessionFactoryBeanName" value="sqlSessionFactory"&gt;&lt;/property&gt;<br />    &lt;/bean&gt;<br /><br /><br /><br /><br />    &lt;!--事务管理部分--&gt;<br />    &lt;bean id="transactionManager"<br />          class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt;<br />        &lt;property name="dataSource" ref="dataSource" /&gt;<br />    &lt;/bean&gt;<br />    &lt;tx:annotation-driven transaction-manager="transactionManager" proxy-target-class="true" /&gt;<br /><br /><br />    &lt;tx:advice id="txAdvice" transaction-manager="transactionManager"&gt;<br />        &lt;tx:attributes&gt;<br />            &lt;tx:method name="save*" propagation="REQUIRED" /&gt;<br />            &lt;tx:method name="insert*" propagation="REQUIRED" /&gt;<br />            &lt;tx:method name="add*" propagation="REQUIRED" /&gt;<br />            &lt;tx:method name="create*" propagation="REQUIRED" /&gt;<br />            &lt;tx:method name="delete*" propagation="REQUIRED" /&gt;<br />            &lt;tx:method name="update*" propagation="REQUIRED" /&gt;<br />            &lt;tx:method name="find*" propagation="SUPPORTS" read-only="true" /&gt;<br />            &lt;tx:method name="select*" propagation="SUPPORTS" read-only="true" /&gt;<br />            &lt;tx:method name="get*" propagation="SUPPORTS" read-only="true" /&gt;<br />        &lt;/tx:attributes&gt;<br />    &lt;/tx:advice&gt;<br /><br />    &lt;aop:config&gt;<br />        &lt;aop:pointcut id="iccardTerm" expression="execution(* com.founderit.service.*.*(..))" /&gt;<br />        &lt;aop:advisor pointcut-ref="iccardTerm" advice-ref="txAdvice" /&gt;<br />    &lt;/aop:config&gt;<br /><br />&lt;/beans&gt;</code></pre>
<p>service层</p>
<pre><code>@Override</code></pre>
<pre><code>public int insertObject(Object obj) {<br />    int result=0;<br />        for (int i=0;i&lt;4;i++) {<br />            Student student=new Student();<br />            student.setName("wll");<br />            student.setAge(1);<br />            student.setId(100+i);<br />            result=userDao.insertObject(student);<br />        }<br />    return result;<br />}</code></pre>
<p>测试</p>
<p>&nbsp;项目中将插入四条记录，我们在插入第三条时手动报错，如果没有事务，前二条正常的记录将插入成功，运行tomcat,发起hello请求</p>
<pre><code>@Override</code></pre>
<pre><code>public int insertObject(Object obj) {<br />    int result=0;<br />        for (int i=0;i&lt;4;i++) {<br />            Student student=new Student();<br />            student.setName("wll");<br />            student.setAge(1);<br />            student.setId(100+i);<br />            if (i==2){<br />                int error=10/0;<br />            }<br />            result=userDao.insertObject(student);<br />        }<br />    return result;<br />}<br /><br /></code></pre>
<p><img src="./images/SSM整合学习 四2.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;<img src="./images/SSM整合学习 四3.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>需要注意的是spring aop被拦截的方法需显式抛出异常，并不能经任何处理，这样aop代理才能捕获到方法的异常，才能进行回滚，默认情况下aop只捕获runtimeException的异常</p>
<p>如service层做了异常处理，事务不会回滚，我们将service层做了try/catch处理，再次测试发现事务并没有回滚而是正常提交了</p>
<p><img src="./images/SSM整合学习 四4.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;<img src="./images/SSM整合学习 四5.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;解决方案：</p>
<p>service层处理事务，那么service中的方法中不做异常捕获（推荐），或者在catch语句中最后增加throw new RuntimeException()语句，以便让aop捕获异常再去回滚，并且在service上层（controller）要继续捕获这个异常并处理</p>
<p>&nbsp;</p>

</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>