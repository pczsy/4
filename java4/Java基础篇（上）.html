<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修Java基础篇（上）' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>Java基础篇（上）</center></div><div class='banquan'>原文出处:本文由博客园博主尴尬的我提供。<br/>
原文连接:https://www.cnblogs.com/sudoit/p/12016884.html</div><br>
    <h2>1、<strong>简介</strong></h2>
<p>Java是由Sun Microsystems公司于1995年5月推出的Java面向对象程序设计语言和Java&nbsp;平台的总称。由James Gosling和同事们共同研发，并在1995年正式推出。</p>
<p>Java分为三个体系：</p>
<p>　　JavaSE（J2SE）（Java2 Platform Standard Edition，java平台标准版）</p>
<p>　　JavaEE(J2EE)(Java 2 Platform,Enterprise Edition，java平台企业版)</p>
<p>　　JavaME(J2ME)(Java 2 Platform Micro Edition，java平台微型版)。</p>
<h1>2、<strong>特性</strong></h1>
<p>Java语言是简单的，面向对象的，分布式的，健壮的，安全的，体系结构中立的，可移 植的，解释型的，高性能的，多线程的，动态的。&nbsp;</p>
<h1>3、<strong>Java&nbsp;基础语法（修饰符）</strong></h1>
<p>一个&nbsp;Java&nbsp;程序可以认为是一系列对象的集合，而这些对象通过调用彼此的方法来协同 工作。下面简要介绍下类、对象、方法和实例变量的概念。</p>
<ol>
<li>对象：对象是类的一个实例，有状态和行为。例如，一条狗是一个对象，它的 状态 有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。</li>
<li>类：类是一个模板，它描述一类对象的行为和状态。</li>
<li>方法：方法就是行为，一个类可以有很多方法。逻辑运算、数据修改以及所有动作都是 在方法中完成的。</li>
<li>实例变量：每个对象都有独特的实例变量，对象的状态由这些实例变量的值决定。
<p>Java&nbsp;变量：Java&nbsp;中主要有如下几种类型的变量</p>
<p>　　　　　　(1)、局部变量</p>
<p>　　　　　　(2)、类变量（静态变量）</p>
<p>　　　　　　(3)、成员变量（非静态变量）</p>
</li>
<li>Java修饰符：</li>
</ol>
<p>像其他语言一样，Java可以使用修饰符来修饰类中方法和属性。主要有两类修饰符：</p>
<p>访问控制修饰符&nbsp;: default, public , protected, private</p>
<p>非访问控制修饰符&nbsp;: final, abstract, static, synchronized</p>
<p>&nbsp;</p>
<p>修饰符用来定义类、方法或者变量，通常放在语句的最前端。我们通过下面的例子来说明：</p>
<src class="cnblogs_code">
<pre><code> 1 public class<span> ClassName {
 2 
 3    // ...
 4 
 5     private boolean<span> myFlag;
 6 
 7     static final double weeks = 9.5<span>;
 8 
 9     protected static final int BOXWIDTH = 42<span>;
10 
11     public static void<span> main(String[] arguments) {
12     
13        // 方法体
14 
15 <span>    }
16 <span>}
17 
18  </span></span></span></span></span></span></span></code></pre>

<p>&nbsp;</p>
<p>　　6. 访问控制修饰符</p>
<p>Java中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。Java&nbsp;支持&nbsp;4&nbsp;种不同的访问权限。</p>
<p>default (即默认，什么也不写）:&nbsp;在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。</p>
<p>private :&nbsp;在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类）</p>
<p>public :&nbsp;对所有类可见。使用对象：类、接口、变量、方法</p>
<p>protected :&nbsp;对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类）。</p>
<p>我们可以通过以下表来说明访问权限：</p>
<table border="0" cellspacing="0">
<tbody>
<tr>
<td colspan="6" valign="center" width="833">
<p align="center"><strong>访问控制</strong></p>
</td>
</tr>
<tr>
<td valign="top" width="140">
<p><strong>修饰符</strong></p>
</td>
<td valign="top" width="93">
<p><strong>当前类</strong></p>
</td>
<td valign="top" width="120">
<p><strong>同一包内</strong></p>
</td>
<td valign="top" width="192">
<p><strong>子孙类(同一包)</strong></p>
</td>
<td valign="top" width="192">
<p><strong>子孙类(不同包)</strong></p>
</td>
<td valign="top" width="94">
<p><strong>其他包</strong></p>
</td>
</tr>
<tr>
<td valign="top" width="140">
<p>public</p>
</td>
<td valign="top" width="93">
<p>Y</p>
</td>
<td valign="top" width="120">
<p>Y</p>
</td>
<td valign="top" width="192">
<p>Y</p>
</td>
<td valign="top" width="192">
<p>Y</p>
</td>
<td valign="top" width="94">
<p>Y</p>
</td>
</tr>
<tr>
<td valign="top" width="140">
<p>protected</p>
</td>
<td valign="top" width="93">
<p>Y</p>
</td>
<td valign="top" width="120">
<p>Y</p>
</td>
<td valign="top" width="192">
<p>Y</p>
</td>
<td valign="top" width="192">
<p>Y/N</p>
</td>
<td valign="top" width="94">
<p>N</p>
</td>
</tr>
<tr>
<td valign="top" width="140">
<p>default</p>
</td>
<td valign="top" width="93">
<p>Y</p>
</td>
<td valign="top" width="120">
<p>Y</p>
</td>
<td valign="top" width="192">
<p>Y</p>
</td>
<td valign="top" width="192">
<p>N</p>
</td>
<td valign="top" width="94">
<p>N</p>
</td>
</tr>
<tr>
<td valign="top" width="140">
<p>private</p>
</td>
<td valign="top" width="93">
<p>Y</p>
</td>
<td valign="top" width="120">
<p>N</p>
</td>
<td valign="top" width="192">
<p>N</p>
</td>
<td valign="top" width="192">
<p>N</p>
</td>
<td valign="top" width="94">
<p>N</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>默认访问修饰符-不使用任何关键字</p>
<p>使用默认访问修饰符声明的变量和方法，对同一个包内的类是可见的。接口里的变量都隐式声明为&nbsp;public static final,而接口里的方法默认情况下访问权限为&nbsp;public。</p>
<p>私有访问修饰符-private</p>
<p>私有访问修饰符是最严格的访问级别，所以被声明为&nbsp;private&nbsp;的方法、变量和构造方法只能被所属类访问，并且类和接口不能声明为&nbsp;private。</p>
<p>声明为私有访问类型的变量只能通过类中公共的&nbsp;getter&nbsp;方法被外部类访问。</p>
<p>Private&nbsp;访问修饰符的使用主要用来隐藏类的实现细节和保护类的数据。</p>
<p>下面的类使用了私有访问修饰符：</p>
<src class="cnblogs_code">
<pre><code> 1 public class<span> Logger {
 2 
 3    private<span> String format;
 4 
 5    public<span> String getFormat() {
 6 
 7       return this<span>.format;
 8 
 9 <span>   }
10 
11    public void<span> setFormat(String format) {
12 
13       this.format =<span> format;
14 
15 <span>   }
16 
17 }</span></span></span></span></span></span></span></span></code></pre>

<p>实例中，Logger&nbsp;类中的&nbsp;format&nbsp;变量为私有变量，所以其他类不能直接得到和设置该变量的值。为了使其他类能够操作该变量，定义了两个&nbsp;public&nbsp;方法：getFormat()&nbsp;（返回&nbsp;format的值）和&nbsp;setFormat(String)（设置&nbsp;format&nbsp;的值）</p>
<p>&nbsp;</p>
<p>公有访问修饰符-public</p>
<p>被声明为&nbsp;public&nbsp;的类、方法、构造方法和接口能够被任何其他类访问。</p>
<p>如果几个相互访问的&nbsp;public&nbsp;类分布在不同的包中，则需要导入相应&nbsp;public&nbsp;类所在的包。由于类的继承性，类所有的公有方法和变量都能被其子类继承。</p>
<p>受保护的访问修饰符-protected</p>
<p>protected&nbsp;需要从以下两个点来分析说明：</p>
<p>子类与基类在同一包中：被声明为&nbsp;protected&nbsp;的变量、方法和构造器能被同一个包中的任何其他类访问；</p>
<p>子类与基类不在同一包中：那么在子类中，子类实例可以访问其从基类继承而来的&nbsp;protected&nbsp;方法，而不能访问基类实例的protected方法。</p>
<p>protected&nbsp;可以修饰数据成员，构造方法，方法成员，不能修饰类（内部类除外）。</p>
<p>接口及接口的成员变量和成员方法不能声明为&nbsp;protected。</p>
<p>子类能访问&nbsp;protected&nbsp;修饰符声明的方法和变量，这样就能保护不相关的类使用这些方法和变量。</p>
<p>下面的父类使用了&nbsp;protected&nbsp;访问修饰符，子类重写了父类的&nbsp;openSpeaker()&nbsp;方法。</p>
<src class="cnblogs_code">
<pre><code> 1 class<span> AudioPlayer {
 2 
 3    protected boolean<span> openSpeaker(Speaker sp) {
 4 
 5       // 实现细节
 6 
 7 <span>   }
 8 
 9 <span>}
10 
11 class StreamingAudioPlayer extends<span> AudioPlayer {
12 
13    protected boolean<span> openSpeaker(Speaker sp) {
14 
15       // 实现细节
16 
17 <span>   }
18 
19 }</span></span></span></span></span></span></span></code></pre>

<p>&nbsp;</p>
<p>如果把&nbsp;openSpeaker()&nbsp;方法声明为&nbsp;private，那么除了&nbsp;AudioPlayer&nbsp;之外的类将不能访问该方法。</p>
<p>如果把&nbsp;openSpeaker()&nbsp;声明为&nbsp;public，那么所有的类都能够访问该方法。</p>
<p>如果我们只想让该方法对其所在类的子类可见，则将该方法声明为&nbsp;protected。</p>
<p>protected&nbsp;是最难理解的一种&nbsp;Java&nbsp;类成员访问权限修饰词，更多详细内容请查看&nbsp;Java protected&nbsp;关键字详解。</p>
<p>&nbsp;</p>
<p>7.访问控制和继承</p>
<p>请注意以下方法继承的规则：</p>
<p>父类中声明为&nbsp;public&nbsp;的方法在子类中也必须为&nbsp;public。</p>
<p>父类中声明为&nbsp;protected&nbsp;的方法在子类中要么声明为&nbsp;protected，要么声明为&nbsp;public，不能声明为&nbsp;private。</p>
<p>父类中声明为&nbsp;private&nbsp;的方法，不能够被继承。</p>
<p>&nbsp;</p>
<p>8.非访问修饰符</p>
<p>为了实现一些其他的功能，Java&nbsp;也提供了许多非访问修饰符。</p>
<p>static&nbsp;修饰符，用来修饰类方法和类变量。</p>
<p>final&nbsp;修饰符，用来修饰类、方法和变量，final&nbsp;修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。</p>
<p>abstract&nbsp;修饰符，用来创建抽象类和抽象方法。</p>
<p>synchronized&nbsp;和&nbsp;volatile&nbsp;修饰符，主要用于线程的编程。</p>
<p>&nbsp;</p>
<ul>
<li>static&nbsp;修饰符</li>
</ul>
<p>静态变量：</p>
<p>　　static&nbsp;关键字用来声明独立于对象的静态变量，无论一个类实例化多少对象，它的静态变量只有一份拷贝。 静态变量也被称为类变量。局部变量不能被声明为&nbsp;static&nbsp;变量。</p>
<p>静态方法：</p>
<p>　　static&nbsp;关键字用来声明独立于对象的静态方法。静态方法不能使用类的非静态变量。静态方法从参数列表得到数据，然后计算这些数据。</p>
<p>　　对类变量和方法的访问可以直接使用&nbsp;classname.variablename&nbsp;和&nbsp;classname.methodname&nbsp;的方式访问。</p>
<p>　　如下例所示，static修饰符用来创建类方法和类变量。</p>
<src class="cnblogs_code">
<pre><code> 1 public class<span> InstanceCounter {
 2 
 3    private static int numInstances = 0<span>;
 4 
 5    protected static int<span> getCount() {
 6 
 7       return<span> numInstances;
 8 
 9 <span>   }
10 
11    private static void<span> addInstance() {
12 
13       numInstances++<span>;
14 
15 <span>   }
16 
17 <span>   InstanceCounter() {
18 
19 <span>      InstanceCounter.addInstance();
20 
21 <span>   }
22 
23    public static void<span> main(String[] arguments) {
24 
25       System.out.println("Starting with " +
26 
27       InstanceCounter.getCount() + " instances"<span>);
28 
29       for (int i = 0; i &lt; 500; ++<span>i){
30 
31          new<span> InstanceCounter();
32 
33 <span>          }
34 
35       System.out.println("Created " +
36 
37       InstanceCounter.getCount() + " instances"<span>);
38 
39 <span>   }
40 
41 }</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>

<p>以上实例运行编辑结果如下:</p>
<p>Starting with 0 instances</p>
<p>Created 500 instances</p>
<p>&nbsp;</p>
<ul>
<li>final&nbsp;修饰符</li>
</ul>
<p>final&nbsp;变量：</p>
<p>　　final&nbsp;表示"最后的、最终的"含义，变量一旦赋值后，不能被重新赋值。被&nbsp;final&nbsp;修饰的实例变量必须显式指定初始值。</p>
<p>　　final&nbsp;修饰符通常和&nbsp;static&nbsp;修饰符一起使用来创建类常量。</p>
<p>实例</p>
<src class="cnblogs_code">
<pre><code>public class<span> Test{

  final int value = 10<span>;

  // 下面是声明常量的实例

  public static final int BOXWIDTH = 6<span>;

  static final String TITLE = "Manager"<span>;

  public void<span> changeValue(){

     value = 12; //将输出一个错误
<span>
  }

}</span></span></span></span></span></span></code></pre>

<p>&nbsp;</p>
<p>final&nbsp;方法</p>
<p>　　父类中的&nbsp;final&nbsp;方法可以被子类继承，但是不能被子类重写。</p>
<p>　　声明&nbsp;final&nbsp;方法的主要目的是防止该方法的内容被修改。</p>
<p>如下所示，使用&nbsp;final&nbsp;修饰符声明方法。</p>
<src class="cnblogs_code">
<pre><code>public class<span> Test{

    public final void<span> changeName(){

       // 方法体
<span>
    }

}</span></span></span></code></pre>

<p>final&nbsp;类</p>
<p>　　final&nbsp;类不能被继承，没有类能够继承&nbsp;final&nbsp;类的任何特性。</p>
<p>实例</p>
<src class="cnblogs_code">
<pre><code>1 public final class<span> Test {
2 
3    // 类体
4 
5 }</span></code></pre>

<ul>
<li>abstract&nbsp;修饰符</li>
</ul>
<p>抽象类：</p>
<p>　　抽象类不能用来实例化对象，声明抽象类的唯一目的是为了将来对该类进行扩充。</p>
<p>　　一个类不能同时被&nbsp;abstract&nbsp;和&nbsp;final&nbsp;修饰。如果一个类包含抽象方法，那么该类一定要声明为抽象类，否则将出现编译错误。</p>
<p>　　抽象类可以包含抽象方法和非抽象方法。</p>
<p>实例</p>
<src class="cnblogs_code">
<pre><code> 1 abstract class<span> Caravan{
 2 
 3    private double<span> price;
 4 
 5    private<span> String model;
 6 
 7    private<span> String year;
 8 
 9    public abstract void goFast(); //抽象方法
10 
11    public abstract void<span> changeColor();
12 
13 }</span></span></span></span></span></code></pre>

<p>抽象方法</p>
<p>抽象方法是一种没有任何实现的方法，该方法的的具体实现由子类提供。</p>
<p>抽象方法不能被声明成&nbsp;final&nbsp;和&nbsp;static。</p>
<p>任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类。</p>
<p>如果一个类包含若干个抽象方法，那么该类必须声明为抽象类。抽象类可以不包含抽象方法。</p>
<p>抽象方法的声明以分号结尾，例如：public abstract sample();。</p>
<p>实例</p>
<src class="cnblogs_code">
<pre><code> 1 public abstract class<span> SuperClass{
 2 
 3     abstract void m(); //抽象方法
 4 
 5 <span>}
 6 
 7 class SubClass extends<span> SuperClass{
 8 
 9      //实现抽象方法
10 
11       void<span> m(){
12 
13 <span>          .........
14 
15 <span>      }
16 
17 }</span></span></span></span></span></span></code></pre>

<ul>
<li>synchronized&nbsp;修饰符</li>
</ul>
<p>synchronized&nbsp;关键字声明的方法同一时间只能被一个线程访问。synchronized&nbsp;修饰符可以应用于四个访问修饰符。</p>
<p>实例</p>
<src class="cnblogs_code">
<pre><code>1 public synchronized void<span> showDetails(){
2 
3 <span>.......
4 
5 <span>}
6  </span></span></span></code></pre>

<p>&nbsp;</p>
<ul>
<li>transient&nbsp;修饰符</li>
</ul>
<p>序列化的对象包含被&nbsp;transient&nbsp;修饰的实例变量时，java&nbsp;虚拟机(JVM)跳过该特定的变量。</p>
<p>该修饰符包含在定义变量的语句中，用来预处理类和变量的数据类型。</p>
<p>实例</p>
<src class="cnblogs_code">
<pre><code>1 public transient int limit = 55;   // 不会持久化
2 
3 public int b; // 持久化</code></pre>

<ul>
<li>volatile&nbsp;修饰符</li>
</ul>
<p>volatile&nbsp;修饰的成员变量在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值。而且，当成员变量发生变化时，会强制线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。</p>
<p>一个&nbsp;volatile&nbsp;对象引用可能是&nbsp;null。</p>
<p>实例</p>
<src class="cnblogs_code">
<pre><code> 1 public class MyRunnable implements<span> Runnable
 2 
 3 <span>{
 4 
 5     private volatile boolean<span> active;
 6 
 7     public void<span> run()
 8 
 9 <span>    {
10 
11         active = true<span>;
12 
13         while (active) // 第一行
14 
15 <span>        {
16 
17             // 代码
18 
19 <span>        }
20 
21 <span>    }
22 
23     public void<span> stop()
24 
25 <span>    {
26 
27         active = false; // 第二行
28 
29 <span>    }
30 
31 }</span></span></span></span></span></span></span></span></span></span></span></span></code></pre>

<p>&nbsp;</p>
<p>通常情况下，在一个线程调用&nbsp;run()&nbsp;方法（在&nbsp;Runnable&nbsp;开启的线程），在另一个线程调用&nbsp;stop()&nbsp;方法。 如果 第一行 中缓冲区的&nbsp;active&nbsp;值被使用，那么在 第二行 的&nbsp;active&nbsp;值为&nbsp;false&nbsp;时循环不会停止</p>
<p>但是以上代码中我们使用了&nbsp;volatile&nbsp;修饰&nbsp;active，所以该循环会停止。</p>
<p>&nbsp;</p>

</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>