<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修Java面试题_第三阶段(Spring、MVC、IOC、AOP、DI、MyBatis、SSM、struts2)' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>Java面试题_第三阶段(Spring、MVC、IOC、AOP、DI、MyBatis、SSM、struts2)</center></div><div class='banquan'>原文出处:本文由博客园博主佩奇er提供。<br/>
原文连接:https://www.cnblogs.com/hxun/p/11763345.html</div><br>
    <h2><span style="background-color: #99ccff;">1.1&nbsp;何为Spring Bean容器?Spring Bean容器与Spring IOC 容器有什么不同吗?</span></h2>
<p>答：1）用于创建bean<span style="font-family: 宋体;">对象</span>,管理bean对象的那个容器。</p>
<p>2）Spring IOC 容器本质上指的<span style="font-family: 宋体;">的就是</span>Spring Bean容器,Spring Bean容器<span style="font-family: 宋体;">中最核心一个机制是</span>IOC机制(<span style="color: #ff0000;">控制<span style="font-family: 宋体;">反转</span></span>),</p>
<p>所以有时候又将springbean容器称之为Spring IOC 容器.</p>
<h2><span style="background-color: #99ccff;">1.2&nbsp;<strong>Spring</strong><strong>&nbsp;IOC </strong><strong>如何</strong><strong><span style="font-family: 宋体;">理解</span>?</strong></span></h2>
<p>答：IOC 是Spring中提供一种控制反转机制,目的是将我们项目中对象的依赖管理交给Spring实现,</p>
<p>这样可以更好<span style="color: #ff0000;">实现对象关系的<span style="font-family: 宋体;">解耦</span>,提高程序的可扩展性.</span></p>
<h2><span style="background-color: #99ccff;">1.3&nbsp;<strong>Spring DI <span style="font-family: 宋体;">如何</span></strong><strong><span style="font-family: 宋体;">理解</span>?</strong></span></h2>
<p>答：DI 是Spring中的依赖注入机制,IOC的实现需要借助这种机制.我们通常<span style="font-family: 宋体;">会这样理解</span>,</p>
<p>Spring Bean容器中的IOC思想<span style="font-family: 宋体;">一种目标</span>,DI是实现这种思想<span style="font-family: 宋体;">的目标的手段</span>.</p>
<h2><span style="background-color: #99ccff;">1.4&nbsp;<strong>Spring</strong><strong>&nbsp;<span style="font-family: 宋体;">中</span></strong><strong>基于</strong><strong><span style="font-family: 宋体;">注解如何配置对象作用域</span>?</strong><strong>以及</strong><strong><span style="font-family: 宋体;">如何配置延迟加载机制</span>?</strong></span></h2>
<p>答：@Scope(&ldquo;singleton&rdquo;)</p>
<p>@Scope(&ldquo;prototype&rdquo;)</p>
<p>@Lazy(value=true)</p>
<h2><span style="background-color: #99ccff;">1.5&nbsp;<strong>Spring <span style="font-family: 宋体;">工厂底层构建</span><span style="font-family: 'Calibri Light';">Bean</span><span style="font-family: 宋体;">对象借助什么机制</span><span style="font-family: 'Calibri Light';">?</span><span style="font-family: 宋体;">当对象不使用了要释放资源,目的是什么</span><span style="font-family: 'Calibri Light';">?</span><span style="font-family: 宋体;">何为内存泄漏</span><span style="font-family: 'Calibri Light';">?</span></strong></span></h2>
<p>答：借助反射机制，防止内存泄漏，对象已经不使用了但占用着内存,这种现 <span style="font-family: 宋体;">象称之为内存泄漏</span>,内存泄漏不<span style="font-family: 宋体;">是内存溢出</span>,但是它是内存溢出的一个导火索. 内存溢出直接就导致系统崩溃了.</p>
<h2><span style="background-color: #99ccff;">1.6&nbsp;<strong><span style="font-family: 宋体;">描述</span>Spring MVC<span style="font-family: 宋体;">处理流程及应用优势</span></strong></span></h2>
<p>答：</p>
<p>1、<span style="color: #ff0000;">客户端</span>发出一个http请求给web<span style="color: #ff0000;">服务器</span>，web服务器对http请求进 行 <span style="font-family: 宋体;"><span style="color: #ff0000;">解析</span>，如果匹配前端控制器</span>(或分发器/DispatcherServlet)的请求映射路径， web容器将请求转交给<span style="color: #ff0000;">DispatcherServlet</span>.</p>
<p>2、DipatcherServlet接收到这个请求之后将根据请求的信息以及处理器映射 <span style="font-family: 宋体;">器</span>(<span style="color: #ff0000;">HandlerMapping</span>)的配置找到处理请求的处理器（<span style="color: #ff0000;">Handler</span>）。</p>
<p>3、由具体的处理器适配器（<span style="color: #ff0000;">HandlerAdapter</span>）对<span style="color: #ff0000;">Handler</span>进行具体的调用。</p>
<p>4、Handler对数据处理完成以后将返回一个<span style="color: #ff0000;">ModelAndView()对象</span>给 <span style="color: #ff0000;">DispatcherServlet</span>。</p>
<p>5、DispatcherSevlet通过<span style="color: #ff0000;">视图解析器（ViewResolver）</span>将ModelAndView()转 <span style="font-family: 宋体;">化为真正的视图</span>View。</p>
<p>6、Dispatcher通过model<span style="color: #ff0000;">解析</span>出ModelAndView()中的参数进行<span style="color: #ff0000;">解析</span>最终展 <span style="font-family: 宋体;">现出完整的</span>view并返回给<span style="color: #ff0000;">客户端</span>。</p>
<p>&nbsp;</p>
<h2><span style="background-color: #99ccff;">1.7&nbsp;<strong>Spring<span style="font-family: 宋体;">中的事务处理方式及优缺点</span></strong></span></h2>
<p><span style="font-family: 宋体;">答：优点在于：</span></p>
<p>1：能够实现<span style="color: #ff00ff;">全局事务的控制</span>，通过EJB CMT进行事物的管理。</p>
<p>2：能够保证项目模块在系统中完成的功能是可<span style="color: #ff00ff;">可控制的的操作（AOP）</span></p>
<p>缺点在于：</p>
<p>1：Spring中的事物声明有<span style="color: #ff0000;">编程式事物</span>和<span style="color: #ff0000;">申明是事物</span></p>
<h2><span style="background-color: #99ccff;">1.8&nbsp;<strong>MyBatis<span style="font-family: 宋体;">应用中</span><span style="font-family: 'Calibri Light';">#</span><span style="font-family: 宋体;">与</span><span style="font-family: 'Calibri Light';">$</span><span style="font-family: 宋体;">有什么异同点</span></strong></span></h2>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-family: 宋体;">相同点：都是通过</span><span style="color: #ff0000;">get</span>来获取值的</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-family: 宋体;">不同点：</span><span style="color: #ff0000;">$传进去的字符串不带引号 #号带引号</span></p>
<h2><span style="background-color: #99ccff;">1.9&nbsp;<strong>MyBatis<span style="font-family: 宋体;">应用动态</span><span style="font-family: 'Calibri Light';">SQL</span><span style="font-family: 宋体;">解决了什么问题</span></strong></span></h2>
<p><span style="font-family: 宋体;">答：有时候，固定的</span>sql语句不能够满足我们的应用需求。这个时候需要在 标准的基础上建立动态的查询语句。</p>
<p>Mybatis提供了<span style="color: #ff0000;">多种注解</span>，可以提供<span style="color: #ff0000;">动态查询语言</span>。</p>
<p>比如说在开发的时候，遇到这样的场景，界面提供了多种查询，但是都是非 必填写，在选择查询条件时可以选中任意几种组合作为查询条件，如果在使 <span style="font-family: 宋体;">用</span>jdbc的时候，需要判断参数为空，自己组装sql，</p>
<p><span style="font-family: 宋体;">但是</span>mybatis提供动态sql机制，依靠标签。</p>
<h2><span style="background-color: #ffff99;">1.10&nbsp;<strong>Shiro<span style="font-family: 宋体;">框架权限管理时的认证和授权流程描述</span></strong><strong>.</strong></span></h2>
<p><span style="font-family: 宋体;">答：</span>Shiro权限控制流程的原理：</p>
<p><span style="font-family: 宋体;">应用代码</span> &mdash;- 调用Subject （shiro的Subject 就代表当前登陆用户） 控制权限 &mdash;- Subject 在shiro框架内部 调用 Shiro SecurityManager 安全管理器 &mdash;&ndash; 安全管理器调用 Realm （程序和安全数据连接器 ）。</p>
<p>Subject要进行任何操作，都必须要调用安全管理器（对我们来说是自动的）。&nbsp;<br /><span style="font-family: 宋体;">而安全管理器会调用指定的</span>Realms对象，来连接安全数据。</p>
<p>Realms用来编写安全代码逻辑和访问安全数据，是连接程序和安全数据的桥梁。</p>
<h2><span style="background-color: #ffff99;">1.11&nbsp;<strong>BeanFactory<span style="font-family: 宋体;">和</span><span style="font-family: 'Calibri Light';">ApplicationContext</span><span style="font-family: 宋体;">有什么区别？</span></strong></span></h2>
<p class="p">BeanFactory 可以理解为含有<span style="color: #ff0000;">bean集合的工厂类</span>。BeanFactory 包含了种bean的定义，以便在<span style="color: #ff0000;">接收</span>到客户端<span style="color: #ff0000;">请求</span>时将对应的<span style="color: #ff0000;">bean实例化</span>。</p>
<p class="p">BeanFactory还能在<span style="color: #ff0000;">实例化对象</span>时<span style="color: #ff0000;">生成协作类之间的关系</span>。此举将<span style="color: #ff0000;">bean自身</span>与<span style="color: #ff0000;">bean客户端</span>的配置中解放出来。BeanFactory还包含了<span style="color: #ff0000;">bean生命周期的控制</span>，调用客户端的初始化方法（<span style="color: #ff0000;">initialization methods</span>）和销毁方法（<span style="color: #ff0000;">destruction methods</span>）。</p>
<p class="p"><span style="font-family: 宋体;">从表面上看，</span>application context如同bean factory一样具有<span style="color: #ff0000;">bean定义</span>、<span style="color: #ff0000;">bean关联关系的设置</span>，根据<span style="color: #ff0000;">请求分发bean</span>的功能。但application context在此基础上<span style="color: #ff0000;">还提供了其他的功能</span>。</p>
<h2><span style="background-color: #ffff99;">1.12&nbsp;<strong><span style="font-family: 宋体;">请解释</span>Spring Bean<span style="font-family: 宋体;">的生命周期？</span></strong></span></h2>
<p>Spring Bean的生命周期简单易懂。在一个bean实例被初始化时，需要执行一系列的初始化操作以达到可用的状态。同样，当一个bean不在被调用时需要进行相关的析构操作，并从bean容器中移除。</p>
<p>Spring bean factory 负责管理在spring容器中被创建的bean的生命周期。Bean的生命周期由两组回调（call back）方法组成。</p>
<p>初始化之后调用的回调方法。<br />销毁之前调用的回调方法。<br />Spring框架提供了以下四种方式来管理bean的生命周期事件：</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1）<span style="color: #ff0000;">InitializingBean</span>和<span style="color: #ff0000;">DisposableBean</span>回调接口<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2）针对特殊行为的其他<span style="color: #ff0000;">Aware</span>接口<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3）Bean配置文件中的<span style="color: #ff0000;">Custom init()</span>方法和<span style="color: #ff0000;">destroy()</span>方法<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4）@PostConstruct和@PreDestroy注解方式<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 使用customInit()和 customDestroy()方法<span style="color: #ff0000;">管理bean生命周期的代码</span>样例如下：</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">beans</span><span style="color: #0000ff;">&gt;</span>
    <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">bean </span><span style="color: #ff0000;">id</span><span style="color: #0000ff;">="demoBean"</span><span style="color: #ff0000;"> class</span><span style="color: #0000ff;">="com.howtodoinjava.task.DemoBean"</span><span style="color: #ff0000;">
            init-method</span><span style="color: #0000ff;">="customInit"</span><span style="color: #ff0000;"> destroy-method</span><span style="color: #0000ff;">="customDestroy"</span><span style="color: #0000ff;">&gt;&lt;/</span><span style="color: #800000;">bean</span><span style="color: #0000ff;">&gt;</span>
<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">beans</span><span style="color: #0000ff;">&gt;</span></code></pre>

<h2><span style="background-color: #ffff99;">&nbsp;1.13&nbsp;<strong>Spring Bean<span style="font-family: 宋体;">的作用域之间有什么区别？</span></strong></span></h2>
<p class="p">Spring容器中的bean可以分为5个范围。所有范围的名称都是自说明的，但是为了避免混淆，还是让我们来解释一下：</p>
<p class="p">1）<span style="color: #ff0000;">singleton</span>：这种bean范围是默认的，这种范围确保不管接受到多少个请求，每个容器中只有一个bean的实例，单例的模式由bean factory自身来维护。<br />2）<span style="color: #ff00ff;">prototype</span>：原形范围与单例范围相反，为每一个bean请求提供一个实例。<br />3）<span style="color: #ff9900;">request</span>：在请求bean范围内会每一个来自客户端的网络请求创建一个实例，在请求完成以后，bean会失效并被垃圾回收器回收。<br />4）<span style="color: #00ccff;">Session</span>：与请求范围类似，确保每个session中有一个bean的实例，在session过期后，bean会随之失效。<br />5）<span style="color: #800080;">global-session</span>：global-session和Portlet应用相关。当你的应用部署在Portlet容器中工作时，它包含很多portlet。如果你想要声明让所有的portlet共用全局的存储变量的话，那么这全局变量需要存储在global-session中。<br /><span style="font-family: 宋体;">全局作用域与</span>Servlet中的session作用域效果相同。</p>
<h2><span style="background-color: #ffff99;">1.14&nbsp;<strong><span style="font-family: 宋体;">在</span>Spring&nbsp;AOP&nbsp;<span style="font-family: 宋体;">中，关注点和横切关注的区别是什么？</span></strong></span></h2>
<p class="p">关注点是应用中一个模块的行为，一个关注点可能会被定义成一个我们想实现的一个功能。<br />横切关注点是一个关注点，此关注点是整个应用都会使用的功能，并影响整个应用，比如日志，安全和数据传输，几乎应用的每个模块都需要的功能。因此这些都属于横切关注点。</p>
<h2><span style="background-color: #ffff99;">1.15&nbsp;<strong><span style="font-family: 宋体;">使用</span>Spring<span style="font-family: 宋体;">框架的好处是什么？</span></strong></span></h2>
<ul>
<li><span style="font-family: 宋体;"><span style="color: #ff0000;">轻量</span>：</span>Spring&nbsp;是轻量的，基本的版本大约2MB。</li>
<li><span style="font-family: 宋体;"><span style="color: #ff0000;">控制反转</span>：</span>Spring通过控制反转实现了松散耦合，对象们给出它们的依赖，而不是创建或查找依赖的对象们。</li>
<li><span style="color: #ff0000;"><span style="font-family: 宋体;">面向切面的编程</span>(AOP)</span>：Spring支持面向切面的编程，并且把应用业务逻辑和系统服务分开。</li>
<li><span style="font-family: 宋体;"><span style="color: #ff0000;">容器</span>：</span>Spring&nbsp;包含并管理应用中对象的生命周期和配置。</li>
<li><span style="color: #ff0000;">MVC框架</span>：Spring的WEB框架是个精心设计的框架，是Web框架的一个很好的替代品。</li>
<li><span style="font-family: 宋体;"><span style="color: #ff9900;">事务管理</span>：</span>Spring&nbsp;提供一个持续的事务管理接口，可以扩展到上至本地事务下至全局事务（JTA）。</li>
<li><span style="font-family: 宋体;"><span style="color: #ff0000;">异常处理</span>：</span>Spring&nbsp;提供方便的API把具体技术相关的异常（比如由JDBC，Hibernate&nbsp;or&nbsp;JDO抛出的）转化为一致的unchecked&nbsp;异常。</li>




</ul>
<h2><span style="background-color: #ffff99;">1.16&nbsp;<strong>Spring <span style="font-family: 宋体;">中用到了那些设计模式？</span></strong></span></h2>
<p>Spring框架中使用到了大量的设计模式，下面列举了比较有代表性的：</p>
<ul>
<li><span style="color: #ff0000;">代理模式</span>&mdash;在AOP和remoting中被用的比较多。</li>
<li><span style="color: #ff0000;">单例模式</span>&mdash;在spring配置文件中定义的bean默认为单例模式。</li>
<li>模板方法&mdash;用来解决代码重复的问题。比如. RestTemplate, JmsTemplate, JpaTemplate。</li>
<li><span style="color: #ff0000;">工厂模式</span>&mdash;BeanFactory用来创建对象的实例。</li>
<li>适配器&ndash;spring aop</li>
<li>装饰器&ndash;spring data hashmapper</li>
<li>观察者&ndash; spring 时间驱动模型</li>
<li>回调&ndash;Spring ResourceLoaderAware回调接口</li>



</ul>
<h2><span style="background-color: #ffff99;">1.17&nbsp;<strong>Spring <span style="font-family: 宋体;">如何保证 </span><span style="font-family: 'Calibri Light';">Controller </span><span style="font-family: 宋体;">并发的安全？</span></strong></span></h2>
<p class="p">Spring 多线程请求过来调用的Controller对象都是<span style="color: #ff0000;">一个</span>，而不是一个请求过来就创建一个Controller对象。</p>
<p class="p"><strong>并发的安全？</strong>&nbsp;原因就在于<span style="color: #ff0000;">Controller对象是单例的</span>，那么如果不小心在类中定义了类变量，那么这个类变量是被所有请求共享的，这可能会造成多个请求修改该变量的值，出现与预期结果不符合的异常</p>
<p class="p"><strong><span style="font-family: 宋体;">那有没有办法让</span>Controller不以单例而以每次请求都重新创建的形式存在呢</strong>？</p>
<p class="p"><span style="font-family: 宋体;">答案是当然可以，只需要在类上添加注解</span><span style="color: #ff0000;">@Scope(&ldquo;prototype&rdquo;)</span>即可，这样每次请求调用的类都是重新生成的（<span style="color: #ff0000;">每次生成会影响效率</span>）</p>
<p class="p">虽然这样可以解决问题，但增加了时间成本，总让人不爽，还有其他方法么？答案是肯定的！</p>
<p class="p">使用<span style="color: #ff0000;"><strong>ThreadLocal</strong></span>来保存类变量，将类变量保存在<span style="color: #ff0000;">线程的变量域</span>中，让不同的请求隔离开来。</p>
<h2><span style="background-color: #ffff99;">1.18&nbsp;<strong><span style="font-family: 宋体;">使用</span>Spring<span style="font-family: 宋体;">框架的好处是什么？</span></strong></span></h2>
<p class="p"><span style="font-family: 宋体;">轻量：</span>Spring 是轻量的，基本的版本大约2MB。</p>
<p class="p"><span style="font-family: 宋体;">控制反转：</span>Spring通过控制反转实现了松散耦合，对象们给出它们的依赖，而不是创建或查找依赖的对象们。</p>
<p class="p"><span style="font-family: 宋体;">面向切面的编程</span>(AOP)：Spring支持面向切面的编程，并且把应用业务逻辑和系统服务分开。</p>
<p class="p"><span style="font-family: 宋体;">容器：</span>Spring 包含并管理应用中对象的生命周期和配置。</p>
<p class="p">MVC框架：Spring的WEB框架是个精心设计的框架，是Web框架的一个很好的替代品。</p>
<p class="p"><span style="font-family: 宋体;">事务管理：</span>Spring 提供一个持续的事务管理接口，可以扩展到上至本地事务下至全局事务（JTA）。</p>
<p class="p"><span style="font-family: 宋体;">异常处理：</span>Spring 提供方便的API把具体技术相关的异常（比如由JDBC，Hibernate or JDO抛出的）转化为一致的unchecked 异常。</p>
<h2><span style="background-color: #ffff99;">1.19&nbsp;<strong><span style="font-family: 宋体;">在</span> Spring<span style="font-family: 宋体;">中如何注入一个</span><span style="font-family: 'Calibri Light';">java</span><span style="font-family: 宋体;">集合？</span></strong></span></h2>
<p>Spring提供以下几种集合的配置元素：</p>
<ul>
<li>&lt;<span style="color: #ff0000;">list</span>&gt;类型用于注入一列值，允许有相同的值。</li>
<li>&lt;<span style="color: #ff0000;">set</span>&gt; 类型用于注入一组值，不允许有相同的值。</li>
<li>&lt;<span style="color: #ff0000;">map</span>&gt; 类型用于注入一组键值对，键和值都可以为任意类型。</li>
<li>&lt;<span style="color: #ff0000;">props</span>&gt;类型用于注入一组键值对，键和值都只能为String类型</li>




</ul>
<h2><span style="background-color: #ffcc99;">1.20&nbsp;<strong>Spring<span style="font-family: 宋体;">支持的事务管理类型</span></strong></span></h2>
<p class="p">Spring支持如下两种方式的事务管理：</p>
<p class="p"><span style="color: #ff0000;">编程式事务管理</span>：这意味着你可以通过编程的方式管理事务，这种方式带来了很大的灵活性，但很难维护。</p>
<p class="p"><span style="font-family: 宋体;"><span style="color: #ff0000;">声明式事务管理</span>：这种方式意味着你可以将事务管理和业务代码分离。你只需要通过注解或者</span>XML配置管理事务。</p>
<h2><span style="background-color: #ffcc99;">1.21&nbsp;<strong>Spring<span style="font-family: 宋体;">框架的事务管理有哪些优点？</span></strong></span></h2>
<p class="p"><span style="font-family: 宋体;">1)它为不同的事务</span>API(如JTA, JDBC, Hibernate, JPA, 和JDO)提供了统一的编程模型。</p>
<p class="p"><span style="font-family: 宋体;">2)它为编程式事务管理提供了一个简单的</span>API而非一系列复杂的事务API(如JTA).</p>
<p class="p">3)它支持声明式事务管理。</p>
<p class="p"><span style="font-family: 宋体;">4)它可以和</span>Spring 的多种数据访问技术很好的融合。</p>
<h2><span style="background-color: #ffcc99;">1.22&nbsp;<strong>Spring MVC<span style="font-family: 宋体;">的主要组件？</span></strong></span></h2>
<p class="p"><span style="font-family: 宋体;">（</span>1）前端控制器 <span style="color: #ff0000;">DispatcherServlet</span>（不需要程序员开发）</p>
<p class="p"><span style="font-family: 宋体;">作用：接收请求、响应结果，相当于转发器，有了</span>DispatcherServlet 就减少了其它组件之间的耦合度。</p>
<p class="p"><span style="font-family: 宋体;">（</span>2）处理器映射器<span style="color: #ff0000;">HandlerMapping</span>（不需要程序员开发）</p>
<p class="p"><span style="font-family: 宋体;">作用：根据请求的</span>URL来查找Handler</p>
<p class="p"><span style="font-family: 宋体;">（</span>3）处理器适配器<span style="color: #ff0000;">HandlerAdapter</span></p>
<p class="p"><span style="font-family: 宋体;">注意：在编写</span>Handler的时候要按照HandlerAdapter要求的规则去编写，这样适配器HandlerAdapter才可以正确的去执行Handler。</p>
<p class="p"><span style="font-family: 宋体;">（</span>4）处理器<span style="color: #ff0000;">Handler</span>（需要程序员开发）</p>
<p class="p"><span style="font-family: 宋体;">（</span>5）视图解析器 <span style="color: #ff0000;">ViewResolver</span>（不需要程序员开发）</p>
<p class="p"><span style="font-family: 宋体;">作用：进行视图的解析，根据视图逻辑名解析成真正的视图（</span>view）</p>
<p class="p"><span style="font-family: 宋体;">（</span>6）视图<span style="color: #ff0000;">View</span>（需要程序员开发jsp）</p>
<p class="p">View是一个接口， 它的实现类支持不同的视图类型（jsp，freemarker，pdf等等）</p>
<h2><span style="background-color: #ffcc99;">1.23&nbsp;<strong>SpringMvc<span style="font-family: 宋体;">怎么和</span><span style="font-family: 'Calibri Light';">AJAX</span><span style="font-family: 宋体;">相互调用的？</span></strong></span></h2>
<p class="p"><span style="font-family: 宋体;">通过</span><span style="color: #ff0000;">Jackson框架</span>就可以把Java里面的对象直接转化成Js可以识别的Json对象。具体步骤如下 ：</p>
<p class="p"><span style="font-family: 宋体;">（</span>1）加入<span style="color: #ff0000;">Jackson.jar</span></p>
<p class="p"><span style="font-family: 宋体;">（</span>2）在配置文件中<span style="color: #ff0000;">配置json的映射</span></p>
<p class="p"><span style="font-family: 宋体;">（</span>3）在接受Ajax方法里面可以直接返回<span style="color: #ff0000;">Object,List</span>等,但方法前面要加上</p>
<h2><span style="background-color: #ffcc99;">1.24&nbsp;<strong>Mybatis <span style="font-family: 宋体;">中</span><span style="font-family: 'Calibri Light';">#</span><span style="font-family: 宋体;">和</span><span style="font-family: 'Calibri Light';">$</span><span style="font-family: 宋体;">的区别</span><span style="font-family: 'Calibri Light';">?</span></strong></span></h2>
<p class="p">&nbsp; &nbsp; &nbsp;1. <span style="color: #ff0000;">#{}是预编译处理</span>，<span style="color: #ff0000;">${}是字符串替换</span>。</p>
<p class="p">&nbsp; &nbsp; &nbsp; 2. Mybatis在处理#{}时，会将sql中的<span style="color: #ff0000;">#{}</span>替换为<span style="color: #ff0000;">?</span>号，调用<span style="color: #ff0000;">PreparedStatement</span>的set方法来赋值；</p>
<p class="p">&nbsp; &nbsp; &nbsp; 3. Mybatis在处理${}时，就是把${}替换成变量的值，相当于字符串拼接</p>
<p class="p">&nbsp; &nbsp; &nbsp; 4. 使用<span style="color: #ff0000;">#{}</span>可以有效的<span style="color: #ff0000;">防止SQL注入</span>，提高系统安全性。</p>
<h2><span style="background-color: #ffcc99;">1.25&nbsp;<strong>mybatis<span style="font-family: 宋体;">的缓存机制，一级，二级介绍一下</span></strong></span></h2>
<p class="p">&nbsp;&nbsp;&nbsp;一级缓存</p>
<p class="p">&nbsp; &nbsp; &nbsp; 默认开启</p>
<p class="p">&nbsp; &nbsp; &nbsp; <span style="color: #ff0000;">SqlSession</span>级别的缓存，实现在同一个会话中数据的共享</p>
<p class="p">&nbsp; &nbsp; &nbsp; 一级缓存的生命周期和SqlSession一致</p>
<p class="p">&nbsp; &nbsp; &nbsp; 当有多个SqlSession或者分布式环境下，数据库写操作会引起脏数据。</p>
<p class="p">二级缓存</p>
<p class="p">&nbsp; &nbsp; &nbsp; 默认不开启，需手动开启</p>
<p class="p">&nbsp; &nbsp; &nbsp; <span style="color: #ff0000;">SqlSessionFactory</span>级别的缓存，实现不同会话中数据的共享，是一个全局变量</p>
<p class="p">&nbsp; &nbsp; &nbsp; 可自定义存储源，如Ehcache</p>
<p class="p">&nbsp; &nbsp; &nbsp; 当开启缓存后，数据查询的执行的流程是：二级缓存&gt;一级缓存&gt;数据库</p>
<p class="p">&nbsp; &nbsp; &nbsp; 不同于一级缓存，二级缓存可设置是否允许刷新和刷新频率实现</p>
<p class="p"><span style="font-family: 宋体;">实体类实现序列化，在</span>mapper文件中开启&lt;c</p>
<p class="p">ache&gt;</p>
<p class="p"><span style="font-family: 宋体;">在配置文件中设置</span>cacheEnabled为true</p>
<h2><span style="background-color: #ffcc99;">1.26 S<strong>pringMVC<span style="font-family: 宋体;">与</span><span style="font-family: 'Calibri Light';">Struts2</span><span style="font-family: 宋体;">的区别 </span></strong></span></h2>
<p class="p">&nbsp;Springmvc的入口是一个<span style="color: #ff0000;">servlet即前端控制器</span>，而struts2入口是一个<span style="color: #ff0000;">filter过虑器</span>。</p>
<p class="p">&nbsp;Springmvc是基于<span style="color: #ff0000;">方法开发</span>，传递参数是通过<span style="color: #ff0000;">方法形参</span>，可以设计为<span style="color: #ff0000;">单例或多例(建议单例)</span>，struts2是基于<span style="color: #ff0000;">类开发</span>，传递参数是通过<span style="color: #ff0000;">类的属性</span>，只能设计为<span style="color: #ff0000;">多例</span>。</p>
<h2><span style="background-color: #ffcc99;">1.27&nbsp;<strong>mybatis<span style="font-family: 宋体;">的基本工作流程</span></strong></span></h2>
<p class="p">先来看一下MyBatis 的编程式使用的方法：</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> testMapper() <span style="color: #0000ff;">throws</span><span style="color: #000000;"> IOException {
　　String resource </span>= "mybatis-config.xml"<span style="color: #000000;">;
　　InputStream inputStream </span>=<span style="color: #000000;"> Resources.getResourceAsStream(resource);
　　SqlSessionFactory sqlSessionFactory </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> SqlSessionFactoryBuilder().build(inputStream);
　　SqlSession session </span>=<span style="color: #000000;"> sqlSessionFactory.openSession();
　　</span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
　　　　BlogMapper mapper </span>= session.getMapper(BlogMapper.<span style="color: #0000ff;">class</span><span style="color: #000000;">);
　　　　Blog blog </span>= mapper.selectBlogById(1<span style="color: #000000;">);
　　　　System.out.println(blog);
　　} </span><span style="color: #0000ff;">finally</span><span style="color: #000000;"> {
　　　　session.close();
　　}
}</span></code></pre>

<p class="p">1.<span style="color: #ff0000;">读</span>取配置文件，<span style="color: #ff0000;">配置文件</span>包含<span style="color: #ff0000;">数据库连接信息</span>和<span style="color: #ff0000;">Mapper映射文件</span>或者<span style="color: #ff0000;">Mapper包路径</span>。</p>
<p class="p">2.有了这些信息就能创建<span style="color: #ff0000;">SqlSessionFactory</span>，SqlSessionFactory的生命周期是<span style="color: #ff0000;">程序级</span>,程序运行的时候建立起来,程序结束的时候消亡</p>
<p class="p">3.<span style="color: #ff0000;">SqlSessionFactory</span>建立<span style="color: #ff0000;">SqlSession</span>,目的执行sql语句，SqlSession是<span style="color: #ff0000;">过程级</span>,一个方法中建立,方法结束应该关闭</p>
<p class="p">4.当用户使用mapper.xml文件中配置的的方法时，mybatis首先会<span style="color: #ff0000;">解析sql动态标签</span>为对应数据库sql语句的形式，并将其<span style="color: #ff0000;">封装进MapperStatement对象</span>，然后通过<span style="color: #ff0000;">executor</span>将sql注入数据库执行，并返回结果。</p>
<p class="p">5.将返回的结果通过<span style="color: #ff0000;">映射</span>，包装成<span style="color: #ff0000;">java对象</span>。</p>
<h2><span style="background-color: #ffcc99;">1.28&nbsp;<strong><span style="font-family: 宋体;">什么是</span>MyBatis<span style="font-family: 宋体;">的接口绑定</span><span style="font-family: 'Calibri Light';">,</span><span style="font-family: 宋体;">有什么好处</span><span style="font-family: 'Calibri Light';">&nbsp;&nbsp;</span></strong></span></h2>
<p class="p"><span style="font-family: 宋体;">接口映射就是在</span>IBatis中任意定义接口,然后把接口里面的方法和SQL语句绑定,我们通过直接调用接口方法 例如：</p>
<p class="p"><span style="color: #ff0000;">UserMapper &nbsp;userMapper=sqlSession.getMapper &nbsp;(UserMapper.class)</span> 就可以,这样比起原来了SqlSession提供的方法,</p>
<p class="p">例如<span style="color: #ff0000;">List&lt;Country&gt; countryList = sqlSession.selectList("selectAll");</span>我们可以有更加灵活的选择和设置.。</p>
<p class="p"><span style="font-family: 宋体;"><span style="color: #ff0000;">注意</span>：（</span>1）Mapper .xml文件的namespace属性必须配置为接口的全限定名称，接口方法名与Mapper.xml中的&lt;select&gt;&lt;insert&gt;id值必须相同，且接口方法的返回值类型必须与Mapper.xml配置的resultType一致，这里后者起到决定作用。</p>
<p class="p"><span style="font-family: 宋体;">（</span>2）select查询通过在Mapper.xml中配置ResultMap标签，将查询结果的列名与字段名对应。</p>
<p class="p">insert语句通过#{属性名}从接口参数获取值放到sql语句中。</p>
<p class="p"><span style="font-family: 宋体;">（</span>3）Mapper.xml接口绑定本质是动态代理。</p>
<h2><span style="background-color: #ffcc99;">1.29&nbsp;<strong>MyBatis<span style="font-family: 宋体;">的编程步骤</span><span style="font-family: 'Calibri Light';">&nbsp;</span></strong></span></h2>
<p class="p"><span style="font-family: 宋体;">1)创建</span><span style="color: #ff0000;">SqlSessionFactory</span></p>
<p class="p"><span style="font-family: 宋体;">2)通过</span>SqlSessionFactory创建<span style="color: #ff0000;">SqlSession</span></p>
<p class="p"><span style="font-family: 宋体;">3)通过</span>SqlSession<span style="color: #ff0000;">执行</span>数据库操作</p>
<p class="p"><span style="font-family: 宋体;">4)调用</span><span style="color: #ff0000;">session.commit()</span>提交事务</p>
<p class="p"><span style="font-family: 宋体;">5)调用</span><span style="color: #ff0000;">session.close()</span>关闭事务</p>
<h2><span style="background-color: #ffcc00;">1.30&nbsp;JDBC<span style="font-family: 宋体;">编程有哪些不足之处，</span><span style="font-family: 'Calibri Light';">MyBatis</span><span style="font-family: 宋体;">是如何解决这些问题的？ </span></span></h2>
<p class="p">JDBC编程的不足之处</p>
<p class="p">1)数据库链接<span style="color: #ff0000;">创建、释放频繁</span>造成系统资源浪费从而影响系统性能，如果使用数据库链接池可解决此问题。</p>
<p class="p">2)Sql语句写在代码中造成代码不易维护，实际应用sql变化的可能较大，<span style="color: #ff0000;">sql变动需要改变java代码</span>。</p>
<p class="p"><span style="font-family: 宋体;">3)向</span><span style="color: #ff0000;">sql语句传参数麻烦</span>，因为sql语句的where条件不一定，可能多也可能少，占位符需要和参数一一对应。</p>
<p class="p"><span style="font-family: 宋体;">4)对结果集解析麻烦，</span><span style="color: #ff0000;">sql变化导致解析代码变化</span>，且解析前需要遍历，如果能将数据库记录封装成pojo对象解析比较方便。</p>
<p class="p">MyBatis的解决方案</p>
<p class="p"><span style="font-family: 宋体;">1)在</span>SqlMapConfig.xml中配置数据链接池，使用<span style="color: #ff0000;">连接池管理数据库链接</span>。</p>
<p class="p"><span style="font-family: 宋体;">2)将</span><span style="color: #ff0000;">Sql语句配置在XXXXmapper.xml文件中与java代码分离</span>。</p>
<p class="p">3)Mybatis自动将<span style="color: #ff0000;">java对象映射至sql</span>语句。</p>
<p class="p">4)Mybatis自动将<span style="color: #ff0000;">sql执行结果映射至java对象</span>。</p>
<h2><span style="background-color: #ffcc00;">1.31&nbsp;MyBatis<span style="font-family: 宋体;">的优缺点 </span></span></h2>
<p class="p"><span style="font-family: 宋体;">优点</span></p>
<p class="p">1)易于上手和掌握</p>
<p class="p">2)<span style="color: #ff0000;">Sql写在xml里</span>面，便于统一管理和优化</p>
<p class="p"><span style="font-family: 宋体;">3)<span style="color: #ff0000;">减少</span></span><span style="color: #ff0000;">Sql与程序代码的耦合</span></p>
<p class="p"><span style="font-family: 宋体;">4)提供</span>xml标签，<span style="color: #ff0000;">支持动态Sql编写</span></p>
<p class="p"><span style="font-family: 宋体;">缺点</span></p>
<p class="p">1)<span style="color: #ff0000;">Sql工作量大</span>，尤其是字段多，关联表多时，更是如此</p>
<p class="p">2)Sql依赖于数据库，导致数据库<span style="color: #ff0000;">移植性差</span></p>
<p class="p"><span style="font-family: 宋体;">3)由于</span>xml里面标签<span style="color: #ff0000;">id必须唯一</span>，<span style="color: #ff0000;">导致DAO中方法不支持方法重载。所以dao层必须是接口</span></p>
<h2><span style="background-color: #ffcc00;">1.32&nbsp;<span style="font-family: 宋体;">使用</span>MyBatis<span style="font-family: 宋体;">的</span><span style="font-family: 'Calibri Light';">mapper</span><span style="font-family: 宋体;">接口调用时有哪些要求？ </span></span></h2>
<p class="p">Mapper接口方法名和mapper.xml中定义的每个sql的<span style="color: #ff0000;">id相同</span></p>
<p class="p">Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql 的<span style="color: #ff0000;">parameterType</span>的类型相同</p>
<p class="p">Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的<span style="color: #ff0000;">resultType</span>的类型相同</p>
<p class="p">Mapper.xml文件中的<span style="color: #ff0000;">namespace</span>即是mapper接口的类路径</p>
<h2><span style="background-color: #ffcc00;">1.33&nbsp;<strong><span style="font-family: 宋体;">谈谈你对</span>SpringMVC<span style="font-family: 宋体;">的理解</span></strong></span></h2>
<p class="p">1. 是一个基于<span style="color: #ff0000;">MVC的web框架</span></p>
<p class="p">2. SpringMVC是Spring的一个模块，是<span style="color: #ff0000;">Spring的子容器</span>，子容器可以<span style="color: #ff0000;">拿父容器的东西</span>，但是父容器不能拿子容器的东西</p>
<p class="p">3. SpringMVC的<span style="color: #ff0000;">前端控制器DispatcherServlet</span>，用于<span style="color: #ff0000;">分发请求，使开发变得简单</span></p>
<p class="p">4. SpringMVC流程（重点）. SpringMVC三大组件</p>
<p class="p">&nbsp; &nbsp; &nbsp; 1）<span style="color: #ff0000;">HandlerMapping：处理器映射器</span></p>
<p class="p">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 用户请求路径到Controller方法的映射</p>
<p class="p">&nbsp; &nbsp; &nbsp; 2）<span style="color: #ff0000;">HandlerAdapter：处理器适配器</span></p>
<p class="p">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 根据handler(controlelr类）的开发方式（注解开发/其他开发） 方式的不同去寻找不同的处理器适配器</p>
<p class="p">&nbsp; &nbsp; &nbsp; 3）<span style="color: #ff0000;">ViewResolver：视图解析器</span></p>
<p class="p">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 可以解析JSP/freemarkerr/pdf等</p>
<h2><span style="background-color: #ffcc00;">1.34&nbsp;<span style="font-family: 宋体;">简述</span>Mybatis<span style="font-family: 宋体;">的插件运行原理，以及如何编写一个插件？</span></span></h2>
<p class="p"><span style="font-family: 宋体;">答：</span>1）Mybatis仅可以编写针对ParameterHandler、ResultSetHandler、StatementHandler、Executor这4种接口的插件，Mybatis通过动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这4种接口对象的方法时，就会进入拦截方法，具体就是InvocationHandler的invoke()方法，当然，只会拦截那些你指定需要拦截的方法。</p>
<p class="p">2）实现Mybatis的Interceptor接口并复写intercept()方法，然后在给插件编写注解，指定要拦截哪一个接口的哪些方法即可，记住，别忘了在配置文件中配置你编写的插件。</p>
<h2><span style="background-color: #ffcc00;">1.35&nbsp;Mybatis<span style="font-family: 宋体;">动态</span><span style="font-family: 'Calibri Light';">sql</span><span style="font-family: 宋体;">是做什么的？都有哪些动态</span><span style="font-family: 'Calibri Light';">sql</span><span style="font-family: 宋体;">？能简述一下动态</span><span style="font-family: 'Calibri Light';">sql</span><span style="font-family: 宋体;">的执行原理不？</span></span></h2>
<p class="p"><span style="font-family: 宋体;">答：</span>1）Mybatis动态sql可以让我们在Xml映射文件内，以标签的形式编写动态sql，完成逻辑判断和动态拼接sql的功能。2）Mybatis提供了9种动态sql标签：trim|where|set|foreach|if|choose|when|otherwise|bind。</p>
<p class="p">3）其执行原理为，使用OGNL从sql参数对象中计算表达式的值，根据表达式的值动态拼接sql，以此来完成动态sql的功能。</p>
<h2><span style="background-color: #ffcc00;">1.36&nbsp;Mybatis<span style="font-family: 宋体;">是否支持延迟加载？如果支持，它的实现原理是什么？</span></span></h2>
<p><span style="font-family: 宋体;">答：</span>1）Mybatis仅支持association关联对象和collection关联集合对象的延迟加载，association指的就是一对一，collection指的就是一对多查询。在Mybatis配置文件中，可以配置是否启用延迟加载lazyLoadingEnabled=true|false。</p>
<p>2）它的原理是，使用CGLIB创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用a.getB().getName()，拦截器invoke()方法发现a.getB()是null值，那么就会单独发送事先保存好的查询关联B对象的sql，把B查询上来，然后调用a.setB(b)，于是a的对象b属性就有值了，接着完成a.getB().getName()方法的调用。这就是延迟加载的基本原理。</p>
<h2><span style="background-color: #ffcc00;">1.37&nbsp;Mybatis<span style="font-family: 宋体;">能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别？</span></span></h2>
<p><span style="font-family: 宋体;">答：能，</span>Mybatis不仅可以执行一对一、一对多的关联查询，还可以执行多对一，多对多的关联查询，多对一查询，其实就是一对一查询，只需要把selectOne()修改为selectList()即可；多对多查询，其实就是一对多查询，只需要把selectOne()修改为selectList()即可。</p>
<p><span style="font-family: 宋体;">关联对象查询，有两种实现方式，一种是单独发送一个</span>sql去查询关联对象，赋给主对象，然后返回主对象。另一种是使用嵌套查询，嵌套查询的含义为使用join查询，一部分列是A对象的属性值，另外一部分列是关联对象B的属性值，好处是只发一个sql查询，就可以把主对象和其关联对象查出来。</p>
<h2><span style="background-color: #ffcc00;">1.38&nbsp;Mybatis<span style="font-family: 宋体;">是如何将</span><span style="font-family: 'Calibri Light';">sql</span><span style="font-family: 宋体;">执行结果封装为目标对象并返回的？都有哪些映射形式？</span></span></h2>
<p><span style="font-family: 宋体;">答：第一种是使用</span>&lt;resultMap&gt;标签，逐一定义列名和对象属性名之间的映射关系。</p>
<p><span style="font-family: 宋体;">第二种是使用</span>sql列的别名功能，将列别名书写为对象属性名，比如T_NAME AS NAME，对象属性名一般是name，小写，但是列名不区分大小写，Mybatis会忽略列名大小写，智能找到与之对应对象属性名，你甚至可以写成T_NAME AS NaMe，Mybatis一样可以正常工作。</p>
<h2><span style="background-color: #ffcc00;">1.39&nbsp;Mybatis<span style="font-family: 宋体;">映射文件中，如果</span><span style="font-family: 'Calibri Light';">A</span><span style="font-family: 宋体;">标签通过</span><span style="font-family: 'Calibri Light';">include</span><span style="font-family: 宋体;">引用了</span><span style="font-family: 'Calibri Light';">B</span><span style="font-family: 宋体;">标签的内容，请问，</span><span style="font-family: 'Calibri Light';">B</span><span style="font-family: 宋体;">标签能否定义在</span><span style="font-family: 'Calibri Light';">A</span><span style="font-family: 宋体;">标签的后面，还是说必须定义在</span><span style="font-family: 'Calibri Light';">A</span><span style="font-family: 宋体;">标签的前面？</span></span></h2>
<p><span style="font-family: 宋体;">答：虽然</span>Mybatis解析Xml映射文件是按照顺序解析的，但是，被引用的B标签依然可以定义在任何地方，Mybatis都可以正确识别。原理是，Mybatis解析A标签，发现A标签引用了B标签，但是B标签尚未解析到，尚不存在，此时，Mybatis会将A标签标记为未解析状态，然后继续解析余下的标签，包含B标签，待所有标签解析完毕，Mybatis会重新解析那些被标记为未解析的标签，此时再解析A标签时，B标签已经存在，A标签也就可以正常解析完成了。</p>
<h2><span style="background-color: #7fffd4;">1.40&nbsp;<strong>MyBatis<span style="font-family: 宋体;">里面的动态</span><span style="font-family: 'Calibri Light';">Sql</span><span style="font-family: 宋体;">是怎么设定的</span><span style="font-family: 'Calibri Light';">?</span><span style="font-family: 宋体;">用什么语法</span><span style="font-family: 'Calibri Light';">?</span></strong>&nbsp;&nbsp;</span><strong><br /></strong></h2>
<p>答：MyBatis里面的动态Sql一般是通过if节点来实现，通过OGNL语法来实现，但是如果要写的完整，必须配合where、trim节点，where节点是判断包含节点有内容就插入where，否则不插入，trim节点是用来判断如果动态语句是以and 或or开始，那么会自动把这个and或者or取掉 。</p>
<h2><span style="background-color: #7fffd4;">1.41&nbsp;<strong>Mybatis<span style="font-family: 宋体;">都有哪些</span><span style="font-family: 'Calibri Light';">Executor</span><span style="font-family: 宋体;">执行器？它们之间的区别是什么？</span></strong>&nbsp;</span><br /><strong><span style="font-family: 宋体;">答：</span>Mybatis有三种基本的Executor执行器，SimpleExecutor、ReuseExecutor、BatchExecutor。</strong></h2>
<p class="p">SimpleExecutor：每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象。</p>
<p class="p">ReuseExecutor：执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，而是放置于Map&lt;String, Statement&gt;<span style="font-family: 宋体;">内，供下一次使用。简言之，就是重复使用</span>Statement对象。</p>
<p class="p">BatchExecutor：执行update（没有select，JDBC批处理不支持select），将所有sql都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个Statement对象，每个Statement对象都是addBatch()完毕后，等待逐一执行executeBatch()批处理。与JDBC批处理相同。</p>
<p class="p"><span style="font-family: 宋体;">作用范围：</span>Executor的这些特点，都严格限制在SqlSession生命周期范围内。</p>
<h2><span style="background-color: #7fffd4;">1.42&nbsp;<strong><span style="font-family: 宋体;">为什么说</span>Mybatis<span style="font-family: 宋体;">是半自动</span><span style="font-family: 'Calibri Light';">ORM</span><span style="font-family: 宋体;">映射工具？它与全自动的区别在哪里？</span></strong></span></h2>
<p class="p"><span style="font-family: 宋体;">答：</span>Hibernate属于全自动ORM映射工具，使用Hibernate查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。而Mybatis在查询关联对象或关联集合对象时，需要手动编写sql来完成，所以，称之为半自动ORM映射工具。</p>
<p class="p"><span style="font-family: 宋体;">面试题看似都很简单，但是想要能正确回答上来，必定是研究过源码且深入的人，而不是仅会使用的人或者用的很熟的人，以上所有面试题及其答案所涉及的内容，在我的</span>Mybatis系列博客中都有详细讲解和原理分析。</p>
<h2><span style="background-color: #7fffd4;">1.43&nbsp;<strong><span style="font-family: 宋体;">简单介绍下你对</span>mybatis<span style="font-family: 宋体;">的理解？</span></strong></span></h2>
<p>1. &nbsp;&nbsp;&nbsp;&nbsp;mybatis配置</p>
<p>2. SqlMapConfig.xml，此文件作为mybatis的全局配置文件，配置了mybatis的运行环境等信息。</p>
<p>3. mapper.xml文件即sql映射文件，文件中配置了操作数据库的sql语句。此文件需要在SqlMapConfig.xml中加载。</p>
<p>4. 通过mybatis环境等配置信息构造SqlSessionFactory即会话工厂</p>
<p>5. 由会话工厂创建sqlSession即会话，操作数据库需要通过sqlSession进行。</p>
<p>6. mybatis底层自定义了Executor执行器接口操作数据库，Executor接口有两个实现，一个是基本执行器、一个是缓存执行器。</p>
<p>7. Mapped Statement也是mybatis一个底层封装对象，它包装了mybatis配置信息及sql映射信息等。mapper.xml文件中一个sql对应一个Mapped Statement对象，sql的id即是Mapped statement的id。</p>
<p>8. Mapped Statement对sql执行输入参数进行定义，包括HashMap、基本类型、pojo，Executor通过Mapped Statement在执行sql前将输入的java对象映射至sql中，输入参数映射就是jdbc编程中对preparedStatement设置参数。</p>
<p>9. Mapped Statement对sql执行输出结果进行定义，包括HashMap、基本类型、pojo，Executor通过Mapped Statement在执行sql后将输出结果映射至java对象中，输出结果映射过程相当于jdbc编程中对结果的解析处理过程。</p>
<h2><span style="background-color: #7fffd4;">1.44&nbsp;<span style="font-family: 宋体;">介绍一下</span>Spring<span style="font-family: 宋体;">的事物管理</span></span></h2>
<p>&nbsp;&nbsp;&nbsp;&nbsp;事务就是对一系列的数据库操作（比如插入多条数据）进行统一的提交或回滚操作，如果插入成功，那么一起成功，如果中间有一条出现异常，那么回滚之前的所有操作。这样可以防止出现脏数据，防止数据库数据出现问题。</p>
<p><span style="font-family: 宋体;">开发中为了避免这种情况一般都会进行事务管理。</span>Spring中也有自己的事务管理机制，一般是使用TransactionMananger进行管&nbsp;理，可以通过Spring的注入来完成此功能。</p>
<p>Spring支持如下两种方式的事务管理：</p>
<p>编程式事务管理：这意味着你可以通过编程的方式管理事务，这种方式带来了很大的灵活性，但很难维护。</p>
<p><span style="font-family: 宋体;">声明式事务管理：这种方式意味着你可以将事务管理和业务代码分离。你只需要通过注解或者</span>XML配置管理事务。</p>
<p>一般选择声明式事务管理，因为这种方式和应用程序的关联较少。</p>
<h2><span style="background-color: #7fffd4;">1.45&nbsp;SSM<span style="font-family: 宋体;">优缺点、使用场景？</span></span></h2>
<p>1. Mybatis和hibernate不同，它不完全是一个ORM框架，因为MyBatis需要程序员自己编写Sql语句，不过mybatis可以通过XML或注解方式灵活配置要运行的sql语句，并将java对象和sql语句映射生成最终执行的sql，最后将sql执行的结果再映射生成java对象。</p>
<p>2. Mybatis学习门槛低，简单易学，程序员直接编写原生态sql，可严格控制sql执行性能，灵活度高，非常适合对关系数据模型要求不高的软件开发，例如互联网软件、企业运营类软件等，因为这类软件需求变化频繁，一但需求变化要求成果输出迅速。但是灵活的前提是mybatis无法做到数据库无关性，如果需要实现支持多种数据库的软件则需要自定义多套sql映射文件，工作量大。</p>
<p>3. Hibernate对象/关系映射能力强，数据库无关性好，对于关系模型要求高的软件（例如需求固定的定制化软件）如果用hibernate开发可以节省很多代码，提高效率。但是Hibernate的学习门槛高，要精通门槛更高，而且怎么设计O/R映射，在性能和对象模型之间如何权衡，以及怎样用好Hibernate需要具有很强的经验和能力才行。</p>
<p>4. 总之，按照用户的需求在有限的资源环境下只要能做出维护性、扩展性良好的软件架构都是好架构，所以框架只有适合才是最好。</p>
<h2><span style="background-color: #7fffd4;">1.46&nbsp;<strong>SpringMVC<span style="font-family: 宋体;">的工作流程</span><span style="font-family: 'Calibri Light';">?</span></strong></span></h2>
<p><span style="font-family: 宋体;">1)用户发送请求至前端控制器</span><span style="color: #ff0000;">DispatcherServlet</span></p>
<p>2)DispatcherServlet收到请求调用<span style="color: #ff0000;">HandlerMapping</span>处理器映射器。</p>
<p><span style="font-family: 宋体;">3)处理器映射器根据请求</span>url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。</p>
<p>4)DispatcherServlet通过<span style="color: #ff0000;">HandlerAdapter</span>处理器<a href="https://www.baidu.com/s?wd=%E9%80%82%E9%85%8D%E5%99%A8&amp;tn=24004469_oem_dg&amp;rsv_dl=gh_pl_sl_csd"><span style="font-family: 宋体;">适配器</span></a>调用处理器</p>
<p><span style="font-family: 宋体;">5)执行处理器</span>(Controller，也叫后端控制器)。</p>
<p>6)Controller执行完成返回<span style="color: #ff0000;">ModelAndView</span></p>
<p>7)HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet</p>
<p>8)DispatcherServlet将ModelAndView传给ViewReslover视图解析器</p>
<p>9)<span style="color: #ff0000;">ViewReslover</span>解析后返回具体<span style="color: #ff0000;">View</span></p>
<p>10)DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）。</p>
<p>11)<span style="color: #ff0000;">DispatcherServlet</span>响应用户</p>
<h2><span style="background-color: #7fffd4;">1.47&nbsp;<strong><span style="font-family: 宋体;">如果你也用过</span>struts2，<span style="font-family: 宋体;">简单介绍下</span><span style="font-family: 'Calibri Light';">springMVC</span><span style="font-family: 宋体;">和</span><span style="font-family: 'Calibri Light';">struts2</span><span style="font-family: 宋体;">的区别有哪些</span><span style="font-family: 'Calibri Light';">?</span></strong></span></h2>
<p>springmvc的入口是一个servlet即前端控制器，而struts2入口是一个filter过虑器。</p>
<p>springmvc是基于方法开发(一个url对应一个方法)，请求参数传递到方法的形参，可以设计为单例或多例(建议单例)，struts2是基于类开发，传递参数是通过类的属性，只能设计为多例。</p>
<p>Struts采用值栈存储请求和响应的数据，通过OGNL存取数据， springmvc通过参数解析器是将request请求内容解析，并给方法形参赋值，将数据和视图封装成ModelAndView对象，最后又将ModelAndView中的模型数据通过reques域传输到页面。Jsp视图解析器默认使用jstl。</p>
<h2><span style="background-color: #7fffd4;">1.48&nbsp;<span style="font-family: 宋体;">怎么样把数据放入</span>Session<span style="font-family: 宋体;">里面</span><strong>&nbsp;?</strong></span><strong><br /></strong><span style="font-size: 16px;"><strong><span style="font-family: 宋体;">可以声明一个</span>request,或者session先拿到session,然后就可以放入数据,或者可以在类上面加上@SessionAttributes注解,里面包含的字符串就是要放入session里面的key</strong></span></h2>
<h2><span style="background-color: #7fffd4;">1.49&nbsp;<strong><span style="font-family: 宋体;">讲下</span>SpringMvc<span style="font-family: 宋体;">的执行流程</span></strong>&nbsp;?</span></h2>
<p>答案1</p>
<p>系统启动的时候根据配置文件<span style="color: #ff0000;">创建spring的容器</span>,首先是<span style="color: #ff0000;">发送http请求</span>到核心控制器<span style="color: #ff0000;">DispatcherServlet</span>，spring容器通过<span style="color: #ff0000;">映射器</span>去寻找业务<span style="color: #ff0000;">控制器</span>，使用<span style="color: #ff0000;">适配器</span>找到相应的业务类，在进业务类时进行数据封装，在封装前可能会涉及到类型转换，执行完业务类后使用<span style="color: #ff0000;">ModelAndView</span>进行视图转发，数据放在<span style="color: #ff0000;">model</span>中，用<span style="color: #ff0000;">map传递数据</span>进行页面显示。</p>
<p>答案2</p>
<p><img src="./images/Java面试题_第三阶段(Spring、MVC、IOC、AOP、DI、MyBatis、SSM、struts2)0.png" alt="" /></p>
<ul style="margin: 0px 0px 0px 30px; padding: 0px; word-break: break-all; font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 12px;">
<li style="margin-top: 0px; margin-right: 0px; margin-bottom: 1em; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; list-style: disc;">
<h3 style="margin: 10px 0px; padding: 0px; font-size: 16px; line-height: 1.5;">1）一个请求匹配前端控制器&nbsp;<span style="margin: 0px; padding: 0px; color: #ff0000;">DispatcherServlet</span>&nbsp;的请求映射路径(在&nbsp;<span style="margin: 0px; padding: 0px; background-color: #ff0000; color: #ffffff;">web.xml</span>中指定), WEB 容器将该请求转交给 DispatcherServlet 处理</h3>



</li>
<li style="margin-top: 0px; margin-right: 0px; margin-bottom: 1em; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; list-style: disc;">
<h3 style="margin: 10px 0px; padding: 0px; font-size: 16px; line-height: 1.5;">2）DispatcherServlet 接收到请求后, 将根据&nbsp;<span style="margin: 0px; padding: 0px; color: #ff0000;">请求信息&nbsp;</span>交给&nbsp;处理器映射器<span style="margin: 0px; padding: 0px;">&nbsp;（<span style="margin: 0px; padding: 0px; color: #ff0000;">HandlerMapping</span>）</span></h3>



</li>
<li style="margin-top: 0px; margin-right: 0px; margin-bottom: 1em; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; list-style: disc;">
<h3 style="margin: 10px 0px; padding: 0px; font-size: 16px; line-height: 1.5;"><span style="margin: 0px; padding: 0px; color: #ff0000;">3）HandlerMapping&nbsp;</span>根据用户的url请求&nbsp;查找匹配该url的&nbsp;<span style="margin: 0px; padding: 0px; color: #ff0000;">Handler</span>，并返回一个<span style="margin: 0px; padding: 0px; color: #ff0000;">执行链<span style="margin: 0px; padding: 0px; color: #000000;"><br style="margin: 0px; padding: 0px;" /></span></span></h3>



</li>
<li style="margin-top: 0px; margin-right: 0px; margin-bottom: 1em; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; list-style: disc;">
<h3 style="margin: 10px 0px; padding: 0px; font-size: 16px; line-height: 1.5;">4）DispatcherServlet 再请求 处理器适配器(<span style="margin: 0px; padding: 0px; color: #ff0000;">HandlerAdapter</span>) 调用相应的 Handler 进行处理并返回&nbsp;<span style="margin: 0px; padding: 0px; color: #ff0000;">ModelAndView</span>&nbsp;给&nbsp;DispatcherServlet</h3>



</li>
<li style="margin-top: 0px; margin-right: 0px; margin-bottom: 1em; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; list-style: disc;">
<h3 style="margin: 10px 0px; padding: 0px; font-size: 16px; line-height: 1.5;">5）DispatcherServlet 将 ModelAndView 请求&nbsp;<span style="margin: 0px; padding: 0px; color: #ff0000;">ViewReslover</span>（视图解析器）解析，返回具体 View</h3>



</li>
<li style="margin-top: 0px; margin-right: 0px; margin-bottom: 1em; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; list-style: disc;">
<h3 style="margin: 10px 0px; padding: 0px; font-size: 16px; line-height: 1.5;">6）DispatcherServlet 对 View 进行<span style="margin: 0px; padding: 0px; color: #ff0000;">渲染视图</span>（即将<span style="margin: 0px; padding: 0px; color: #ff0000;">模型数据</span>填充至视图中）</h3>



</li>
<li style="margin-top: 0px; margin-right: 0px; margin-bottom: 1em; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; list-style: disc;">
<h3 style="margin: 10px 0px; padding: 0px; font-size: 16px; line-height: 1.5;">7）DispatcherServlet 将页面响应给用户</h3>



</li>



</ul>
<h2><span style="background-color: #9999ff;">1.50&nbsp;<strong>MyBatis(IBatis)<span style="font-family: 宋体;">的好处是什么</span></strong>？</span><br /><span style="font-size: 16px;"><strong>ibatis把sql语句从Java源程序中独立出来，放在单独的XML文件中编写，给程序的&nbsp;</strong><strong><br /></strong><strong><span style="font-family: 宋体;">维护带来了很大便利。</span>&nbsp;</strong><strong><br /></strong><strong>ibatis封装了底层JDBC API的调用细节，并能自动将结果集转换成JavaBean对象，大大简化了Java数据库编程的重复工作。&nbsp;</strong><strong><br /></strong><strong><span style="font-family: 宋体;">因为</span>Ibatis需要程序员自己去编写sql语句，程序员可以结合数据库自身的特点灵活控制sql语句，&nbsp;</strong><strong><br /></strong><strong><span style="font-family: 宋体;">因此能够实现比</span>hibernate等全自动orm框架更高的查询效率，能够完成复杂查询。</strong></span></h2>
<h2><span style="background-color: #9999ff;">1.51&nbsp;<strong>Bean <span style="font-family: 宋体;">工厂和 </span><span style="font-family: 'Calibri Light';">Application contexts </span><span style="font-family: 宋体;">有什么区别？</span></strong></span></h2>
<p class="p">Application contexts提供一种方法处理文本消息，一个通常的做法是加载文件资源（比如镜像），它们可以向注册为监听器的bean发布事件。另外，在容器或容器内的对象上执行的那些不得不由bean工厂以程序化方式处理的操作，可以在Application contexts中以声明的方式处理。Application contexts实现了MessageSource接口，该接口的实现以可插拔的方式提供获取本地化消息的方法。</p>
<h2><span style="background-color: #9999ff;">1.52&nbsp;<strong><span style="font-family: 宋体;">解释</span>Spring<span style="font-family: 宋体;">支持的几种</span><span style="font-family: 'Calibri Light';">bean</span><span style="font-family: 宋体;">的作用域</span></strong></span></h2>
<p class="p">Spring框架支持以下五种bean的作用域：</p>
<p class="p">singleton : bean在每个Spring ioc 容器中只有一个实例。</p>
<p class="p">prototype：一个bean的定义可以有多个实例。</p>
<p class="p">request：每次http请求都会创建一个bean，该作用域仅在基于web的Spring ApplicationContext情形下有效。</p>
<p class="p">session：在一个HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。</p>
<p class="p">global-session：在一个全局的HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。</p>
<p class="p"><span style="font-family: 宋体;">缺省的</span>Spring bean 的作用域是Singleton。</p>
<h2><span style="background-color: #9999ff;">1.53&nbsp;<strong><span style="font-family: 宋体;">什么是</span>bean<span style="font-family: 宋体;">的自动装配？</span></strong></span></h2>
<p class="p">Spring 容器能够自动装配相互合作的bean，这意味着容器不需要&lt;constructor-arg&gt;和&lt;property&gt;配置，能通过Bean工厂自动处理bean之间的协作。</p>
<h2><span style="background-color: #9999ff;">1.54&nbsp;<strong><span style="font-family: 宋体;">什么是基于</span>Java<span style="font-family: 宋体;">的</span><span style="font-family: 'Calibri Light';">Spring</span><span style="font-family: 宋体;">注解配置</span><span style="font-family: 'Calibri Light';">? </span><span style="font-family: 宋体;">给一些注解的例子。</span></strong></span></h2>
<p class="p"><span style="font-family: 宋体;">基于</span>Java的配置，允许你在少量的Java注解的帮助下，进行你的大部分Spring配置而非通过XML文件。</p>
<p class="p"><span style="font-family: 宋体;">以</span>@Configuration 注解为例，它用来标记类可以当做一个bean的定义，被Spring IOC容器使用。另一个例子是@Bean注解，它表示此方法将要返回一个对象，作为一个bean注册进Spring应用上下文。</p>
<h2><span style="background-color: #9999ff;">1.55&nbsp;<strong><span style="font-family: 宋体;">使用</span>Spring<span style="font-family: 宋体;">通过什么方式访问</span><span style="font-family: 'Calibri Light';">Hibernate?</span></strong></span></h2>
<p class="p"><span style="font-family: 宋体;">在</span>Spring中有两种方式访问Hibernate：</p>
<p class="p"><span style="font-family: 宋体;">控制反转</span> Hibernate Template和 Callback。</p>
<p class="p"><span style="font-family: 宋体;">继承</span> HibernateDAOSupport提供一个AOP 拦截器。</p>
<h2><span style="background-color: #9999ff;">1.56&nbsp;<strong><span style="font-family: 宋体;">如何通过</span>HibernateDaoSupport<span style="font-family: 宋体;">将</span><span style="font-family: 'Calibri Light';">Spring</span><span style="font-family: 宋体;">和</span><span style="font-family: 'Calibri Light';">Hibernate</span><span style="font-family: 宋体;">结合起来？</span></strong></span></h2>
<p class="p"><span style="font-family: 宋体;">用</span>Spring的 SessionFactory 调用 LocalSessionFactory。集成过程分三步：</p>
<p class="p"><span style="font-family: 宋体;">配置</span>the Hibernate SessionFactory。</p>
<p class="p"><span style="font-family: 宋体;">继承</span>HibernateDaoSupport实现一个DAO。</p>
<p class="p"><span style="font-family: 宋体;">在</span>AOP支持的事务中装配。</p>
<h2><span style="background-color: #9999ff;">1.57&nbsp;<strong>Spring<span style="font-family: 宋体;">框架的事务管理有哪些优点？</span></strong></span></h2>
<p class="p"><span style="font-family: 宋体;">它为不同的事务</span>API 如 JTA，JDBC，Hibernate，JPA 和JDO，提供一个不变的编程模式。</p>
<p class="p"><span style="font-family: 宋体;">它为编程式事务管理提供了一套简单的</span>API而不是一些复杂的事务API如</p>
<p class="p">它支持声明式事务管理。</p>
<p class="p"><span style="font-family: 宋体;">它和</span>Spring各种数据访问抽象层很好得集成。</p>
<h2><span style="background-color: #9999ff;">1.58&nbsp;<strong><span style="font-family: 宋体;">在</span>Spring AOP <span style="font-family: 宋体;">中，关注点和横切关注的区别是什么？</span></strong></span></h2>
<p class="p">关注点是应用中一个模块的行为，一个关注点可能会被定义成一个我们想实现的一个功能。</p>
<p class="p">横切关注点是一个关注点，此关注点是整个应用都会使用的功能，并影响整个应用，比如日志，安全和数据传输，几乎应用的每个模块都需要的功能。因此这些都属于横切关注点。</p>
<h2><span style="background-color: #9999ff;">1.59&nbsp;AOP<span style="font-family: 宋体;">作用是什么</span><span style="font-family: 'Calibri Light';">,</span><span style="font-family: 宋体;">底层如何实现在哪些地方会用到</span><span style="font-family: 'Calibri Light';">,</span><span style="font-family: 宋体;">分别简述切面</span><span style="font-family: 'Calibri Light';">,</span><span style="font-family: 宋体;">切入点和通知。</span></span></h2>
<p class="p">AOP:面向切面编程:将一个系统中共同的业务逻辑提取出来,进行单独的封装成一个组件(切面),然后以配置的方式作用于系统中,实现程序的可插拔性,提高代码的复用性,提升系统的灵活性和性能</p>
<p class="p"><span style="font-family: 宋体;">底层实现</span>:JDK动态代理,只支持接口注入CGLIB:可以支持普通类的注入</p>
<p class="p"><span style="font-family: 宋体;">那些地方会用到</span>:事物开启,日志记录,安全验证,权限验证</p>
<p class="p"><span style="font-family: 宋体;">切面</span>:系统中共通的业务提取出来,在某个时刻或者某个阶段共同调用</p>
<p class="p"><span style="font-family: 宋体;">切入点</span>:找到目标方法,给它追加共通的业务逻辑,在spring中提供了切入点表达式帮助我们找到目标方法execution</p>
<p class="p"><span style="font-family: 宋体;">通知</span>:什么时候调用这个共通的业务逻辑,用于指定切面方法作用到系统中的时机.前置通知,后置通知,环绕通知,异常通知,最终通知。</p>
<h2><span style="background-color: #ccffcc;">1.60&nbsp;<strong>Spring<span style="font-family: 宋体;">中</span><span style="font-family: 'Calibri Light';">AutoWired</span><span style="font-family: 宋体;">和</span><span style="font-family: 'Calibri Light';">,Resource</span><span style="font-family: 宋体;">之间区别是什么</span></strong></span></h2>
<p class="p">AutoWried:按照类型进行匹配&mdash;spring框架自带的,查看当前Spring容器中那个bean类型和引用类型一致,就进行注入,如果有多个匹配类型就会报错.</p>
<p class="p">Resource:默认按照名称进行注入,如果找不到对应的名称按照bean类型进行注入&nbsp;。</p>
<p>答：MyBatis里面的动态Sql一般是通过if节点来实现，通过OGNL语法来实现，但是如果要写的完整，必须配合where、trim节点，where节点是判断包含节点有内容就插入where，否则不插入，trim节点是用来判断如果动态语句是以and 或or开始，那么会自动把这个and或者or取掉 。</p>
<p>&nbsp;</p>
<p><span style="color: #ff0000;">ending...</span></p>
<p>&nbsp;</p>

</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>