<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修Java面向对象总结' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>Java面向对象总结</center></div><div class='banquan'>原文出处:本文由博客园博主LYANG-A提供。<br/>
原文连接:https://www.cnblogs.com/lyang-a/p/11434550.html</div><br>
    <h2 id="面向对象基本概念">面向对象基本概念</h2>
<p>  <strong>Java</strong> 是面向对象的编程语言，对象就是面向对象程序设计的核心。所谓对象就是现实世界中的实体，对象与实体是一 一对应的，也就是说现实世界中每一个实体都是一个对象，它是一种具体的概念。</p>
<p><strong>对象有以下特点</strong>：</p>
<ul>
<li>对象具有属性和行为。</li>
<li>对象具有变化的状态。</li>
<li>对象具有唯一性。</li>
<li>对象都是某个类别的实例。</li>
<li>一切皆为对象，现实世界中的所有事物都可以视为对象（<strong>万物皆对象</strong>）。</li>
</ul>
<h2 id="面向对象的三大核心特性">面向对象的三大核心特性</h2>
<p>1、 <strong>可管理性</strong>：能够将功能与数据结合，方便管理。<br />
2.、<strong>可扩展性</strong>：它使面向对象设计脱离了基于模块的设计，便于软件的修改。<br />
3.、<strong>可重用性</strong>：它是面向对象软件开发的核心思路，提高了开发效率。面向对象程序设计的抽象、继承、封装和多态四大特点都围绕这个核心。</p>
<h2 id="类和对象">类和对象</h2>
<p>  <strong>类</strong>：类是一个模板、一种分类，它描述一类对象的行为（方法）和状态（属性）。<br />
  <strong>对象</strong>：对象是类的一个实例（对象不是找个女朋友），有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。</p>
<h2 id="类和对象的定义格式">类和对象的定义格式</h2>
<h3 id="类的定义">类的定义：</h3>
<pre><code><code>[public] class 类名称{
    属性名称;
    返回值类型 方法名称(){}
}

//例：
class Student{
    private String name;
    private int age;
    public void teal(){
        System.out.println(name+&quot;今年&quot;+age+&quot;岁！&quot;);
    }
}</code></code></pre>
<h3 id="对象的定义">对象的定义：</h3>
<p>  一个类要想真正的进行操作，则必须依靠对象，对象的定义格式如下：</p>
<pre><code><code>   类名称  对象名称 = new 类名称();
例：Student  stu  = new Student();</code></code></pre>
<p>如果要想访问类中的属性或方法（方法的定义），则可以依靠以下的语法形式：<br />
  访问类中的属性：<strong>对象.属性</strong> ;<br />
  调用类中的方法：<strong>对象.方法()</strong>;</p>
<h2 id="对象的创建">对象的创建</h2>
<p>  对象是根据类创建的。在Java中，使用关键字<strong>new</strong>来创建一个新的对象。创建对象需要以下三步：</p>
<p>    <strong>声明</strong>：声明一个对象，包括对象名称和对象类型。<br />
    <strong>实例化</strong>：使用关键字<strong>new</strong>来创建一个对象。<br />
    <strong>初始化</strong>：使用new创建对象时，会调用构造方法初始化对象。<br />
例子：</p>
<pre><code><code>public Dog(String name){
     //这个构造器仅有一个参数：name
     System.out.println(&quot;小狗的名字是 : &quot; + name ); 
}
public static void main(String[] args){
     // 下面的语句将创建一个Puppy对象
     Dog dog = new Dog( &quot;Tom&quot; );
}</code></code></pre>
<h2 id="封装">封装</h2>
<p><strong>封装的概念</strong>：<br />
  封装是面向对象思想的三大特征之一，封装就是隐藏实现细节，仅对外提供访问接口。实现细节部份包装、隐藏起来的方法。<br />
封装的<strong>好处</strong>：<br />
  减少耦合性、隐藏信息、代码复用、安全性高、类内部的结构可以自由修改 ... 。<br />
封装的<strong>缺点</strong>：会影响执行效率</p>
<p>封装之前：属性都可以直接访问和修改。</p>
<pre><code><code>class Person{
　　String name;
　　int age;
}</code></code></pre>
<p>封装之后：</p>
<p>  属性都不可以直接访问和修改，需通过<strong>set</strong>和<strong>get</strong>方法进行<strong>访问</strong>和<strong>修改</strong>。</p>
<pre><code><code>class Person{
　　//属性是成员变量，私有化属性，使得其他对象不能直接访问属性
　　private String name;
　　private int age;
　　//参数及方法内定义的变量是局部变量
　　public void setName(String name){
　　      this.name = name;
    }
　　public String getName(){
　　      return name;
    }
}</code></code></pre>
<h2 id="构造方法">构造方法</h2>
<p>  构造方法是类的一种特殊方法，用来初始化类的一个新的对象。Java 中的每个类都有一个默认的构造方法，它必须具有和类名相同的名称，而且没有返回类型。构造方法的默认返回类型就是对象类型本身，并且构造方法不能被<strong>static</strong>、<strong>final</strong>、<strong>synchronized</strong>、<strong>abstract</strong> 和 <strong>native</strong> 修饰。</p>
<h3 id="无参构造方法">无参构造方法：</h3>
<p>  如果一个类没有定义构造方法，则默认<strong>无参构造</strong>，如果有定义有参构造，最好再显示定义一个无参构造方法</p>
<pre><code><code>public Student(){
    // 默认无参构造方法
} </code></code></pre>
<h3 id="带参构造方法">带参构造方法：</h3>
<pre><code><code>public Student(String name){
    this.name = name;
}</code></code></pre>
<h3 id="多参构造方法">多参构造方法：</h3>
<pre><code><code>public Student(String name,int age){
    this.name = name;
    this.age = age;
    //...
}</code></code></pre>
<p><font color = red><strong>总结</strong>：</font></p>
<p> （1）构造方法名称与类名相同，没有返回值声明（包括 <strong>void</strong>）<br />
 （2）构造方法用于初始化数据（属性）。<br />
 （3）每一个类中都会有一个默认的无参的构造方法。<br />
 （4）如果类中有显示的构造方法，那么默认构造方法将无效。<br />
 （5）如果有显示的构造方法，还想保留默认构造方法，需要显示的写出来。<br />
 （6）构造方法可以有多个，但参数不一样，称为构造方法的重载。<br />
 （7）在构造方法中调用另一个构造方法，使用<strong>this</strong>(...)，该句代码必须在第一句。<br />
 （8）构造方法之间的调用，必须要有出口。<br />
 （9）给对象初始化数据可以使用构造方法或Setter方法，通常情况下，两者都会保留。<br />
 （10）一个好的编程习惯是要保留默认的构造方法。（为了方便一些框架代码使用反射来创建对象）</p>
<p><font color=red>注意</font>：<br />
  1、<strong>this()</strong> 不能使用在普通方法中，只能写在构造方法中。<br />
  2、<strong>this(实参列表)</strong>必须放在构造方法中的第一行。<br />
  3、在构造方法中，this(实参列表)不可<strong>递归</strong>（自己调用自己）。</p>
<h2 id="值传递与引用传递">值传递与引用传递</h2>
<p>  <font color = red><strong>在java中只有值传递，并没有所谓的引用传递</strong></font></p>
<p>java数据类型可以分为两大类：<br />
  <strong>基本类型</strong>（primitive types）和<strong>引用类型</strong>（reference types）</p>
<p><img src="./images/Java面向对象总结0.png" alt="数据类型" /></p>
<h2 id="java基本数据类型的大小范围默认值">Java基本数据类型的大小、范围、默认值</h2>
<table>
<thead>
<tr class="header">
<th>数据类型</th>
<th>描述</th>
<th>占用字节</th>
<th>取值范围</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>byte</td>
<td>Java中最小的数据类型</td>
<td>1个字节</td>
<td>-128 ~ 127</td>
<td>0</td>
</tr>
<tr class="even">
<td>short</td>
<td>短整型</td>
<td>2个字节</td>
<td>-32768 ~ 32717</td>
<td>0</td>
</tr>
<tr class="odd">
<td>int</td>
<td>整型，用于存储整数</td>
<td>4个字节</td>
<td>-2147483648 ~ 2147483647</td>
<td>0</td>
</tr>
<tr class="even">
<td>long</td>
<td>长整型</td>
<td>8个字节</td>
<td>-2^63 ~ 2^63-1</td>
<td>0L</td>
</tr>
<tr class="odd">
<td>float</td>
<td>浮点型，用于存储带小数点的数字</td>
<td>4个字节</td>
<td>/</td>
<td>0.0f</td>
</tr>
<tr class="even">
<td>double</td>
<td>双精度浮点型，用于存储带有小数点的数字</td>
<td>8个字节</td>
<td>/</td>
<td>0.0d</td>
</tr>
<tr class="odd">
<td>char</td>
<td>字符型，用于存储单个字符</td>
<td>2个字节</td>
<td>0 ~ 65535</td>
<td>\u0000(空格)</td>
</tr>
<tr class="even">
<td>boolean</td>
<td>布尔类型，用于判断真或假</td>
<td>1个字节</td>
<td>仅有两个值，即true、false</td>
<td>false</td>
</tr>
</tbody>
</table>
<h2 id="static关键字">static关键字</h2>
<p><strong>static</strong>关键字的作用：方便在没有创建对象的情况下来进行调用（方法/变量）。<br />
  a、使用static关键字修饰一个<strong>属性</strong>：声明为static的变量实质上就是全局变量。<br />
  b、使用static关键字修饰一个<strong>方法</strong>：在一个类中定义一个方法为static，无需本类的对象即可调用此方法（类调用）。<br />
  c、使用static关键字修饰一个<strong>类（内部类）</strong>：<br />
      声明为static的方法有以下几条限制：<br />
        它们仅能调用其他的static 方法，反过来是可以的，<br />
        它们只能访问static数据，<br />
        它们不能以任何方式引用<strong>this</strong>或<strong>super，</strong><br />
        不允许用来修饰局部变量。</p>
<p><strong>总结</strong>：被<strong>static</strong>关键字修饰的方法或者变量不需要依赖于对象来进行访问，只要类被加载了，就可以通过类名去进行访问。</p>
<p>可以参考：<a href="https://www.cnblogs.com/dolphin0520/p/3799052.html" class="uri">https://www.cnblogs.com/dolphin0520/p/3799052.html</a></p>
<h2 id="继承extends">继承（extends）</h2>
<p>  继承是面向对象三大特征之一。在定义和实现一个类的时候，可以在一个已经存在的类（父类）的基础之上来进行，把这个已经存在的类（父类）所定义的内容作为自己的内容，并可以加入若干新的内容，或修改原来的方法（重写）使之更适合特殊的需要，这就是继承。</p>
<p> 被继承的类称为<strong>父类（超类）</strong>，继承父类的类称为<strong>子类（派生类）</strong>，通过继承可以实现代码重用<br />
  子类拥有父类非 private 的属性、方法。<br />
  子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。<br />
  子类可以用自己的方式实现父类的方法。</p>
<p>  <strong>构造器</strong>而言，它只能够被调用，而不能被继承，可以通过使用super()进行调用，<br />
  对于继承而已，子类会默认调用父类的构造器，但是如果没有默认的父类构造器，子类必须要显示的指定父类的构造器（通过<strong>super()</strong>），而且必须是在子类构造器中做的第一件事(第一行代码)。<br />
  对于<strong>protected</strong>而言，它指明就类用户而言，他是private，但是对于任何继承与此类的子类而言或者其他任何位于同一个包的类而言，他却是可以访问的</p>
<p>  <strong>Java 的继承是单继承，不允许多继承，但是可以多层继承（继承链）；接口可以实现多继承！</strong></p>
<p>语法：</p>
<pre><code><code>[访问权限] class 子类名 extends 父类名{
　　//类体定义;
}</code></code></pre>
<p>示例：</p>
<pre><code><code>public class Dog{
    private String name;
    private String sex;
    
    public void eat(){
        System.out.println(&quot;吃饭&quot;);
    }
}
public class HomeDog extends Dog{
　　//类的定义
}
public class HuskyDog extends Dog{
　　//类的定义
}</code></code></pre>
<p>继承的<strong>好处</strong>：<br />
  a、提高代码的复用性<br />
  b、提高代码的维护性<br />
  c、让类与类之间产生关系，是多态的前提</p>
<p>继承的<strong>缺点</strong>：<br />
  提高了类与类之间的耦合性</p>
<p>不能被继承的有哪些？<br />
  被private、static修饰的不能被继承；<br />
  构造方法不能被继承；<br />
  被final修饰的方法和类不能被继承。</p>
<h2 id="对象初始化">对象初始化</h2>
<h3 id="一代码块的概念">一、代码块的概念</h3>
<p>  <strong>静态代码块</strong>、<strong>构造代码块</strong>、<strong>局部代码块</strong></p>
<p>    <strong>静态代码块</strong>：在类中，方法体和代码块之外（全局作用域），使用static修饰的代码块，我们称之为静态代码块。（可以定义任意多个，顺序执行）<br />
      静态代码块随着类的第一次加载而执行，且只执行一次。<br />
      在静态代码块中，不能直接操作类中的成员变量，但是可以操作当前类中的成员变量。<br />
      静态代码块要想操作静态变量，静态变量必须在静态代码块之前声明，因为再类中它们的执行顺序是<strong>从上而下</strong>的。</p>
<p>    <strong>构造代码块</strong>：在类中，方法体和代码块之外（全局作用域），没有使用static修饰的代码块，我们称之为静态代码块。（可以定义任意多个，顺序执行）<br />
      构造代码块随着对象的创建而执行，对象创建多少次构造代码块就执行多少次。<br />
      构造代码块优先于构造方法执行，创建对象时先执行当前类中的构造代码块，然后再执行构造方法。</p>
<p>    <strong>局部代码块</strong>：在局部中定义的代码块。（可以定义任意多个，顺序执行）</p>
<p>  执行顺序：<br />
    <strong>静态代码块 &gt; 构造代码块 &gt; 构造方法</strong></p>
<pre><code><code>class Test{
  public String str1;   //普通字段
  public static String str2;    // 静态字段

  static{           
    //静态代码块
  }

  {
    //构造代码块
  }
    
  public Test() { 
    //构造函数
  }
    
  public static void main(String[] args) {
    {
        System.out.println(&quot;局部代码块&quot;);
    }
  }
}</code></code></pre>
<h3 id="二-创建子类对象时对象的初始化顺序">二、 创建子类对象时，对象的初始化顺序</h3>
<h4 id="字段初始化代码块和构造函数的执行顺序">  1、字段初始化、代码块和构造函数的执行顺序</h4>
<pre><code><code>public class CodeBlockTest {
      public static void main(String[] args) {
        Child child = new Child();
      }
}

class Father {
      public static String fatherStr1 = &quot;fatherStr1（静态字段初始化值）&quot;;
      public String fatherStr2 = &quot;fatherStr2（字段初始化值）&quot;;

    static {
        System.out.println(&quot;父类静态代码块：&quot; + fatherStr1);
        fatherStr1 = &quot;fatherStr1（静态代码块赋值）&quot;;
      }
    
      {
        System.out.println(&quot;父类构造代码块：&quot; + fatherStr2);
        fatherStr2 = &quot;fatherStr2（构造代码块赋值）&quot;;
      }
    
      public Father() {
        System.out.println(&quot;父类构造函数块：&quot; + fatherStr2);
        fatherStr2 = &quot;fatherStr2（构造函数赋值）&quot;;
      }
}

class Child extends Father {
      public static String childStr1 = &quot;childStr1（静态字段初始化值）&quot;;
      public String childStr2 = &quot;childStr2（字段初始化值）&quot;;
    
      static {
        System.out.println(&quot;子类静态代码块：&quot; + childStr1);
        childStr1 = &quot;childStr1（静态代码块赋值）&quot;;
      }
    
      {
        System.out.println(&quot;子类构造代码块：&quot; + childStr2);
        childStr2 = &quot;childStr2（构造代码块赋值）&quot;;
      }
    
      public Child() {
        System.out.println(&quot;子类构造函数：&quot; + childStr2);
        childStr2 = &quot;childStr2（构造函数赋值）&quot;;
      }
}</code></code></pre>
<p><strong>输出结果：</strong></p>
<pre><code><code>父类静态代码块：fatherStr1（静态字段初始化值）
子类静态代码块：childStr1（静态字段初始化值）
父类构造代码块：fatherStr2（字段初始化值）
父类构造函数块：fatherStr2（构造代码块赋值）
子类构造代码块：childStr2（字段初始化值）
子类构造函数：childStr2（构造代码块赋值）</code></code></pre>
<p>通过每执行一个代码块或构造函数，输出字段在上一代码块执行后的值，以此来探究对象的初始化顺序。</p>
<h4 id="父类静态代码块和子类静态字段初始化的执行顺序">  2、父类静态代码块和子类静态字段初始化的执行顺序</h4>
<pre><code><code>public class CodeBloacTest2 {
      public static void main(String[] args) {
        Child child = new Child();
      }
}

class Father {
      public static String fatherStr = &quot;（静态字段初始化值）&quot;;
      static {
        System.out.println(&quot;父类静态代码块：fatherStr&quot; + fatherStr);
        fatherStr = &quot;（静态代码块赋值）&quot;;
    }
}

class Child extends Father {
    public static String childStr = fatherStr;
    static {
      System.out.println(&quot;子类静态代码块：childStr = fatherStr&quot; + childStr);
      childStr = &quot;（静态代码块赋值1）&quot;;
    }
}</code></code></pre>
<p><strong>输出结果：</strong></p>
<pre><code><code>父类静态代码块：fatherStr（静态字段初始化值）
子类静态代码块：childStr = fatherStr（静态代码块赋值）</code></code></pre>
<p>  我们在子类静态字段childStr初始化的时候，赋的是父类静态字段fatherStr的值。由输出结果可知，childStr初始化后的值是父类静态代码块执行后赋予fatherStr的值。由此可知两者的执行顺序为：父类静态代码块 &gt; 子类静态字段初始化</p>
<p><strong>结论：</strong><br />
  <strong>static字段、代码块</strong>的执行顺序优先于<strong>非static字段、代码块</strong>。这是因为在静态域是属于类的，在类加载后就一直存在；而普通域需要创建对象才能访问。而在创建对象时，需要先加载父类，然后再加载子类，因此<strong>父类的静态字段初始化和静态代码块执行先于子类。</strong></p>
<p>引用：<a href="https://www.jb51.net/article/111157.htm" class="uri">https://www.jb51.net/article/111157.htm</a></p>
<h2 id="方法重载overlord">方法重载（Overlord）</h2>
<p>  方法重载是 Java多态性的表现。在 Java 语言中，<strong>在同一个类中有多个（一个以上）名称相同的方法，但它们的参数列表各不相同（即参数个数或类型不同）</strong>，这种情况被称为方法的<strong>重载</strong>。<br />
  方法重载有两种情况：<strong>普通方法的重载</strong>和<strong>构造方法的重载</strong>。<br />
<strong>重载遵循的规则：</strong></p>
<ul>
<li>重载方法的参数列表必须和被重载的方法不同，并且这种不同必须足以清楚地确定要调用哪一个方法。</li>
<li>重载方法的返回值类型可以和被重载的方法相同，也可以不同，但是只有返回值类型不同不能表示为重载。</li>
</ul>
<h2 id="方法的重写override">方法的重写（Override）</h2>
<p>  在Java中，子类中的方法可以与父类中的某个方法的<strong>名称和参数完全相同</strong>，通过子类创建的实例对象调用这个方法时，将调用子类中的定义方法，这相当于把父类中定义的那个完全相同的方法给覆盖了，这就是方法的<strong>重写</strong>。方法重写又称<strong>方法覆盖</strong>。<br />
  在子类和父类中，重写方法后，在调用时，以创建的对象类型为准，会调用谁的方法。</p>
<p><strong>重写遵循的规则：</strong></p>
<ul>
<li>发生在子父类中，方法重写的两个方法返回值、方法名、参数列表必须完全一致（子类重写父类的方法）</li>
<li>子类抛出的异常不能超过父类相应方法抛出的异常（子类异常不能大于父类异常）</li>
<li>子类方法的访问级别不能低于父类相应方法的访问级别(子类访问级别不能低于父类访问级别)</li>
<li>父类中的方法若使用<strong>private</strong>、<strong>static</strong>、<strong>final</strong>任意修饰符修饰，那么，不能被子类重写。</li>
</ul>
<p><font color = red><strong>重载（Overload）与重写（Override）的区别？？？</strong></font></p>
<h2 id="this关键字">this关键字</h2>
<p><strong>this</strong>关键字指向的是当前对象的引用。</p>
<p>  调用类中的属性：<strong>this.属性名称</strong>，指的是访问类中的成员变量，用来区分成员变量和局部变量（重名问题）。<br />
  调用类中的方法：<strong>this.方法名称</strong>，用来访问本类的成员方法。<br />
  调用类构造方法：<strong>this();</strong> 访问本类的构造方法，()中可以有参数，如果有参数，就是调用指定的有参构造。</p>
<pre><code><code>public Num_Min(int num1, int num2) {
    this.num1 = num1;
    this.num2 = num2;
}
    
public Num_Min(int num1, int num2, int num3) {
    this(num1,num2);    // 调用类中的构造方法
    /*this.num1 = num1;
    this.num2 = num2;*/
    this.num3 = num3;
}</code></code></pre>
<p>为什么<strong>this(实参列表)</strong>和<strong>super(实参列表)</strong>必须放在第一行？<br />
  <strong>核心</strong>：在一个类中，可能有很多个构造方法，但是肯定有一个构造方法没有显示的使用this(实参列表)，因为构造方法不能递归！<br />
  <strong>super(实参列表)</strong>：保证子类对象访问父类成员变量之前已经完成了对父类对象的初始化工作！<br />
  <strong>this(实参列表)</strong>：保证父类初始化的唯一性！</p>
<h2 id="super关键字">super关键字</h2>
<p>可以理解为对父类的引用，使用super来调用父类的<strong>属性</strong>，<strong>方法</strong>，和<strong>构造方法</strong><br />
super可以完成以下的操作：<br />
  a、使用super调用父类中的属性，可以从父类实例处获得信息。<br />
  b、使用super调用父类中的方法，可以委托父类对象帮助完成某件事情。<br />
  c、使用super调用父类中的构造方法（super(实参)形式），必须在子类构造方法的第一条语句，调用父类中相应的构造方法，若不显示的写出来，默认调用父类的无参构造方法，比如：super();</p>
<h2 id="final关键字">final关键字</h2>
<p>  <strong>final的含义：最终的，不可变的。</strong></p>
<p>  <strong>final</strong>可以修饰局部变量，也可以修饰<strong>属性</strong>（成员变量和静态变量）、<strong>方法</strong>（成员方法和静态方法）和<strong>类</strong> ，但是不能修饰<strong>构造方法</strong>！</p>
<p>使用<strong>final</strong>关键字完成以下的操作：<br />
  a、使用final关键字声明的变量，我们称之为<strong>常量</strong>，必须对该值初始化操作。<br />
    当final修饰一个基本数据类型时，表示该基本数据类型的值一旦在初始化后就不能发生变化；<br />
    如果final修饰一个引用类型时，在对其初始化之后便不能再让其指向其他对象了，但该引用所指向的对象的内容是可以发生变化的</p>
<p>  b、使用final关键字声明的方法<br />
    该方法为最终方法，且只能被子类继承，但是不能被子类重写。</p>
<p>  c、使用final关键字声明的类<br />
    该类就转变为最终类（不可变的类），fianl修饰的类无法被继承。</p>
<p>  d、在方法参数中使用final，在该方法内部不能修改参数的值。</p>
<p>  当final变量是基本数据类型以及String类型时，如果在编译期间能知道它的确切值，则编译器会把它当做编译期常量使用，不过要注意，只有在编译期间能确切知道final变量值的情况下，编译器才会进行这样的优化<br />
  引用变量被final修饰之后，虽然不能再指向其他对象，但是它指向的对象的内容是可变的。</p>
<p>可以参考：<a href="https://www.cnblogs.com/xiaoxi/p/6392154.html" class="uri">https://www.cnblogs.com/xiaoxi/p/6392154.html</a></p>
<h2 id="多态性">多态性</h2>
<p>  <strong>多态</strong>就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定。就是不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是<strong>多态性</strong>。</p>
<p><strong>多态存在的三个必要条件：</strong><br />
  （1）继承<br />
  （2）重写<br />
  （3）父类引用指向子类对象</p>
<p><strong>多态的优点</strong><br />
  消除类型之间的耦合性、可替换性、可扩充性、灵活性、简化性等。</p>
<p><strong>对象的多态性</strong>：<br />
  对象多态性是从继承关系中的多个类而来，<br />
  <strong>向上转型</strong>：将子类实例转为父类引用<br />
  <strong>格式</strong>：<code>父类 父类对象 = 子类实例 ;</code> // 自动转换<br />
  以基本数据类型操作为例：int i = ‘a' ;<br />
  （因为char的容量比int小，所以可以自动完成）</p>
<p>  <strong>向下转型</strong>：将父类实例转为子类实例<br />
  <strong>格式</strong>：<code>子类 子类对象 = (子类)父类实例 ;</code> // 强制转换<br />
  以基本数据类型操作为例：char c = (char)97;<br />
  （因为整型是4个字节比char 2个字节要大，所以需要强制完成）</p>
<p>a、方法的<strong>重载</strong>与<strong>重写</strong>就是方法的多态性表现<br />
b、多个子类就是父类中的多种形态<br />
c、父类引用可以指向子类对象，自动转换<br />
d、子类对象指向父类引用需要强制转换（注意：类型不对会报异常 ClassCastException）<br />
e、在实际开发中尽量使用父类引用（更利于扩展）</p>
<p>  指向子类的父类引用由于向上转型了，它只能访问父类中拥有的方法和属性，而对于子类中存在而父类中不存在的方法，<br />
  该引用是不能使用的，尽管是重载该方法。若子类重写了父类中的某些方法，在调用该些方法的时候，必定是使用子类中定义的这些方法（动态连接、动态调用）。<br />
例如：</p>
<pre><code><code>class A{
　　void fun1(){}
　　void fun2(){}
}

class B extends A{
　　void fun1(String a){} //重载fun1
　　void fun2(){} //重写fun2
}

class C{
　　public static void main(String[] args){
　　A a = new B();
　　a.fun1(); //这里会调用A类的fun1方法，由于向上转型，B的fun1(String a) 会被丢弃
　　a.fun2(); //这里调用B的fun2方法，由于是new 的B对象，而B重写了fun2，所以会调用B的fun2
}
}</code></code></pre>
<p>   对于面向对象而言，多态分为编译时多态和运行时多态。其中编辑时多态是静态的，主要是指方法的重载，而运行时多态是动态的，它是通过动态绑定来实现的，也就是我们所说的<strong>多态性</strong>。</p>
<p>java实现多态有三个必要条件（<strong>继承</strong>、<strong>重写</strong>、<strong>向上转型</strong>）：<br />
   <strong>继承</strong>：在多态中必须存在有继承关系的子类和父类。<br />
   <strong>重写</strong>：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。<br />
   <strong>向上转型</strong>：在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法</p>
<p><strong>基于继承实现的多态：</strong><br />
   继承是通过重写父类的同一方法的几个不同子类来体现的<br />
   对于引用子类的父类类型，在处理该引用时，它适用于继承该父类的所有子类，子类对象的不同，对方法的实现也就不同，<br />
   执行相同动作产生的行为也就不同。</p>
<p><strong>基于接口实现的多态：</strong><br />
   指向接口的引用必须是指定这实现了该接口的一个类的实例程序，在运行时，根据对象引用的实际类型来执行对应的方法。</p>
<h2 id="instanceof关键字">instanceof关键字</h2>
<p>  <strong>instanceof</strong>是用于检查对象是否为指定的类型，通常在把父类引用强制转换为子类引用（==向下转型==）时要使用，以避免发生类型转换异常（ClassCastException）。</p>
<p><strong>语法格式如下：</strong></p>
<pre><code><code>obj instanceof class|interface</code></code></pre>
<p><strong>作用</strong>：判断<code>instanceof</code>左边的对象（obj）是否是<code>instanceof</code>右边的实例。</p>
<p>注意点:</p>
<ul>
<li><p>“obj”可以是对象，也可以是null</p></li>
<li><pre><code><code>    instanceof属于二元运算符，返回的结果为boolean类型。</code></code></pre></li>
<li><pre><code><code>      当“obj”是“class(类)|interface(接口)”的实例，则返回结果为true，否则返回结果为false！</code></code></pre></li>
</ul>
<p><strong>示例：</strong></p>
<pre><code><code>if(animal instanceof dog){
　　//...
}</code></code></pre>
<p>  该语句一般用于判断一个对象是否为某个类的实例，是返回true，否返回false</p>
<p><strong>instanceof编译</strong>和<strong>运行</strong>方面进行分析：</p>
<p>  instanceof编译时特点<br />
    右边的“类或接口”是左边“对象”的父类、本身类和子类时，编译通过，否则编译失败！<br />
    本身类：此处的本身类指的就是“<strong>编译时</strong>”对应的类。<br />
    Animal animal = new Dog();  --&gt;本身类就是Animal</p>
<p>  当左边“对象”不为null的时候<br />
    右边的<strong>类或接口</strong>是左边<strong>对象</strong>的父类、本身类时，这是返回结果就是true。<br />
    右边的<strong>类或接口</strong>是左边<strong>对象</strong>的兄弟类、子类时，这是返回结果就是false。<br />
    本身类：此处的本身类指的就是“<strong>运行时</strong>”对应的类。<br />
    Animal animal = new Dog();  --&gt;本身类就是Dog</p>
<pre><code><code>// 编译时         运行时
Animal animal = new Dog();
// 编译时：本身类      运行时：本身类的父类
System.out.println(animal instanceof Animal);       // true
// 编译时：本身类的子类   运行时：本身类
System.out.println(animal instanceof Dog);          // true
// 编译时：本身类的子类   运行时：本身类的子类
System.out.println(animal instanceof SmallDog);     // false
// 编译时：本身类的父类   运行时：本身类的父类  
System.out.println(animal instanceof Object);       // true
// 编译时：本身类的子类   运行时：本身类的兄弟
System.out.println(animal instanceof Cat);          // false
System.out.println(null instanceof Animal);         // false
System.out.println(animal instanceof String);   // 编译时：根本身类没联系（报异常）</code></code></pre>
<p>多态情况下操作成员变量和成员方法的特点：</p>
<pre><code><code>// 编译时         运行时
Animal animal = new Dog();</code></code></pre>
<p>  成员变量特点：<br />
    <strong>编译时</strong>：编译看左边，也就是看“编译类型”中是否包含该成员变量。<br />
    <strong>运行时</strong>：运行看左边，也就是执行“编译类型”中的成员变量。<br />
    <strong>核心</strong>：编译和运行都看左边（编译类型）。<br />
  成员方法特点：<br />
    <strong>编译时</strong>：编译看左边，也就是看“编译类型”中是否包含该成员方法。<br />
    <strong>运行时</strong>：运行看右边，也就是执行“运行类型”中的成员方法。<br />
    <strong>核心</strong>：编译看左边（编译类型），运行看右边（运行类型）。</p>
<h2 id="抽象类abstract">抽象类（abstract）</h2>
<p><strong>抽象类的基本概念：</strong><br />
  （1）很多具有相同<strong>特征</strong>和<strong>行为</strong>的对象可以抽象为一个类。<br />
  （2）使用<strong>abstract</strong>关键字声明的类为抽象类。</p>
<p><strong>定义一个抽象类：</strong></p>
<pre><code><code>abstract class Animal{
      public abstract void move();
}

abstract class Person extends Animal{
      private String name;
      //...
    
      public abstract void eat();//抽象方法
}</code></code></pre>
<p><strong>抽象类的规则：</strong></p>
<ul>
<li>抽象类可以没有抽象方法，有抽象方法的类必须是抽象类。</li>
<li>非抽象类继承抽象类时必须实现所有的抽象方法，如果没有实现抽象类中所有的抽象方法，则该类也是一个抽象类。</li>
<li>抽象类可以继承抽象类，可以不实现父类抽象方法。</li>
<li>抽象类可以有方法实现和属性。</li>
<li>抽象类不能被实例化。</li>
<li>抽象类不能被<strong>final</strong>修饰。</li>
<li>抽象类可以有构造方法。</li>
</ul>
<p>  <strong><font color = red>注意</font>：abstract关键字不能和private、final、static关键字共存！</strong></p>
<h2 id="接口interface">接口（interface）</h2>
<p><strong>接口的定义语法格式：</strong></p>
<pre><code><code>// 接口的定义
[权限修饰符] interface 接口名称 [extends 父类接口1, 父类接口2, ...] {
        // 声明变量（静态全局的）
        // 抽象方法
        // JDK1.8以后，还可以定义静态方法和default修饰的成员方法
}

// 接口的实现
[修饰符] class 实现类 [extends 父类] interface 接口1, 接口2, ... {
        // 重写接口中的方法
}</code></code></pre>
<p><strong>接口特性</strong><br />
  1、接口中每一个<strong>方法</strong>也是隐式抽象的,接口中的方法会被隐式的指定为 <strong>public abstract</strong>（只能是 public abstract 修饰，其他修饰符都会报错）。<br />
  2、接口中可以含有<strong>变量</strong>，但是接口中的变量会被隐式的指定为 <strong>public static final 变量</strong>（并且只能用 public 修饰，其他修饰符都会报错）。<br />
  3、接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。</p>
<p><strong>示列：</strong></p>
<pre><code><code>interface Eat{
    /* public abstract */ void eat();  //默认为public abstract void eat();
    /* public static final */ int NUM = 10; 
}

public interface Sleep extends Eat{
    // 默认为抽象方法
    /* public abstract */ void sleep();
    
    // JDK1.8以后，我们还可以定义静态方法和default修饰的成员方法
    public static void staticMethod() {
        System.out.println(&quot;静态方法&quot;);
    }
    default void method() {
        System.out.println(&quot;成员方法&quot;);
    }
}</code></code></pre>
<p><strong>接口的使用规则：</strong><br />
（1）定义一个接口，使用【<strong>interface</strong>】关键字<br />
（2）一个具体类实现接口使用【<strong>implements</strong>】关键字<br />
（3）接口可以继承多个接口：<strong>extends</strong> 接口1, 接口2, …<br />
（4）接口不能被实例化<br />
（5）接口不能有构造方法<br />
（6）一个类可以实现多个接口<br />
（7）抽象类实现接口可以不实现接口的方法<br />
（8）在接口中定义的方法没有声明 访问修饰符，默认为public<br />
（9）在一个接口中，只能定义<strong>常量</strong>、<strong>抽象方法</strong>，JDK1.8后可以定义默认的实现方法</p>
<p><strong>java8新增：</strong><br />
（1）增加了default方法和static方法,这两种方法完全可以有方法体<br />
（2）default方法属于实例,static方法属于类(接口)<br />
（3）接口中的静态方法不会被继承,接口中的静态变量会被继承</p>
<pre><code><code>public interface IUser {
    static void say() {
    System.out.println(&quot;say_&quot; + IUser.class);
}

    default void eat() {
        System.out.println(&quot;eat_&quot; + IUser.class);
    }
}</code></code></pre>
<p>  <font color = red><strong>接口与抽象类的区别？？？</strong></font></p>


</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>