<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修《构建之法》阅读-第一次作业' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>《构建之法》阅读-第一次作业</center></div><div class='banquan'>原文出处:本文由博客园博主Slow-walker提供。<br/>
原文连接:https://www.cnblogs.com/Slow-Walker/p/11513179.html</div><br>
    <h1 align="center">构建之法第一次作业</h1>
<p><strong>作业属于的课程：</strong><a href="https://edu.cnblogs.com/campus/xnsy/2019autumnsystemanalysisanddesign">https://edu.cnblogs.com/campus/xnsy/2019autumnsystemanalysisanddesign</a></p>
<p><strong>作业的要求：</strong><a href="https://www.cnblogs.com/harry240/p/11469058.html">https://www.cnblogs.com/harry240/p/11469058.html</a></p>
<p><strong>我在这个课程的目标：</strong></p>
<p>（1）系统分析作为我们专业的核心必修课程，其在软件组织中，分析与设计的作用是举足轻重的。自己也是希望利用这门课程，把大一、大二两个学年所学到的在软件开发过程中最重要的一些核心思想、设计模式等方面的知识贯穿起来，使自己能够有一个更加完整的知识体系结构，深刻对软件工程的理解。</p>
<p>（2）无论从提升自己的专业动手能力，还是为获得一个更高的分数。自己都应该认真高质量的完成每一次的作业。自己也感觉到每一次的作业设计的都很合理。特别是团队和个人项目时，应该利用所学的理论，从相反方面加以讨论软件系统分析与设计的方法、流程、工具与文档。实现从理论和实践两方面的能力同时提升。</p>
<p><strong>这个作业在哪个具体方面帮助我实现目标：</strong></p>
<p>本次作业针对性对博客园优秀的博文和教材进行了大量阅读，也使自己对软件工程这门课程和博客园这个工具有了一个更深入的认识。同时也是第一次在博客园写文章，接下来的日子也会利用好这门课程的每一次作业和博客园的丰富文章来极大的丰富和完善自己的知识体系。</p>
<h1><strong>一、 </strong><strong>建立博客并介绍自己</strong></h1>
<p><strong>自己的博客地址</strong>：<a href="https://www.cnblogs.com/Slow-Walker/">https://www.cnblogs.com/Slow-Walker/</a></p>
<p><strong>自我介绍：</strong></p>
<p>我叫王柄钞，是来自2017级软件工程卓越班普通程序员一枚，爱好爬山、打篮球、喜欢到处陪&ldquo;girl&rdquo;一起吃吃逛逛。自己认为自己动手能力还是不错，追求突破和解决困难问题之后的成就感，遇事能够比较成熟稳重思考之后再做决定，能够吃苦、敢于挑战，记得曾经做的一个比赛，大概熬了一个月的通宵本来是不可能完成的项目，最终提交作品的时候还是做出了比较满意的作品也取得了意想不到的成绩。有些时候总觉得自己学东西总是比人家慢了一个节拍一样，但是相信自己只要能够持续性的努力就一定不会比人家差，正如自己的博客名Slow-Walker，I&rsquo; am slow-walker ,But I never walk backwards.</p>
<h1><strong>二、 </strong><strong>阅读与思考</strong></h1>
<h2>（1）回想一下你初入大学时对你所在专业的畅想</h2>
<p><strong>当初你是如何做出选择你所在专业的决定的？</strong></p>
<p>回首两年前选专业的场景，其实那个时候自己对计算机这个行业不是很了解，也仅仅就知道他在未来就业还非常好，对于我们这种家庭没有特别厚的背景的人学计算机能够通过自己的能力，走出属于自己的一片天地。模模糊糊就选了这个专业，从大学进来的时候自己想着，自己在大学里面一定要好好学，因为这专业学好了自己能够凭借自己的技术去创业开公司。</p>
<p>&nbsp;</p>
<p><strong>你认为过去一（两）年中接触到的课程是否符合你对你自己所在专业的期待，为什么？</strong></p>
<p>在过去两年里自己接触和学习的东西主要来自两个方面，第一个就是学校开始的课程的学习，第二个就是来自自己阅览和看的视频所学的感兴趣的方向的知识。都比较满意自己在刚刚大一之处对自己这两年的规划，唯一还有点不足的是自己学习的知识还是比较零散，也希望通过自己这一年的学习巩固和加强丰富自己转也课程体系。</p>
<p>&nbsp;</p>
<p align="left"><strong>你觉得你所在的专业是你喜欢的领域吗，它是你擅长的领域吗？</strong></p>
<p>自我感觉软件工程学生未来有很多发展方向，因此针对自己也选了一个自己的未来发展方向，我喜欢大数据领域，我相信自己通过这三年一直朝着这个目标前进，不断曾强自己在这方面的知识，相信到即将大三结束工作面试活动研究生面试都能取得自己一个较满意的结果。</p>
<p>&nbsp;</p>
<p><strong>将来你会选择从事和你专业相关的工作吗？是的话给出你想去的城市、公司和岗位，否的话给出原因</strong></p>
<p>将来的我会选择从事现在所学专业的工作，当然想去的城市能够留在成都当然也是挺不错的，公司的话还是希望自己起初实习以及起初正式工作不应该只看中眼前的工资，而应该考虑未来五年深知十年的薪水，所以起初应该本着对未来学习和发展更有帮助的公司去上班。期望的当然还是BAT这种大公司，岗位还是想做大数据研发这一块，大数据架构。</p>
<h2>（2）对照前人们走过的路和描述未来发展，现在的你</h2>
<p><strong>自我感觉你已经具备的专业知识、技能、能力有哪些？已经写过的代码量是多少？描述你做的最复杂的项目/</strong><strong>作业。</strong></p>
<p>自我感觉自己以及具备基本的c、c#、java、python、PHP基本的程序设计能力，能够熟练的使用MySQL数据库，对面向对象、设计模式有比较深刻的认识。自己写过的代码量至少应该有3万行+，自己做过最复杂的项目印象最深刻的有两个。</p>
<p>第一个就是石工设计大赛给斯伦贝谢公司做的一个petrel插件，其实在开发这个插件业务不是很复杂，难的就是他的开发框架要用他自己的ocean框架是集成在vs里面的。遇到的最大的困难就是要去学习这些全英文开发文档，要去明白他的数据域以及数据结构是怎么样的。从项目启动到结束持续性的花费了一个月的时间，基本上每天最早睡觉也是两点。但最后还是取得了一个满意的成绩。最终在这个过程提升的是自己的一个快速学习和克服问题解决问题的能力，使自己在未来开发过程中有了更加向前的动力。</p>
<p>&nbsp;</p>
<p><strong>离成为一个合格的本科毕业生，在专业知识、技能、能力上还差距哪些？</strong></p>
<p>其实针对自己现在像一个合格的本科生出去工作的话，自己专业知识上也主要差在自己学的东西还很零散，基础不够扎实，不能融会贯通，动手能力上还有待加强。在与人沟通协作的技能上还有一定的差距，特别是在编码这一块，自我感觉一个真正合格计算机本科毕业生，本科毕业至少也得应该有10万+行代码量，也正是需要这样的代码量的不断练习我们学的知识，才能丰富和融会贯通，使得我们的知识体系结构更加完整，才能在写代码的过程中不断改进，提升代码质量，我想这也是有些人能进一些大厂，然而有些人也只能进一些小公司的原因所在。</p>
<h2>（3）目前是一个人生选择的十字路口，考研、工作、考公、出国，不同的选择在大三就有不同的努力方向。而无论考研还是工作的每条路径，也有许多不同的分支。</h2>
<p align="left"><strong>对照以上你阅读的前人们的经历，你的选择是什么？</strong></p>
<p>针对在老师们列出的优秀博文，其实他们很多都讲了一个共同的特点就是刚刚开始也比较菜，但是自己不愿意待在舒适的环境，都是通过一次次失败一次次前进，并在这个过程中厚积薄发，最终达到了自己既定的目标。同样，自己的选择也是，我也首先会选择考取研究生，想通过这样一个平台不断提升自己的能力，再到后面工作的时候自己应该起步五年应该主要沉下心来厚积薄发，后面五年到十年才会实现由量变到质变的一个过程。</p>
<p align="left"><strong>&nbsp;</strong></p>
<p><strong>在这种选择下，你认为你相比其他同学来说有何优势，有何劣势？</strong></p>
<p>优势的话主要是通过自己更高水平的研究生学习，相信自己未来的起点一定会比人家高，自己的未来对事物的认知水平也会有更加不同的高度。劣势就是相比于同龄进入社会的人，自己晚出去三年，也许到自己毕业的时候人家已经是有很强经验的项目经理了。</p>
<p>&nbsp;</p>
<p><strong>针对你的选择，你给自己的大三设定的规划安排是什么？</strong></p>
<p>设定的目标，努力学好自己的课程，将自己的绩点有所提升，更加完善自己的动手能力和丰富自己的专业知识结构体系。争取把六级过了，争取能够有一篇尽量高一点水平的文章和一张含金量较高的国奖。</p>
<p>&nbsp;</p>
<p><strong>你对于实现自己的梦想已经做了或者计划做什么样的准备？</strong></p>
<p>所做的计划，首先就是每天认真按照自己的规定计划完成当天的英语学习，其次未来提升代码量和成绩自己努力完成每一次老师课后布置的作业，并上课积极与老师交流互动。针对课后，自己也正在准备参加数学建模国赛，以及后期的泰迪杯，以及主动学习相关的研究，相信自己能够在大三关键的一年多出一些成果。</p>
<h1>三、提有质量的问题</h1>
<p>针对性阅读之后的罗列的本书逻辑目录：</p>
<p>&nbsp;</p>
<h2>第一章 概论</h2>
<p>大马哈鱼洄游模型</p>
<p>程序数据结构算法 软件程序软件工程</p>
<p>软件工程定义</p>
<p>软件工程三步曲</p>
<p>&nbsp;</p>
<h2>第二章 个人技术和流程</h2>
<p>单元测试</p>
<p>个人开发流程</p>
<p>&nbsp;</p>
<h2>第三章 软件工程师的成长</h2>
<p>个人能力的衡量与发展</p>
<p>初级软件工程师成长阶段</p>
<p>软件开发的工作量和质量的衡量标准</p>
<p>软件工程师的职业发展</p>
<p>&nbsp;</p>
<h2>第四章 两人合作</h2>
<p>代码规范</p>
<p>代码风格规范</p>
<p>代码设计规范</p>
<p>代码复审</p>
<p>结对编程</p>
<p>&nbsp;</p>
<h2>第五章 团队和流程</h2>
<p>写了再改模式Code-and-Fix</p>
<p>瀑布模型Waterfall Model</p>
<p>瀑布模型的各种变形</p>
<p>Rational Unified Process统一流程RUP</p>
<p>老板驱动的流程Boss-Driven Process</p>
<p>渐进交付的流程Evolutionary DeliveryMVP和MBP</p>
<p>&nbsp;</p>
<h2>第六章 敏捷流程</h2>
<p>敏捷的流程</p>
<p>敏捷流程的问题和解法</p>
<p>敏捷的团队</p>
<p>敏捷总结</p>
<p>敏捷的问答</p>
<p>&nbsp;</p>
<h2>第七章 MSF</h2>
<p>MSF 简史</p>
<p>MSF基本原则</p>
<p>MSF团队模型</p>
<p>MSF过程模型</p>
<p>MSF敏捷开发模式</p>
<p>MSF CMMI开发模式</p>
<p>&nbsp;</p>
<h2>第八章 需求分析</h2>
<p>&nbsp;</p>
<p>软件需求</p>
<p>软件产品的利益相关者</p>
<p>获取用户需求用户调查</p>
<p>竞争性需求分析的框架 NABCD模型</p>
<p>功能的定位和优先级</p>
<p>计划和估计</p>
<p>分而治之Work Breakdown Structure</p>
<p>&nbsp;</p>
<h2>第九章 项目经理</h2>
<p>PM 是啥</p>
<p>微软PM的来历</p>
<p>PM做开发和测试之外的所有事情</p>
<p>PM 和风险管理</p>
<p>PM 的能力要求和任务</p>
<p>在一个项目中PM的具体任务</p>
<p>&nbsp;</p>
<h2>第十章 典型用户和场景</h2>
<p>典型用户和典型场景</p>
<p>用例Use Case</p>
<p>规格说明书</p>
<p>功能驱动的设计</p>
<p>&nbsp;</p>
<h2>第十一章 软件设计与实现</h2>
<p>分析和设计方法</p>
<p>图形建模和分析方法</p>
<p>其他设计方法</p>
<p>从Spec到实现</p>
<p>开发阶段的日常管理</p>
<p>&nbsp;</p>
<h2>第十二章 用户体验</h2>
<p>用户体验的要素</p>
<p>用户体验设计的步骤和目标</p>
<p>评价标准</p>
<p>&nbsp;</p>
<h2>第十三章 软件测试</h2>
<p>基本名词解释及分类</p>
<p>各种测试方法</p>
<p>实战中的测试</p>
<p>&nbsp;</p>
<h2>第十四章 质量保证</h2>
<p>软件的质量</p>
<p>软件的质量保障工作</p>
<p>&nbsp;</p>
<h2>第十五章 稳定和发布阶段</h2>
<p>从代码完成到发布</p>
<p>不同频率和不同覆盖范围的渐进发布</p>
<p>发布之后事后诸葛亮会议</p>
<p>&nbsp;</p>
<h2>第十六章 IT行业的创新</h2>
<p>创新的迷思</p>
<p>创新的时机</p>
<p>创新的招数</p>
<p>魔方的创新</p>
<h3>最后针对性的章节提出问题：</h3>
<h2>问题一、</h2>
<p>针对第二章中单元测试的学习，对之前写过的一些程序试了一下更加深单元测试的理解，之前对这个没什么概念写代码就只管写代码了。也理解到了自己在写单元测试时应该要跟软件同步更新，并且单元测试要覆盖所有代码路径，单元测试可以把我们的软件能做的不能做的事都在&ldquo;单元&rdquo;中表达出来。并且也感受到了有单元测试的话后期出现的bug修复起来也比很容易。</p>
<p>针对自己的写的一个测试自己暑假写的java代码，感受到单元测试的一个重要标准就是保持每个测试的孤立性，即只测试本方法内的逻辑，如果遇到其它模块或其它借口的调用，则尽量使用mock&nbsp;object来代替，在实际测试过程中，如果一个类A中的一个方法需要调用到接口B、C、D、E、F、G（或更多）接口的时候，通常的做法，也是junit框架推荐的做法是将这些其它接口通过参数传递的方式供A使用，但这样造成的最直接后果就是A方法中的参数过多，代码难以维护且不美观，可能有些得不偿失。</p>
<p>然而过程中也遇到的问题，怎么保持单元测试的孤立性呢，而且存在的问题还有就是，假如测试方法中的参数过多就会造成在被测试方法业务逻辑复杂，而且会频繁调用其它接口，如何减少参数呢？</p>
<h2>问题二、</h2>
<p>针对第六章的敏捷开发的整个流程和疑惑，敏捷开发的路程，个人觉的如果能够掌控好开发的流程和节点，及时的了解进度与遇到的问题，及时发现可能隐患的延时问题，就能掌控好开发的流程了；针对于复杂的开发确实很有用，回想之前自己开发的几个程序，只是简单的执行，使用敏捷开发并不适用，简单的东西也许敏捷反而不敏捷了；</p>
<p>回头先之前的开发过程，也都感觉使用了里面的部分路程，自己最后总结的流程，首先是，快速的竟品分析。对市面上的同类竟品进行深入的分析，提炼出产品框架，分析对比各竟品的优缺点，去其糟粕，取其精华。其次对用户行为数据分析。通过问卷，访谈等调查用户使用此类产品遇到的问题，收集反馈意见。再通过设计多套概念产品方案。设计产品框架，主要任务流程，最初可以设计多套交互方案，最后评审选出最优方案。再快速的视觉实现。定义产品主色和辅助色系，快速在一个典型的界面上进行多套方案的尝试，通过简单的用户测试，决定出符合用户预期的风格方案。最终高效配合，敏捷开发。技术人员根据交互原型和典型界面的视觉方案进行技术储备和框架搭建，最后对各模块精细化实现，最后产品上线。</p>
<h2>问题三、</h2>
<p>在本书的第11章，我看了这一段文字&ldquo;小飞：你是说构建就像是运球、传球。。。&rdquo;，对于代码重构不是很清楚。我查了资料，基本上都是在强调重构的好处优点，重构就是软件产品最初制造出来，具有良好架构。由于随着时间的发展，需求发生变化，为了实现达到软件对的雪球，不得已要打破之前的架构方式。然而新修订的入户软件已经使得之前的变得面目全非，并限制之后功能的扩展。从而这个软件如果要重构的花费还比不如重新开发一个软件成本高。而重构在&ldquo;软件系统的过程, 它不会改变代码的外部行为, 同时改善其内部结构。 这是一种严格的清理代码的方法, 它可以最大限度地减少引入错误的可能性。重构的实质就是，在编码能够考虑之后的维护和功能的扩展。&rdquo;</p>
<p>然而现在对重构还有似乎疑惑，针对何时重构，在刚刚开始开发的时候应该在那些方面应该考虑后面的重构？</p>
<h2>问题四、</h2>
<p>针对第13章的阅读各种的软件测试，确实软件测试是软件工程中的一项重要的步骤，缺一不可，然而书中学会到了单元测试、构建验证测试、&ldquo;探索式&rdquo;的测试等待，然而我感觉可以加一种测试方法，就是将用户和测试人员相结合的方式一起进行测试，这样的话通过用户的角度就能够更多的去发现问题，同事在他们测试过程过程中，也能让他们发现问题，并及时解决问题，不至于到最后交付项目时候出现偏差。</p>
<h2>问题五、</h2>
<p>针对在在第16章中，阅读针对创新，文中谈到了创新，谈到了创新时机、创新的迷思和招数等。同事举例了创新的产品，其中对于一个魔方的销售，针对不同的客户使用了一些不一样的商业模式。然而针对软件工程开发领域创新到底什么样的才叫创新？要达到什么要求水平才能称得上创新？新的开发技术的出现算是软件工程的创新吗？</p>
<p>&nbsp;</p>
<h1>四、了解和调查源程序版本管理工具</h1>
<p>之前暑假做的项目都一直使用svn，用的过程中一直注意的就是始终保持与SVN服务器保持同步，代码的版本控制，分支控制，必须要靠有权限的人才能操作。而本次使用的git让每个用户都可以有自己的版本控制，可以用户更多自己管理自己代码的途径。</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td valign="top" width="143">
<p class="a1">管理工具</p>
</td>
<td valign="top" width="143">
<p class="a1">简介</p>
</td>
<td valign="top" width="143">
<p class="a1">优点</p>
</td>
<td valign="top" width="139">
<p class="a1">缺点</p>
</td>
</tr>
<tr>
<td valign="top" width="143">
<p class="a1">Git</p>
</td>
<td valign="top" width="143">
<p class="a1">开源的分布式的vcs(version control system)版本控制系统</p>
</td>
<td valign="top" width="143">
<p class="a1">可以先存储在本地，不会存在服务器死机就影响工作，拥有丰富的资料来进行学习查阅，开源的，大小项目均可管理，拥有良好的分支机制</p>
</td>
<td valign="top" width="139">
<p class="a1">兼容性不好，可能在上个版本的项目内容放到另一个git版本会出错。</p>
</td>
</tr>
<tr>
<td valign="top" width="143">
<p class="a1">Gitup</p>
</td>
<td valign="top" width="143">
<p class="a1">&nbsp;</p>
</td>
<td valign="top" width="143">
<p class="a1">1、适合分布式开发，强调个体；</p>
<p class="a1">2、公共的服务器压力和数量都不会太大；</p>
<p class="a1">3、速度快， 成熟的架构，开发灵活；</p>
<p class="a1">4、任意两个开发者之间可以很容易的解决冲突；</p>
<p class="a1">5、离线工作，管理代码成本低，不需要依赖服务器；</p>
<p class="a1">6、部署方便。基本上下个命令就可以用；</p>
<p class="a1">7、良好的分支机制，可以让主干代码保持干净。</p>
</td>
<td valign="top" width="139">
<p class="a1">1、资料少，学习成本比较大，学习周期比较长，要求人员素质比较高；</p>
<p class="a1">2、不符合常规思维；</p>
<p class="a1">3、代码保密性差，一旦开发者把整个库克隆下来就可以完全公开所有代码和版本信息。</p>
<p class="a1">4、不支持中文，图形界面支持差，使用难度大。不易推广。</p>
</td>
</tr>
<tr>
<td valign="top" width="143">
<p class="a1">Rational</p>
</td>
<td valign="top" width="143">
<p class="a1">一种面向对象的统一建模语言的可视化建模工具。用于可视化建模和公司级水平软件应用的组件构造。</p>
</td>
<td valign="top" width="143">
<p class="a1">ROSE在UML建模方便太方便了，而且速度也比较快，支持分包，支持对软件过程的全程管理</p>
</td>
<td valign="top" width="139">
<p class="a1">ROSE好像不能做数据库设计，之前用的不支持c#，不能转化成c#框架代码，正逆向工程不是特别出色</p>
</td>
</tr>
</tbody>
</table>

</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>